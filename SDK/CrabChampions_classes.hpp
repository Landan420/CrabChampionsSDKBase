#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CrabChampions

#include "Basic.hpp"

#include "CrabChampions_structs.hpp"
#include "SlateCore_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class CrabChampions.CrabPickupDA
// 0x0080 (0x00B0 - 0x0030)
class UCrabPickupDA : public UDataAsset
{
public:
	bool                                          bRequiresUnlock;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabPickupType                               PickupType;                                        // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 LootPool;                                          // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabRarity                                   Rarity;                                            // 0x0062(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabPickupTag                                PickupTag;                                         // 0x0063(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresMatchingPickupTag;                        // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnWeight;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x006C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PrimaryFX;                                         // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SecondaryFX;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCrabInteractUI>            InteractUI;                                        // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                LocationUI;                                        // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         OnPickedUpFX;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnPickedUpSound;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPickupDA">();
	}
	static class UCrabPickupDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPickupDA>();
	}
};
static_assert(alignof(UCrabPickupDA) == 0x000008, "Wrong alignment on UCrabPickupDA");
static_assert(sizeof(UCrabPickupDA) == 0x0000B0, "Wrong size on UCrabPickupDA");
static_assert(offsetof(UCrabPickupDA, bRequiresUnlock) == 0x000030, "Member 'UCrabPickupDA::bRequiresUnlock' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Name_0) == 0x000038, "Member 'UCrabPickupDA::Name_0' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Description) == 0x000048, "Member 'UCrabPickupDA::Description' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Icon) == 0x000058, "Member 'UCrabPickupDA::Icon' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, PickupType) == 0x000060, "Member 'UCrabPickupDA::PickupType' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, LootPool) == 0x000061, "Member 'UCrabPickupDA::LootPool' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Rarity) == 0x000062, "Member 'UCrabPickupDA::Rarity' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, PickupTag) == 0x000063, "Member 'UCrabPickupDA::PickupTag' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, bRequiresMatchingPickupTag) == 0x000064, "Member 'UCrabPickupDA::bRequiresMatchingPickupTag' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, SpawnWeight) == 0x000068, "Member 'UCrabPickupDA::SpawnWeight' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Tint) == 0x00006C, "Member 'UCrabPickupDA::Tint' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, PrimaryFX) == 0x000080, "Member 'UCrabPickupDA::PrimaryFX' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, SecondaryFX) == 0x000088, "Member 'UCrabPickupDA::SecondaryFX' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, InteractUI) == 0x000090, "Member 'UCrabPickupDA::InteractUI' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, LocationUI) == 0x000098, "Member 'UCrabPickupDA::LocationUI' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, OnPickedUpFX) == 0x0000A0, "Member 'UCrabPickupDA::OnPickedUpFX' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, OnPickedUpSound) == 0x0000A8, "Member 'UCrabPickupDA::OnPickedUpSound' has a wrong offset!");

// Class CrabChampions.CrabGM
// 0x00D0 (0x0390 - 0x02C0)
class ACrabGM : public AGameModeBase
{
public:
	TSubclassOf<class ACrabPC>                    PCToSpawn;                                         // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugInitDelay;                                    // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugCurrentIsland;                                // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabIslandType                               DebugIslandType;                                   // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabChallengeModifier                        DebugChallengeModifier;                            // 0x02D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabBlessing                                 DebugBlessing;                                     // 0x02D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D3[0x5];                                      // 0x02D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabLM*                                LM;                                                // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x14];                                     // 0x02E0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WaitingForMorePlayersDelay;                        // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreStartDelay;                                     // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACrabC>                     CharacterToSpawn;                                  // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACrabPortal*, int32>               CurrentPortals;                                    // 0x0328(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class ACrabPortal*                            ChosenPortal;                                      // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugCompleteIsland();
	void DebugEndRun();
	void DebugGoToIsland(int32 IslandToGoTo);
	void DebugGoToNextBiome();
	void DebugGoToNextIsland();
	void OnNavigationGenerationFinished(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGM">();
	}
	static class ACrabGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabGM>();
	}
};
static_assert(alignof(ACrabGM) == 0x000008, "Wrong alignment on ACrabGM");
static_assert(sizeof(ACrabGM) == 0x000390, "Wrong size on ACrabGM");
static_assert(offsetof(ACrabGM, PCToSpawn) == 0x0002C0, "Member 'ACrabGM::PCToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugInitDelay) == 0x0002C8, "Member 'ACrabGM::DebugInitDelay' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugCurrentIsland) == 0x0002CC, "Member 'ACrabGM::DebugCurrentIsland' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugIslandType) == 0x0002D0, "Member 'ACrabGM::DebugIslandType' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugChallengeModifier) == 0x0002D1, "Member 'ACrabGM::DebugChallengeModifier' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugBlessing) == 0x0002D2, "Member 'ACrabGM::DebugBlessing' has a wrong offset!");
static_assert(offsetof(ACrabGM, LM) == 0x0002D8, "Member 'ACrabGM::LM' has a wrong offset!");
static_assert(offsetof(ACrabGM, WaitingForMorePlayersDelay) == 0x0002F4, "Member 'ACrabGM::WaitingForMorePlayersDelay' has a wrong offset!");
static_assert(offsetof(ACrabGM, PreStartDelay) == 0x0002F8, "Member 'ACrabGM::PreStartDelay' has a wrong offset!");
static_assert(offsetof(ACrabGM, CharacterToSpawn) == 0x000300, "Member 'ACrabGM::CharacterToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabGM, CurrentPortals) == 0x000328, "Member 'ACrabGM::CurrentPortals' has a wrong offset!");
static_assert(offsetof(ACrabGM, ChosenPortal) == 0x000378, "Member 'ACrabGM::ChosenPortal' has a wrong offset!");

// Class CrabChampions.CrabAbilityDA
// 0x0030 (0x00E0 - 0x00B0)
class UCrabAbilityDA final : public UCrabPickupDA
{
public:
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabHitmarkerType                            HitmarkerType;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabAbilitySpawnType                         AbilitySpawnType;                                  // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbilitySpawnDelay;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         AbilityTelegraphFX;                                // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AbilityTelegraphSound;                             // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAbilityDA">();
	}
	static class UCrabAbilityDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAbilityDA>();
	}
};
static_assert(alignof(UCrabAbilityDA) == 0x000008, "Wrong alignment on UCrabAbilityDA");
static_assert(sizeof(UCrabAbilityDA) == 0x0000E0, "Wrong size on UCrabAbilityDA");
static_assert(offsetof(UCrabAbilityDA, ProjectileDA) == 0x0000B0, "Member 'UCrabAbilityDA::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, HitmarkerType) == 0x0000B8, "Member 'UCrabAbilityDA::HitmarkerType' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, AbilitySpawnType) == 0x0000B9, "Member 'UCrabAbilityDA::AbilitySpawnType' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, AbilitySpawnDelay) == 0x0000BC, "Member 'UCrabAbilityDA::AbilitySpawnDelay' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, Cooldown) == 0x0000C0, "Member 'UCrabAbilityDA::Cooldown' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, Montage) == 0x0000C8, "Member 'UCrabAbilityDA::Montage' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, AbilityTelegraphFX) == 0x0000D0, "Member 'UCrabAbilityDA::AbilityTelegraphFX' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, AbilityTelegraphSound) == 0x0000D8, "Member 'UCrabAbilityDA::AbilityTelegraphSound' has a wrong offset!");

// Class CrabChampions.CrabInventoryDA
// 0x0028 (0x00D8 - 0x00B0)
class UCrabInventoryDA : public UCrabPickupDA
{
public:
	ECrabEnhanceableType                          EnhanceableType;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelDescription;                                  // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseBuff;                                          // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHyperbolicBuff;                                   // 0x00CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetBuffAsMultiplier;                              // 0x00CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDebuff;                                        // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHyperbolicDebuff;                                 // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetDebuffAsMultiplier;                            // 0x00D5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Cooldown;                                          // 0x00D6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventoryDA">();
	}
	static class UCrabInventoryDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventoryDA>();
	}
};
static_assert(alignof(UCrabInventoryDA) == 0x000008, "Wrong alignment on UCrabInventoryDA");
static_assert(sizeof(UCrabInventoryDA) == 0x0000D8, "Wrong size on UCrabInventoryDA");
static_assert(offsetof(UCrabInventoryDA, EnhanceableType) == 0x0000B0, "Member 'UCrabInventoryDA::EnhanceableType' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, LevelDescription) == 0x0000B8, "Member 'UCrabInventoryDA::LevelDescription' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, BaseBuff) == 0x0000C8, "Member 'UCrabInventoryDA::BaseBuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bHyperbolicBuff) == 0x0000CC, "Member 'UCrabInventoryDA::bHyperbolicBuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bGetBuffAsMultiplier) == 0x0000CD, "Member 'UCrabInventoryDA::bGetBuffAsMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, BaseDebuff) == 0x0000D0, "Member 'UCrabInventoryDA::BaseDebuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bHyperbolicDebuff) == 0x0000D4, "Member 'UCrabInventoryDA::bHyperbolicDebuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bGetDebuffAsMultiplier) == 0x0000D5, "Member 'UCrabInventoryDA::bGetDebuffAsMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, Cooldown) == 0x0000D6, "Member 'UCrabInventoryDA::Cooldown' has a wrong offset!");

// Class CrabChampions.CrabGS
// 0x0128 (0x0398 - 0x0270)
class ACrabGS final : public AGameStateBase
{
public:
	class ACrabLM*                                LM;                                                // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabMatchState                               MatchState;                                        // 0x0278(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x1F];                                     // 0x0279(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTimePaused;                                     // 0x0298(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTime;                                       // 0x029C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentCountdown;                                  // 0x02A0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDifficulty                               Difficulty;                                        // 0x02A4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x02A8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	ECrabBiome                                    Biome;                                             // 0x02B8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIsland;                                     // 0x02BC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabIslandType                               CurrentIslandType;                                 // 0x02C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIslandStartTime;                            // 0x02C4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x4];                                      // 0x02C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIslandTimeRemaining;                        // 0x02CC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         XLLevel;                                           // 0x02D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x02D8(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	ECrabBlessing                                 Blessing;                                          // 0x02E8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlessingProgress;                                  // 0x02EC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BlessingGoal;                                      // 0x02F0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabLootPool                                 RewardLootPool;                                    // 0x02F4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinigameScore;                                     // 0x02F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x9C];                                     // 0x02FC(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BlessingProgress();
	void OnRep_CurrentCountdown();
	void OnRep_CurrentIslandTimeRemaining();
	void OnRep_CurrentIslandType();
	void OnRep_CurrentTime();
	void OnRep_Difficulty();
	void OnRep_DifficultyModifiers();
	void OnRep_MatchState();
	void OnRep_MinigameScore();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGS">();
	}
	static class ACrabGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabGS>();
	}
};
static_assert(alignof(ACrabGS) == 0x000008, "Wrong alignment on ACrabGS");
static_assert(sizeof(ACrabGS) == 0x000398, "Wrong size on ACrabGS");
static_assert(offsetof(ACrabGS, LM) == 0x000270, "Member 'ACrabGS::LM' has a wrong offset!");
static_assert(offsetof(ACrabGS, MatchState) == 0x000278, "Member 'ACrabGS::MatchState' has a wrong offset!");
static_assert(offsetof(ACrabGS, bIsTimePaused) == 0x000298, "Member 'ACrabGS::bIsTimePaused' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentTime) == 0x00029C, "Member 'ACrabGS::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentCountdown) == 0x0002A0, "Member 'ACrabGS::CurrentCountdown' has a wrong offset!");
static_assert(offsetof(ACrabGS, Difficulty) == 0x0002A4, "Member 'ACrabGS::Difficulty' has a wrong offset!");
static_assert(offsetof(ACrabGS, DifficultyModifiers) == 0x0002A8, "Member 'ACrabGS::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(ACrabGS, Biome) == 0x0002B8, "Member 'ACrabGS::Biome' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIsland) == 0x0002BC, "Member 'ACrabGS::CurrentIsland' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIslandType) == 0x0002C0, "Member 'ACrabGS::CurrentIslandType' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIslandStartTime) == 0x0002C4, "Member 'ACrabGS::CurrentIslandStartTime' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIslandTimeRemaining) == 0x0002CC, "Member 'ACrabGS::CurrentIslandTimeRemaining' has a wrong offset!");
static_assert(offsetof(ACrabGS, XLLevel) == 0x0002D0, "Member 'ACrabGS::XLLevel' has a wrong offset!");
static_assert(offsetof(ACrabGS, ChallengeModifiers) == 0x0002D8, "Member 'ACrabGS::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(ACrabGS, Blessing) == 0x0002E8, "Member 'ACrabGS::Blessing' has a wrong offset!");
static_assert(offsetof(ACrabGS, BlessingProgress) == 0x0002EC, "Member 'ACrabGS::BlessingProgress' has a wrong offset!");
static_assert(offsetof(ACrabGS, BlessingGoal) == 0x0002F0, "Member 'ACrabGS::BlessingGoal' has a wrong offset!");
static_assert(offsetof(ACrabGS, RewardLootPool) == 0x0002F4, "Member 'ACrabGS::RewardLootPool' has a wrong offset!");
static_assert(offsetof(ACrabGS, MinigameScore) == 0x0002F8, "Member 'ACrabGS::MinigameScore' has a wrong offset!");

// Class CrabChampions.CrabAbilityModDA
// 0x0008 (0x00E0 - 0x00D8)
class UCrabAbilityModDA final : public UCrabInventoryDA
{
public:
	ECrabAbilityModType                           AbilityModType;                                    // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAbilityModDA">();
	}
	static class UCrabAbilityModDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAbilityModDA>();
	}
};
static_assert(alignof(UCrabAbilityModDA) == 0x000008, "Wrong alignment on UCrabAbilityModDA");
static_assert(sizeof(UCrabAbilityModDA) == 0x0000E0, "Wrong size on UCrabAbilityModDA");
static_assert(offsetof(UCrabAbilityModDA, AbilityModType) == 0x0000D8, "Member 'UCrabAbilityModDA::AbilityModType' has a wrong offset!");

// Class CrabChampions.CrabHarvestArea
// 0x0090 (0x02B0 - 0x0220)
class ACrabHarvestArea : public AActor
{
public:
	class UNiagaraComponent*                      HarvestAreaNC;                                     // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       HarvestAreaWC;                                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HarvestAreaFX;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabHarvestAreaType                          HarvestAreaType;                                   // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           OverlappingPlayerC;                                // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateRate;                                        // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialCountdown;                                  // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x4];                                      // 0x0268(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmountToDecrement;                                 // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmountToIncrement;                                 // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         HarvestCountdownFX;                                // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HarvestCountdownSound;                             // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HarvestClearFX;                                    // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HarvestClearSound;                                 // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                PlayerToRevive;                                    // 0x0298(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabRevivalUI>             RevivalUIToSpawn;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabRevivalUI*                         RevivalUI;                                         // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MulticastOnCountdownUpdated(uint8 PercentComplete);
	void MulticastOnHarvestAreaCleared();
	void OnRep_PlayerToRevive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHarvestArea">();
	}
	static class ACrabHarvestArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabHarvestArea>();
	}
};
static_assert(alignof(ACrabHarvestArea) == 0x000008, "Wrong alignment on ACrabHarvestArea");
static_assert(sizeof(ACrabHarvestArea) == 0x0002B0, "Wrong size on ACrabHarvestArea");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaNC) == 0x000220, "Member 'ACrabHarvestArea::HarvestAreaNC' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaWC) == 0x000228, "Member 'ACrabHarvestArea::HarvestAreaWC' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaFX) == 0x000230, "Member 'ACrabHarvestArea::HarvestAreaFX' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaType) == 0x000238, "Member 'ACrabHarvestArea::HarvestAreaType' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, Radius) == 0x00023C, "Member 'ACrabHarvestArea::Radius' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, Tint) == 0x000240, "Member 'ACrabHarvestArea::Tint' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, OverlappingPlayerC) == 0x000250, "Member 'ACrabHarvestArea::OverlappingPlayerC' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, UpdateRate) == 0x000260, "Member 'ACrabHarvestArea::UpdateRate' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, InitialCountdown) == 0x000264, "Member 'ACrabHarvestArea::InitialCountdown' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, AmountToDecrement) == 0x00026C, "Member 'ACrabHarvestArea::AmountToDecrement' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, AmountToIncrement) == 0x000270, "Member 'ACrabHarvestArea::AmountToIncrement' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestCountdownFX) == 0x000278, "Member 'ACrabHarvestArea::HarvestCountdownFX' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestCountdownSound) == 0x000280, "Member 'ACrabHarvestArea::HarvestCountdownSound' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestClearFX) == 0x000288, "Member 'ACrabHarvestArea::HarvestClearFX' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestClearSound) == 0x000290, "Member 'ACrabHarvestArea::HarvestClearSound' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, PlayerToRevive) == 0x000298, "Member 'ACrabHarvestArea::PlayerToRevive' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, RevivalUIToSpawn) == 0x0002A0, "Member 'ACrabHarvestArea::RevivalUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, RevivalUI) == 0x0002A8, "Member 'ACrabHarvestArea::RevivalUI' has a wrong offset!");

// Class CrabChampions.CrabActionDA
// 0x0038 (0x0068 - 0x0030)
class UCrabActionDA : public UDataAsset
{
public:
	float                                         Range;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresLOS;                                      // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeGrounded;                                   // 0x0035(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMovementDuringAction;                         // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFocusDuringAction;                           // 0x003D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopingActionInterval;                             // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXSocketName;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FX;                                                // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Sound;                                             // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabActionDA">();
	}
	static class UCrabActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabActionDA>();
	}
};
static_assert(alignof(UCrabActionDA) == 0x000008, "Wrong alignment on UCrabActionDA");
static_assert(sizeof(UCrabActionDA) == 0x000068, "Wrong size on UCrabActionDA");
static_assert(offsetof(UCrabActionDA, Range) == 0x000030, "Member 'UCrabActionDA::Range' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bRequiresLOS) == 0x000034, "Member 'UCrabActionDA::bRequiresLOS' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bMustBeGrounded) == 0x000035, "Member 'UCrabActionDA::bMustBeGrounded' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, Weight) == 0x000038, "Member 'UCrabActionDA::Weight' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bStopMovementDuringAction) == 0x00003C, "Member 'UCrabActionDA::bStopMovementDuringAction' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bClearFocusDuringAction) == 0x00003D, "Member 'UCrabActionDA::bClearFocusDuringAction' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, LoopingActionInterval) == 0x000040, "Member 'UCrabActionDA::LoopingActionInterval' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, Montage) == 0x000048, "Member 'UCrabActionDA::Montage' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, FXSocketName) == 0x000050, "Member 'UCrabActionDA::FXSocketName' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, FX) == 0x000058, "Member 'UCrabActionDA::FX' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, Sound) == 0x000060, "Member 'UCrabActionDA::Sound' has a wrong offset!");

// Class CrabChampions.CrabHC
// 0x0080 (0x0130 - 0x00B0)
class UCrabHC final : public UActorComponent
{
public:
	class ACrabC*                                 OwningC;                                           // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BaseArmorPlates;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseMaxHealth;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldRegenerateHealth;                           // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRegenerationAmount;                          // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBeEliminated;                                  // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasOneShotProtection;                             // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasDeathProtection;                               // 0x00FA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB[0x1];                                       // 0x00FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x00FC(0x001C)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HealthInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHC">();
	}
	static class UCrabHC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabHC>();
	}
};
static_assert(alignof(UCrabHC) == 0x000008, "Wrong alignment on UCrabHC");
static_assert(sizeof(UCrabHC) == 0x000130, "Wrong size on UCrabHC");
static_assert(offsetof(UCrabHC, OwningC) == 0x0000B0, "Member 'UCrabHC::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabHC, BaseArmorPlates) == 0x0000B8, "Member 'UCrabHC::BaseArmorPlates' has a wrong offset!");
static_assert(offsetof(UCrabHC, BaseMaxHealth) == 0x0000C0, "Member 'UCrabHC::BaseMaxHealth' has a wrong offset!");
static_assert(offsetof(UCrabHC, bShouldRegenerateHealth) == 0x0000D0, "Member 'UCrabHC::bShouldRegenerateHealth' has a wrong offset!");
static_assert(offsetof(UCrabHC, HealthRegenerationAmount) == 0x0000D4, "Member 'UCrabHC::HealthRegenerationAmount' has a wrong offset!");
static_assert(offsetof(UCrabHC, bCanBeEliminated) == 0x0000F8, "Member 'UCrabHC::bCanBeEliminated' has a wrong offset!");
static_assert(offsetof(UCrabHC, bHasOneShotProtection) == 0x0000F9, "Member 'UCrabHC::bHasOneShotProtection' has a wrong offset!");
static_assert(offsetof(UCrabHC, bHasDeathProtection) == 0x0000FA, "Member 'UCrabHC::bHasDeathProtection' has a wrong offset!");
static_assert(offsetof(UCrabHC, HealthInfo) == 0x0000FC, "Member 'UCrabHC::HealthInfo' has a wrong offset!");

// Class CrabChampions.CrabAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UCrabAnimInstance : public UAnimInstance
{
public:
	class ACrabC*                                 OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Pitch;                                             // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Direction;                                         // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x02CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKnockedBack;                                    // 0x02CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAnimInstance">();
	}
	static class UCrabAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAnimInstance>();
	}
};
static_assert(alignof(UCrabAnimInstance) == 0x000010, "Wrong alignment on UCrabAnimInstance");
static_assert(sizeof(UCrabAnimInstance) == 0x0002D0, "Wrong size on UCrabAnimInstance");
static_assert(offsetof(UCrabAnimInstance, OwningC) == 0x0002B8, "Member 'UCrabAnimInstance::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, Pitch) == 0x0002C0, "Member 'UCrabAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, Direction) == 0x0002C4, "Member 'UCrabAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, Speed) == 0x0002C8, "Member 'UCrabAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, bIsFalling) == 0x0002CC, "Member 'UCrabAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, bIsKnockedBack) == 0x0002CD, "Member 'UCrabAnimInstance::bIsKnockedBack' has a wrong offset!");

// Class CrabChampions.CrabUI
// 0x0058 (0x02B8 - 0x0260)
class UCrabUI : public UUserWidget
{
public:
	uint8                                         Pad_260[0x58];                                     // 0x0260(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabUI">();
	}
	static class UCrabUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabUI>();
	}
};
static_assert(alignof(UCrabUI) == 0x000008, "Wrong alignment on UCrabUI");
static_assert(sizeof(UCrabUI) == 0x0002B8, "Wrong size on UCrabUI");

// Class CrabChampions.CrabHealthBarUI
// 0x00A0 (0x0358 - 0x02B8)
class UCrabHealthBarUI : public UCrabUI
{
public:
	class ACrabC*                                 OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BuffText;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OwnerNameText;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ArmorPlatesHorizontalBox;                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           HealthBar;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           RecentDamageHealthBar;                             // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentHealthText;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentMaxHealthText;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               IceStackOverlay;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IceStackText;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               FireStackOverlay;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FireStackText;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               LightningStackOverlay;                             // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LightningStackText;                                // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               PoisonStackOverlay;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PoisonStackText;                                   // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ArcaneStackOverlay;                                // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ArcaneStackText;                                   // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHealthBarUI">();
	}
	static class UCrabHealthBarUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabHealthBarUI>();
	}
};
static_assert(alignof(UCrabHealthBarUI) == 0x000008, "Wrong alignment on UCrabHealthBarUI");
static_assert(sizeof(UCrabHealthBarUI) == 0x000358, "Wrong size on UCrabHealthBarUI");
static_assert(offsetof(UCrabHealthBarUI, OwningC) == 0x0002B8, "Member 'UCrabHealthBarUI::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, BuffText) == 0x0002C0, "Member 'UCrabHealthBarUI::BuffText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, OwnerNameText) == 0x0002C8, "Member 'UCrabHealthBarUI::OwnerNameText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ArmorPlatesHorizontalBox) == 0x0002D0, "Member 'UCrabHealthBarUI::ArmorPlatesHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, HealthBar) == 0x0002D8, "Member 'UCrabHealthBarUI::HealthBar' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, RecentDamageHealthBar) == 0x0002E0, "Member 'UCrabHealthBarUI::RecentDamageHealthBar' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, CurrentHealthText) == 0x0002E8, "Member 'UCrabHealthBarUI::CurrentHealthText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, CurrentMaxHealthText) == 0x0002F0, "Member 'UCrabHealthBarUI::CurrentMaxHealthText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, IceStackOverlay) == 0x0002F8, "Member 'UCrabHealthBarUI::IceStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, IceStackText) == 0x000300, "Member 'UCrabHealthBarUI::IceStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, FireStackOverlay) == 0x000308, "Member 'UCrabHealthBarUI::FireStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, FireStackText) == 0x000310, "Member 'UCrabHealthBarUI::FireStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, LightningStackOverlay) == 0x000318, "Member 'UCrabHealthBarUI::LightningStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, LightningStackText) == 0x000320, "Member 'UCrabHealthBarUI::LightningStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, PoisonStackOverlay) == 0x000328, "Member 'UCrabHealthBarUI::PoisonStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, PoisonStackText) == 0x000330, "Member 'UCrabHealthBarUI::PoisonStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ArcaneStackOverlay) == 0x000338, "Member 'UCrabHealthBarUI::ArcaneStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ArcaneStackText) == 0x000340, "Member 'UCrabHealthBarUI::ArcaneStackText' has a wrong offset!");

// Class CrabChampions.CrabInteractable
// 0x0058 (0x0278 - 0x0220)
class ACrabInteractable : public AActor
{
public:
	class USphereComponent*                       InteractableCollision;                             // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       InteractWC;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInteractUI>            InteractUIToSpawn;                                 // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInteractUI*                        InteractUI;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractUIHeightOffset;                            // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractMessage;                                   // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x4];                                      // 0x0258(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractCooldown;                                  // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInteractable">();
	}
	static class ACrabInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabInteractable>();
	}
};
static_assert(alignof(ACrabInteractable) == 0x000008, "Wrong alignment on ACrabInteractable");
static_assert(sizeof(ACrabInteractable) == 0x000278, "Wrong size on ACrabInteractable");
static_assert(offsetof(ACrabInteractable, InteractableCollision) == 0x000220, "Member 'ACrabInteractable::InteractableCollision' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractWC) == 0x000228, "Member 'ACrabInteractable::InteractWC' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractUIToSpawn) == 0x000230, "Member 'ACrabInteractable::InteractUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractUI) == 0x000238, "Member 'ACrabInteractable::InteractUI' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractUIHeightOffset) == 0x000240, "Member 'ACrabInteractable::InteractUIHeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractMessage) == 0x000248, "Member 'ACrabInteractable::InteractMessage' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractCooldown) == 0x00025C, "Member 'ACrabInteractable::InteractCooldown' has a wrong offset!");

// Class CrabChampions.CrabOverlapPickup
// 0x0048 (0x0268 - 0x0220)
class ACrabOverlapPickup : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      PickupNC;                                          // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       PickupCollision;                                   // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapRadius;                                     // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PickupFX;                                          // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           PickedUpByC;                                       // 0x0248(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              OnPickedUpSound;                                   // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_PickedUpByC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabOverlapPickup">();
	}
	static class ACrabOverlapPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabOverlapPickup>();
	}
};
static_assert(alignof(ACrabOverlapPickup) == 0x000008, "Wrong alignment on ACrabOverlapPickup");
static_assert(sizeof(ACrabOverlapPickup) == 0x000268, "Wrong size on ACrabOverlapPickup");
static_assert(offsetof(ACrabOverlapPickup, PickupNC) == 0x000228, "Member 'ACrabOverlapPickup::PickupNC' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, PickupCollision) == 0x000230, "Member 'ACrabOverlapPickup::PickupCollision' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, OverlapRadius) == 0x000238, "Member 'ACrabOverlapPickup::OverlapRadius' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, LifeTime) == 0x00023C, "Member 'ACrabOverlapPickup::LifeTime' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, PickupFX) == 0x000240, "Member 'ACrabOverlapPickup::PickupFX' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, PickedUpByC) == 0x000248, "Member 'ACrabOverlapPickup::PickedUpByC' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, OnPickedUpSound) == 0x000260, "Member 'ACrabOverlapPickup::OnPickedUpSound' has a wrong offset!");

// Class CrabChampions.CrabHealthPickup
// 0x0008 (0x0270 - 0x0268)
class ACrabHealthPickup : public ACrabOverlapPickup
{
public:
	float                                         HealthToGive;                                      // 0x0268(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HealthToGive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHealthPickup">();
	}
	static class ACrabHealthPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabHealthPickup>();
	}
};
static_assert(alignof(ACrabHealthPickup) == 0x000008, "Wrong alignment on ACrabHealthPickup");
static_assert(sizeof(ACrabHealthPickup) == 0x000270, "Wrong size on ACrabHealthPickup");
static_assert(offsetof(ACrabHealthPickup, HealthToGive) == 0x000268, "Member 'ACrabHealthPickup::HealthToGive' has a wrong offset!");

// Class CrabChampions.CrabAnvil
// 0x0070 (0x02E8 - 0x0278)
class ACrabAnvil : public ACrabInteractable
{
public:
	class UStaticMeshComponent*                   AnvilMesh;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AnvilNC;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       AnvilLocationWC;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      HammerSlamNC;                                      // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Mesh;                                              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabEnhancementType                          EnhancementType;                                   // 0x02A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x17];                                     // 0x02A1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x02C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                AnvilLocationUI;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HammerSlamFX;                                      // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HammerSlamSound;                                   // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastApplyEnhancement();
	void OnRep_EnhancementType();
	void OnRep_OwningPS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAnvil">();
	}
	static class ACrabAnvil* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabAnvil>();
	}
};
static_assert(alignof(ACrabAnvil) == 0x000008, "Wrong alignment on ACrabAnvil");
static_assert(sizeof(ACrabAnvil) == 0x0002E8, "Wrong size on ACrabAnvil");
static_assert(offsetof(ACrabAnvil, AnvilMesh) == 0x000278, "Member 'ACrabAnvil::AnvilMesh' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, AnvilNC) == 0x000280, "Member 'ACrabAnvil::AnvilNC' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, AnvilLocationWC) == 0x000288, "Member 'ACrabAnvil::AnvilLocationWC' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, HammerSlamNC) == 0x000290, "Member 'ACrabAnvil::HammerSlamNC' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, Mesh) == 0x000298, "Member 'ACrabAnvil::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, EnhancementType) == 0x0002A0, "Member 'ACrabAnvil::EnhancementType' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, FX) == 0x0002B8, "Member 'ACrabAnvil::FX' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, OwningPS) == 0x0002C0, "Member 'ACrabAnvil::OwningPS' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, AnvilLocationUI) == 0x0002C8, "Member 'ACrabAnvil::AnvilLocationUI' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, HammerSlamFX) == 0x0002D0, "Member 'ACrabAnvil::HammerSlamFX' has a wrong offset!");
static_assert(offsetof(ACrabAnvil, HammerSlamSound) == 0x0002D8, "Member 'ACrabAnvil::HammerSlamSound' has a wrong offset!");

// Class CrabChampions.CrabFocusMenuUI
// 0x0118 (0x03D0 - 0x02B8)
class UCrabFocusMenuUI : public UCrabUI
{
public:
	class UWidgetSwitcher*                        MenuWidgetSwitcher;                                // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        FocusableWidgetArray;                              // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ACrabPC*                                OwningPC;                                          // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x70];                                     // 0x02D8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                PreviouslyFocusedWidget;                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MenuCanvasPanel;                                   // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ResetFocusButton;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HoverSound;                                        // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PressSound;                                        // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MenuActionKeyText;                                 // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MenuActionControllerIcon;                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MenuBackKeyText;                                   // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MenuBackControllerIcon;                            // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NextSubmenuKeyText;                                // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NextSubmenuIcon;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PreviousSubmenuKeyText;                            // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PreviousSubmenuIcon;                               // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SubmenuHorizontalBox;                              // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                ActionButton;                                      // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BackButton;                                        // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedActionButton();
	void OnPressedBackButton();
	void OnPressedResetFocusButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabFocusMenuUI">();
	}
	static class UCrabFocusMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabFocusMenuUI>();
	}
};
static_assert(alignof(UCrabFocusMenuUI) == 0x000008, "Wrong alignment on UCrabFocusMenuUI");
static_assert(sizeof(UCrabFocusMenuUI) == 0x0003D0, "Wrong size on UCrabFocusMenuUI");
static_assert(offsetof(UCrabFocusMenuUI, MenuWidgetSwitcher) == 0x0002B8, "Member 'UCrabFocusMenuUI::MenuWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, FocusableWidgetArray) == 0x0002C0, "Member 'UCrabFocusMenuUI::FocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, OwningPC) == 0x0002D0, "Member 'UCrabFocusMenuUI::OwningPC' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PreviouslyFocusedWidget) == 0x000348, "Member 'UCrabFocusMenuUI::PreviouslyFocusedWidget' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuCanvasPanel) == 0x000350, "Member 'UCrabFocusMenuUI::MenuCanvasPanel' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, ResetFocusButton) == 0x000358, "Member 'UCrabFocusMenuUI::ResetFocusButton' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, HoverSound) == 0x000360, "Member 'UCrabFocusMenuUI::HoverSound' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PressSound) == 0x000368, "Member 'UCrabFocusMenuUI::PressSound' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuActionKeyText) == 0x000370, "Member 'UCrabFocusMenuUI::MenuActionKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuActionControllerIcon) == 0x000378, "Member 'UCrabFocusMenuUI::MenuActionControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuBackKeyText) == 0x000380, "Member 'UCrabFocusMenuUI::MenuBackKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuBackControllerIcon) == 0x000388, "Member 'UCrabFocusMenuUI::MenuBackControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, NextSubmenuKeyText) == 0x000390, "Member 'UCrabFocusMenuUI::NextSubmenuKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, NextSubmenuIcon) == 0x000398, "Member 'UCrabFocusMenuUI::NextSubmenuIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PreviousSubmenuKeyText) == 0x0003A0, "Member 'UCrabFocusMenuUI::PreviousSubmenuKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PreviousSubmenuIcon) == 0x0003A8, "Member 'UCrabFocusMenuUI::PreviousSubmenuIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, SubmenuHorizontalBox) == 0x0003B0, "Member 'UCrabFocusMenuUI::SubmenuHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, ActionButton) == 0x0003C0, "Member 'UCrabFocusMenuUI::ActionButton' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, BackButton) == 0x0003C8, "Member 'UCrabFocusMenuUI::BackButton' has a wrong offset!");

// Class CrabChampions.CrabInGameMenuUI
// 0x0060 (0x0430 - 0x03D0)
class UCrabInGameMenuUI : public UCrabFocusMenuUI
{
public:
	class UCrabConfirmationPromptUI*              ConfirmationPrompt;                                // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSettingsMenuUI*                    SettingsMenu;                                      // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ResumeButton;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuickRestartButton;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SettingsButton;                                    // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                FeedbackButton;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuitToLobbyButton;                                 // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuitToDesktopButton;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabConfirmationPromptUI*              QuitConfirmationPromptUI;                          // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredFeedbackButton();
	void OnHoveredQuickRestartButton();
	void OnHoveredQuitToDesktopButton();
	void OnHoveredQuitToLobbyButton();
	void OnHoveredResumeButton();
	void OnHoveredSettingsButton();
	void OnPressedFeedbackButton();
	void OnPressedQuickRestartButton();
	void OnPressedQuitToDesktopButton();
	void OnPressedQuitToLobbyButton();
	void OnPressedResumeButton();
	void OnPressedSettingsButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInGameMenuUI">();
	}
	static class UCrabInGameMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInGameMenuUI>();
	}
};
static_assert(alignof(UCrabInGameMenuUI) == 0x000008, "Wrong alignment on UCrabInGameMenuUI");
static_assert(sizeof(UCrabInGameMenuUI) == 0x000430, "Wrong size on UCrabInGameMenuUI");
static_assert(offsetof(UCrabInGameMenuUI, ConfirmationPrompt) == 0x0003D0, "Member 'UCrabInGameMenuUI::ConfirmationPrompt' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, SettingsMenu) == 0x0003D8, "Member 'UCrabInGameMenuUI::SettingsMenu' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, ResumeButton) == 0x0003E0, "Member 'UCrabInGameMenuUI::ResumeButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuickRestartButton) == 0x0003E8, "Member 'UCrabInGameMenuUI::QuickRestartButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, SettingsButton) == 0x0003F0, "Member 'UCrabInGameMenuUI::SettingsButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, FeedbackButton) == 0x0003F8, "Member 'UCrabInGameMenuUI::FeedbackButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuitToLobbyButton) == 0x000400, "Member 'UCrabInGameMenuUI::QuitToLobbyButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuitToDesktopButton) == 0x000408, "Member 'UCrabInGameMenuUI::QuitToDesktopButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuitConfirmationPromptUI) == 0x000410, "Member 'UCrabInGameMenuUI::QuitConfirmationPromptUI' has a wrong offset!");

// Class CrabChampions.CrabAOEActionDA
// 0x0008 (0x0070 - 0x0068)
class UCrabAOEActionDA final : public UCrabActionDA
{
public:
	class UCrabAOEDA*                             AOEDA;                                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAOEActionDA">();
	}
	static class UCrabAOEActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAOEActionDA>();
	}
};
static_assert(alignof(UCrabAOEActionDA) == 0x000008, "Wrong alignment on UCrabAOEActionDA");
static_assert(sizeof(UCrabAOEActionDA) == 0x000070, "Wrong size on UCrabAOEActionDA");
static_assert(offsetof(UCrabAOEActionDA, AOEDA) == 0x000068, "Member 'UCrabAOEActionDA::AOEDA' has a wrong offset!");

// Class CrabChampions.CrabInteractPickup
// 0x0090 (0x0308 - 0x0278)
class ACrabInteractPickup final : public ACrabInteractable
{
public:
	class UNiagaraComponent*                      PickupPrimaryNC;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PickupSecondaryNC;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PickupLocationWC;                                  // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabPickupInfo                        PickupInfo;                                        // 0x0290(0x0050)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         NumTimesPickedUp;                                  // 0x0300(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPickupDeactivated;                              // 0x0301(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsPickupDeactivated();
	void OnRep_NumTimesPickedUp();
	void OnRep_PickupInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInteractPickup">();
	}
	static class ACrabInteractPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabInteractPickup>();
	}
};
static_assert(alignof(ACrabInteractPickup) == 0x000008, "Wrong alignment on ACrabInteractPickup");
static_assert(sizeof(ACrabInteractPickup) == 0x000308, "Wrong size on ACrabInteractPickup");
static_assert(offsetof(ACrabInteractPickup, PickupPrimaryNC) == 0x000278, "Member 'ACrabInteractPickup::PickupPrimaryNC' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, PickupSecondaryNC) == 0x000280, "Member 'ACrabInteractPickup::PickupSecondaryNC' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, PickupLocationWC) == 0x000288, "Member 'ACrabInteractPickup::PickupLocationWC' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, PickupInfo) == 0x000290, "Member 'ACrabInteractPickup::PickupInfo' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, NumTimesPickedUp) == 0x000300, "Member 'ACrabInteractPickup::NumTimesPickedUp' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, bIsPickupDeactivated) == 0x000301, "Member 'ACrabInteractPickup::bIsPickupDeactivated' has a wrong offset!");

// Class CrabChampions.CrabAOEDA
// 0x0038 (0x0068 - 0x0030)
class UCrabAOEDA final : public UDataAsset
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDamageType                               DamageType;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockbackStrength;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawn;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         AOEFX;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AOESound;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAOEDA">();
	}
	static class UCrabAOEDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAOEDA>();
	}
};
static_assert(alignof(UCrabAOEDA) == 0x000008, "Wrong alignment on UCrabAOEDA");
static_assert(sizeof(UCrabAOEDA) == 0x000068, "Wrong size on UCrabAOEDA");
static_assert(offsetof(UCrabAOEDA, SocketName) == 0x000030, "Member 'UCrabAOEDA::SocketName' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, Radius) == 0x000038, "Member 'UCrabAOEDA::Radius' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, Damage) == 0x00003C, "Member 'UCrabAOEDA::Damage' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, DamageType) == 0x000040, "Member 'UCrabAOEDA::DamageType' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, KnockbackStrength) == 0x000044, "Member 'UCrabAOEDA::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, DamageAreaToSpawn) == 0x000048, "Member 'UCrabAOEDA::DamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, AOEFX) == 0x000050, "Member 'UCrabAOEDA::AOEFX' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, AOESound) == 0x000058, "Member 'UCrabAOEDA::AOESound' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, CameraShake) == 0x000060, "Member 'UCrabAOEDA::CameraShake' has a wrong offset!");

// Class CrabChampions.CrabInventoryEventUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabInventoryEventUI : public UCrabUI
{
public:
	class UTextBlock*                             InventoryEventMessageText;                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       InventoryEventAnim;                                // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventoryEventUI">();
	}
	static class UCrabInventoryEventUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventoryEventUI>();
	}
};
static_assert(alignof(UCrabInventoryEventUI) == 0x000008, "Wrong alignment on UCrabInventoryEventUI");
static_assert(sizeof(UCrabInventoryEventUI) == 0x0002C8, "Wrong size on UCrabInventoryEventUI");
static_assert(offsetof(UCrabInventoryEventUI, InventoryEventMessageText) == 0x0002B8, "Member 'UCrabInventoryEventUI::InventoryEventMessageText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryEventUI, InventoryEventAnim) == 0x0002C0, "Member 'UCrabInventoryEventUI::InventoryEventAnim' has a wrong offset!");

// Class CrabChampions.CrabInventorySlotUI
// 0x0068 (0x0320 - 0x02B8)
class UCrabInventorySlotUI : public UCrabUI
{
public:
	class UCrabInventoryUI*                       OwningInventoryUI;                                 // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInventoryDA*                       InventoryDA;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x02C8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	class UOverlay*                               SlotOverlay;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SlotButton;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotLockedImage;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 SlotIconImage;                                     // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SlotLevelText;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotEnhanceableIconImage;                          // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredSlotButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventorySlotUI">();
	}
	static class UCrabInventorySlotUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventorySlotUI>();
	}
};
static_assert(alignof(UCrabInventorySlotUI) == 0x000008, "Wrong alignment on UCrabInventorySlotUI");
static_assert(sizeof(UCrabInventorySlotUI) == 0x000320, "Wrong size on UCrabInventorySlotUI");
static_assert(offsetof(UCrabInventorySlotUI, OwningInventoryUI) == 0x0002B8, "Member 'UCrabInventorySlotUI::OwningInventoryUI' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, InventoryDA) == 0x0002C0, "Member 'UCrabInventorySlotUI::InventoryDA' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, InventoryInfo) == 0x0002C8, "Member 'UCrabInventorySlotUI::InventoryInfo' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotOverlay) == 0x0002E8, "Member 'UCrabInventorySlotUI::SlotOverlay' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotButton) == 0x0002F0, "Member 'UCrabInventorySlotUI::SlotButton' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotLockedImage) == 0x0002F8, "Member 'UCrabInventorySlotUI::SlotLockedImage' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotIconImage) == 0x000308, "Member 'UCrabInventorySlotUI::SlotIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotLevelText) == 0x000310, "Member 'UCrabInventorySlotUI::SlotLevelText' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotEnhanceableIconImage) == 0x000318, "Member 'UCrabInventorySlotUI::SlotEnhanceableIconImage' has a wrong offset!");

// Class CrabChampions.CrabArrowSelectionUI
// 0x0050 (0x0308 - 0x02B8)
class UCrabArrowSelectionUI : public UCrabUI
{
public:
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CurrentSelectionText;                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NextButton;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                PreviousButton;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredNextButton();
	void OnHoveredPreviousButton();
	void OnPressedNextButton();
	void OnPressedPreviousButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabArrowSelectionUI">();
	}
	static class UCrabArrowSelectionUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabArrowSelectionUI>();
	}
};
static_assert(alignof(UCrabArrowSelectionUI) == 0x000008, "Wrong alignment on UCrabArrowSelectionUI");
static_assert(sizeof(UCrabArrowSelectionUI) == 0x000308, "Wrong size on UCrabArrowSelectionUI");
static_assert(offsetof(UCrabArrowSelectionUI, CurrentSelectionText) == 0x0002D8, "Member 'UCrabArrowSelectionUI::CurrentSelectionText' has a wrong offset!");
static_assert(offsetof(UCrabArrowSelectionUI, NextButton) == 0x0002E0, "Member 'UCrabArrowSelectionUI::NextButton' has a wrong offset!");
static_assert(offsetof(UCrabArrowSelectionUI, PreviousButton) == 0x0002E8, "Member 'UCrabArrowSelectionUI::PreviousButton' has a wrong offset!");

// Class CrabChampions.CrabInventoryUI
// 0x0150 (0x0520 - 0x03D0)
class UCrabInventoryUI : public UCrabFocusMenuUI
{
public:
	class ACrabPS*                                OwningPS;                                          // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInventorySlotUI*                   HoveredInventorySlotUI;                            // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CrystalsText;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KeysText;                                          // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      WeaponModUniformGridPanel;                         // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      AbilityModUniformGridPanel;                        // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      MeleeModUniformGridPanel;                          // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      PerkUniformGridPanel;                              // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      RelicUniformGridPanel;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SelectedSlotSizeBox;                               // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectedSlotBackgroundImage;                       // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectedSlotIconImage;                             // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotNameText;                              // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotLevelText;                             // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotRarityText;                            // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotEnhanceableHorizontalBox;              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotLootPoolText;                          // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotLevelDescriptionText;                  // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotCooldownHorizontalBox;                 // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotCooldownText;                          // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotAccumulatedBuffHorizontalBox;          // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotAccumulatedBuffText;                   // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           EnhancementsVerticalBox;                           // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabEnhancementUI>         EnhancementUIToSpawn;                              // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SelectedSlotDropButtonOverlay;                     // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotDropText;                              // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SelectedSlotLockedIcon;                            // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotCostHorizontalBox;                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotCostText;                              // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SelectedSlotUnlockSound;                           // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                DropCrystalsButton;                                // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BaseMaxHealthStatText;                             // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MaxHealthMultiplierStatText;                       // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IncomingDamageStatText;                            // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FireRateStatText;                                  // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponDamageStatText;                              // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityDamageStatText;                             // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeDamageStatText;                               // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GlobalDamageStatText;                              // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CriticalHitChanceStatText;                         // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CriticalHitDamageStatText;                         // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CrystalGainStatText;                               // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedDropCrystalsButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventoryUI">();
	}
	static class UCrabInventoryUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventoryUI>();
	}
};
static_assert(alignof(UCrabInventoryUI) == 0x000008, "Wrong alignment on UCrabInventoryUI");
static_assert(sizeof(UCrabInventoryUI) == 0x000520, "Wrong size on UCrabInventoryUI");
static_assert(offsetof(UCrabInventoryUI, OwningPS) == 0x0003D0, "Member 'UCrabInventoryUI::OwningPS' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, HoveredInventorySlotUI) == 0x0003D8, "Member 'UCrabInventoryUI::HoveredInventorySlotUI' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CrystalsText) == 0x0003E0, "Member 'UCrabInventoryUI::CrystalsText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, KeysText) == 0x0003E8, "Member 'UCrabInventoryUI::KeysText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, WeaponModUniformGridPanel) == 0x0003F0, "Member 'UCrabInventoryUI::WeaponModUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, AbilityModUniformGridPanel) == 0x0003F8, "Member 'UCrabInventoryUI::AbilityModUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, MeleeModUniformGridPanel) == 0x000400, "Member 'UCrabInventoryUI::MeleeModUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, PerkUniformGridPanel) == 0x000408, "Member 'UCrabInventoryUI::PerkUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, RelicUniformGridPanel) == 0x000410, "Member 'UCrabInventoryUI::RelicUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotSizeBox) == 0x000418, "Member 'UCrabInventoryUI::SelectedSlotSizeBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotBackgroundImage) == 0x000420, "Member 'UCrabInventoryUI::SelectedSlotBackgroundImage' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotIconImage) == 0x000428, "Member 'UCrabInventoryUI::SelectedSlotIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotNameText) == 0x000430, "Member 'UCrabInventoryUI::SelectedSlotNameText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLevelText) == 0x000438, "Member 'UCrabInventoryUI::SelectedSlotLevelText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotRarityText) == 0x000440, "Member 'UCrabInventoryUI::SelectedSlotRarityText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotEnhanceableHorizontalBox) == 0x000448, "Member 'UCrabInventoryUI::SelectedSlotEnhanceableHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLootPoolText) == 0x000450, "Member 'UCrabInventoryUI::SelectedSlotLootPoolText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLevelDescriptionText) == 0x000458, "Member 'UCrabInventoryUI::SelectedSlotLevelDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCooldownHorizontalBox) == 0x000460, "Member 'UCrabInventoryUI::SelectedSlotCooldownHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCooldownText) == 0x000468, "Member 'UCrabInventoryUI::SelectedSlotCooldownText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotAccumulatedBuffHorizontalBox) == 0x000470, "Member 'UCrabInventoryUI::SelectedSlotAccumulatedBuffHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotAccumulatedBuffText) == 0x000478, "Member 'UCrabInventoryUI::SelectedSlotAccumulatedBuffText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementsVerticalBox) == 0x000480, "Member 'UCrabInventoryUI::EnhancementsVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementUIToSpawn) == 0x000488, "Member 'UCrabInventoryUI::EnhancementUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotDropButtonOverlay) == 0x000490, "Member 'UCrabInventoryUI::SelectedSlotDropButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotDropText) == 0x000498, "Member 'UCrabInventoryUI::SelectedSlotDropText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLockedIcon) == 0x0004A0, "Member 'UCrabInventoryUI::SelectedSlotLockedIcon' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCostHorizontalBox) == 0x0004A8, "Member 'UCrabInventoryUI::SelectedSlotCostHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCostText) == 0x0004B0, "Member 'UCrabInventoryUI::SelectedSlotCostText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotUnlockSound) == 0x0004B8, "Member 'UCrabInventoryUI::SelectedSlotUnlockSound' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, DropCrystalsButton) == 0x0004C0, "Member 'UCrabInventoryUI::DropCrystalsButton' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, BaseMaxHealthStatText) == 0x0004C8, "Member 'UCrabInventoryUI::BaseMaxHealthStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, MaxHealthMultiplierStatText) == 0x0004D0, "Member 'UCrabInventoryUI::MaxHealthMultiplierStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, IncomingDamageStatText) == 0x0004D8, "Member 'UCrabInventoryUI::IncomingDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, FireRateStatText) == 0x0004E0, "Member 'UCrabInventoryUI::FireRateStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, WeaponDamageStatText) == 0x0004E8, "Member 'UCrabInventoryUI::WeaponDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, AbilityDamageStatText) == 0x0004F0, "Member 'UCrabInventoryUI::AbilityDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, MeleeDamageStatText) == 0x0004F8, "Member 'UCrabInventoryUI::MeleeDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, GlobalDamageStatText) == 0x000500, "Member 'UCrabInventoryUI::GlobalDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CriticalHitChanceStatText) == 0x000508, "Member 'UCrabInventoryUI::CriticalHitChanceStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CriticalHitDamageStatText) == 0x000510, "Member 'UCrabInventoryUI::CriticalHitDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CrystalGainStatText) == 0x000518, "Member 'UCrabInventoryUI::CrystalGainStatText' has a wrong offset!");

// Class CrabChampions.CrabInviteFriendRowUI
// 0x0030 (0x02E8 - 0x02B8)
class UCrabInviteFriendRowUI : public UCrabUI
{
public:
	class UTextBlock*                             FriendNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                InviteButton;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InviteButtonText;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredInviteButton();
	void OnPressedInviteButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInviteFriendRowUI">();
	}
	static class UCrabInviteFriendRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInviteFriendRowUI>();
	}
};
static_assert(alignof(UCrabInviteFriendRowUI) == 0x000008, "Wrong alignment on UCrabInviteFriendRowUI");
static_assert(sizeof(UCrabInviteFriendRowUI) == 0x0002E8, "Wrong size on UCrabInviteFriendRowUI");
static_assert(offsetof(UCrabInviteFriendRowUI, FriendNameText) == 0x0002B8, "Member 'UCrabInviteFriendRowUI::FriendNameText' has a wrong offset!");
static_assert(offsetof(UCrabInviteFriendRowUI, InviteButton) == 0x0002D0, "Member 'UCrabInviteFriendRowUI::InviteButton' has a wrong offset!");
static_assert(offsetof(UCrabInviteFriendRowUI, InviteButtonText) == 0x0002D8, "Member 'UCrabInviteFriendRowUI::InviteButtonText' has a wrong offset!");

// Class CrabChampions.CrabBananaPickup
// 0x0000 (0x0268 - 0x0268)
class ACrabBananaPickup final : public ACrabOverlapPickup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBananaPickup">();
	}
	static class ACrabBananaPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabBananaPickup>();
	}
};
static_assert(alignof(ACrabBananaPickup) == 0x000008, "Wrong alignment on ACrabBananaPickup");
static_assert(sizeof(ACrabBananaPickup) == 0x000268, "Wrong size on ACrabBananaPickup");

// Class CrabChampions.CrabBeam
// 0x00E8 (0x0308 - 0x0220)
class ACrabBeam : public AActor
{
public:
	class USceneComponent*                        BeamRoot;                                          // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      BeamNC;                                            // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        BeamAC;                                            // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPointBeamAtGround;                                // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeamRadius;                                        // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamLength;                                        // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamLengthInterpTime;                              // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamLengthInterpEasingExponent;                    // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArcAngle;                                          // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EasingExponent;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalStrength;                                  // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalStrength;                                // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToOwningC;                                  // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FCrabDamageInfo                        DamageInfo;                                        // 0x0290(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               DamageType;                                        // 0x02DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockbackStrength;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x14];                                     // 0x02E4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageInterval;                                    // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0xC];                                      // 0x02FC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBeam">();
	}
	static class ACrabBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabBeam>();
	}
};
static_assert(alignof(ACrabBeam) == 0x000008, "Wrong alignment on ACrabBeam");
static_assert(sizeof(ACrabBeam) == 0x000308, "Wrong size on ACrabBeam");
static_assert(offsetof(ACrabBeam, BeamRoot) == 0x000220, "Member 'ACrabBeam::BeamRoot' has a wrong offset!");
static_assert(offsetof(ACrabBeam, BeamNC) == 0x000228, "Member 'ACrabBeam::BeamNC' has a wrong offset!");
static_assert(offsetof(ACrabBeam, BeamAC) == 0x000230, "Member 'ACrabBeam::BeamAC' has a wrong offset!");
static_assert(offsetof(ACrabBeam, bPointBeamAtGround) == 0x000238, "Member 'ACrabBeam::bPointBeamAtGround' has a wrong offset!");
static_assert(offsetof(ACrabBeam, BeamRadius) == 0x00023C, "Member 'ACrabBeam::BeamRadius' has a wrong offset!");
static_assert(offsetof(ACrabBeam, BeamLength) == 0x000240, "Member 'ACrabBeam::BeamLength' has a wrong offset!");
static_assert(offsetof(ACrabBeam, BeamLengthInterpTime) == 0x000244, "Member 'ACrabBeam::BeamLengthInterpTime' has a wrong offset!");
static_assert(offsetof(ACrabBeam, BeamLengthInterpEasingExponent) == 0x000248, "Member 'ACrabBeam::BeamLengthInterpEasingExponent' has a wrong offset!");
static_assert(offsetof(ACrabBeam, ArcAngle) == 0x00024C, "Member 'ACrabBeam::ArcAngle' has a wrong offset!");
static_assert(offsetof(ACrabBeam, EasingExponent) == 0x000250, "Member 'ACrabBeam::EasingExponent' has a wrong offset!");
static_assert(offsetof(ACrabBeam, VerticalStrength) == 0x000254, "Member 'ACrabBeam::VerticalStrength' has a wrong offset!");
static_assert(offsetof(ACrabBeam, HorizontalStrength) == 0x000258, "Member 'ACrabBeam::HorizontalStrength' has a wrong offset!");
static_assert(offsetof(ACrabBeam, LifeTime) == 0x00025C, "Member 'ACrabBeam::LifeTime' has a wrong offset!");
static_assert(offsetof(ACrabBeam, FX) == 0x000260, "Member 'ACrabBeam::FX' has a wrong offset!");
static_assert(offsetof(ACrabBeam, Sound) == 0x000268, "Member 'ACrabBeam::Sound' has a wrong offset!");
static_assert(offsetof(ACrabBeam, OwningC) == 0x000270, "Member 'ACrabBeam::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabBeam, bAttachToOwningC) == 0x000278, "Member 'ACrabBeam::bAttachToOwningC' has a wrong offset!");
static_assert(offsetof(ACrabBeam, ActorsToIgnore) == 0x000280, "Member 'ACrabBeam::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabBeam, DamageInfo) == 0x000290, "Member 'ACrabBeam::DamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabBeam, Damage) == 0x0002D8, "Member 'ACrabBeam::Damage' has a wrong offset!");
static_assert(offsetof(ACrabBeam, DamageType) == 0x0002DC, "Member 'ACrabBeam::DamageType' has a wrong offset!");
static_assert(offsetof(ACrabBeam, KnockbackStrength) == 0x0002E0, "Member 'ACrabBeam::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(ACrabBeam, DamageInterval) == 0x0002F8, "Member 'ACrabBeam::DamageInterval' has a wrong offset!");

// Class CrabChampions.CrabBiomeDA
// 0x0110 (0x0140 - 0x0030)
class UCrabBiomeDA final : public UDataAsset
{
public:
	ECrabBiome                                    Biome;                                             // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabIsland>                    ArenaIslands;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    LargeArenaIslands;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    HordeIslands;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    DemolitionIslands;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    ParkourIslands;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    ShopIslands;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    BossIslands;                                       // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabEnemyC>>        Enemies;                                           // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  CombatDestructibles;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  RewardDestructibles;                               // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  PhysicsDestructibles;                              // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         AmbienceFX;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AmbienceSound;                                     // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         UnderwaterFX;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SmallOceanImpactFX;                                // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SmallOceanImpactSound;                             // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LargeOceanImpactFX;                                // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LargeOceanImpactSound;                             // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderwaterSpeedMultiplier;                         // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabDebuff                            UnderwaterDebuff;                                  // 0x0124(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              MusicPlaylist;                                     // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ShopMusic;                                         // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBiomeDA">();
	}
	static class UCrabBiomeDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabBiomeDA>();
	}
};
static_assert(alignof(UCrabBiomeDA) == 0x000008, "Wrong alignment on UCrabBiomeDA");
static_assert(sizeof(UCrabBiomeDA) == 0x000140, "Wrong size on UCrabBiomeDA");
static_assert(offsetof(UCrabBiomeDA, Biome) == 0x000030, "Member 'UCrabBiomeDA::Biome' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ArenaIslands) == 0x000038, "Member 'UCrabBiomeDA::ArenaIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, LargeArenaIslands) == 0x000048, "Member 'UCrabBiomeDA::LargeArenaIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, HordeIslands) == 0x000058, "Member 'UCrabBiomeDA::HordeIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, DemolitionIslands) == 0x000068, "Member 'UCrabBiomeDA::DemolitionIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ParkourIslands) == 0x000078, "Member 'UCrabBiomeDA::ParkourIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ShopIslands) == 0x000088, "Member 'UCrabBiomeDA::ShopIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, BossIslands) == 0x000098, "Member 'UCrabBiomeDA::BossIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, Enemies) == 0x0000A8, "Member 'UCrabBiomeDA::Enemies' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, CombatDestructibles) == 0x0000B8, "Member 'UCrabBiomeDA::CombatDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, RewardDestructibles) == 0x0000C8, "Member 'UCrabBiomeDA::RewardDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, PhysicsDestructibles) == 0x0000D8, "Member 'UCrabBiomeDA::PhysicsDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, AmbienceFX) == 0x0000E8, "Member 'UCrabBiomeDA::AmbienceFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, AmbienceSound) == 0x0000F0, "Member 'UCrabBiomeDA::AmbienceSound' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, UnderwaterFX) == 0x0000F8, "Member 'UCrabBiomeDA::UnderwaterFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, SmallOceanImpactFX) == 0x000100, "Member 'UCrabBiomeDA::SmallOceanImpactFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, SmallOceanImpactSound) == 0x000108, "Member 'UCrabBiomeDA::SmallOceanImpactSound' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, LargeOceanImpactFX) == 0x000110, "Member 'UCrabBiomeDA::LargeOceanImpactFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, LargeOceanImpactSound) == 0x000118, "Member 'UCrabBiomeDA::LargeOceanImpactSound' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, UnderwaterSpeedMultiplier) == 0x000120, "Member 'UCrabBiomeDA::UnderwaterSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, UnderwaterDebuff) == 0x000124, "Member 'UCrabBiomeDA::UnderwaterDebuff' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, MusicPlaylist) == 0x000130, "Member 'UCrabBiomeDA::MusicPlaylist' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ShopMusic) == 0x000138, "Member 'UCrabBiomeDA::ShopMusic' has a wrong offset!");

// Class CrabChampions.CrabC
// 0x0250 (0x0710 - 0x04C0)
class ACrabC : public ACharacter
{
public:
	class UCrabHC*                                HC;                                                // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      DebuffNC;                                          // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        DebuffAC;                                          // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChainLightningNC;                                  // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          MeshToSpawn;                                       // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshMat;                                           // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              AnimationBlueprintToUse;                           // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x04F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CoreSocketName;                                    // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         DebuffFX;                                          // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabLM*                                LM;                                                // 0x0518(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0520(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabWeapon*>                    Weapons;                                           // 0x0538(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x30];                                     // 0x0548(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 UROIntervalPerLOD;                                 // 0x0578(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         UpdateMovementStateFrequency;                      // 0x0588(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x14];                                     // 0x058C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAlignToTerrain;                                   // 0x05A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AlignToTerrainSocketName;                          // 0x05A4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AC[0xC];                                      // 0x05AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseWalkSpeed;                                     // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseGravityScale;                                  // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x4];                                      // 0x05C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundFriction;                                    // 0x05C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAcceleration;                                   // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirControl;                                        // 0x05CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateViewPitch;                               // 0x05D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentViewPitch;                                  // 0x05D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              JumpSound;                                         // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              LandSound;                                         // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x10];                                     // 0x05F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsKnockedBack;                                    // 0x0608(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_609[0x7];                                      // 0x0609(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 KnockbackDamageCauser;                             // 0x0610(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x4];                                      // 0x0618(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenDamageEvents;                        // 0x061C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsImmuneToKnockbacks;                             // 0x0628(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToKnockbackDamage;                        // 0x0629(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToIce;                                    // 0x062A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62B[0x1];                                      // 0x062B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebuffStackMultiplier;                             // 0x062C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebuffStackLimit;                                  // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 LastDamageCauser;                                  // 0x0638(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAwardDamageDealtWhenDamaged;                      // 0x0640(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_641[0x1F];                                     // 0x0641(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEliminated;                                     // 0x0660(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldRagdoll;                                    // 0x0661(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_662[0x2];                                      // 0x0662(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollImpulseStrength;                            // 0x0664(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeSpanCleanupTime;                               // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 DOTDamageCauser;                                   // 0x0670(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_678[0x4];                                      // 0x0678(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreezeDuration;                                    // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenFreezes;                             // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenShocks;                              // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68C[0x4];                                      // 0x068C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 IceDamageCauser;                                   // 0x0690(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 FireDamageCauser;                                  // 0x0698(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 LightningDamageCauser;                             // 0x06A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x8];                                      // 0x06A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 ArcaneDamageCauser;                                // 0x06B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x28];                                     // 0x06B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuffState                       DebuffState;                                       // 0x06E0(0x0014)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F4[0x4];                                      // 0x06F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 ChainedToC;                                        // 0x06F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_700[0x8];                                      // 0x0700(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInvulnerable;                                   // 0x0708(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_709[0x7];                                      // 0x0709(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientKnockback(const struct FVector_NetQuantizeNormal& Dir, float Strength);
	void OnRep_ChainedToC();
	void OnRep_DebuffState(const struct FCrabDebuffState& PreviousDebuffState);
	void OnRep_IsEliminated();
	void OnRep_IsInvulnerable();
	void ServerClientAuthoritativeMove(const struct FClientAuthoritativeMoveData& MoveData);
	void ServerSpawnCosmeticProjectile(const struct FCrabProjectileInfo& ProjectileInfo, class AActor* ProjectileOwner, const struct FVector_NetQuantize& StartLoc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabC">();
	}
	static class ACrabC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabC>();
	}
};
static_assert(alignof(ACrabC) == 0x000010, "Wrong alignment on ACrabC");
static_assert(sizeof(ACrabC) == 0x000710, "Wrong size on ACrabC");
static_assert(offsetof(ACrabC, HC) == 0x0004C0, "Member 'ACrabC::HC' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffNC) == 0x0004C8, "Member 'ACrabC::DebuffNC' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffAC) == 0x0004D0, "Member 'ACrabC::DebuffAC' has a wrong offset!");
static_assert(offsetof(ACrabC, ChainLightningNC) == 0x0004D8, "Member 'ACrabC::ChainLightningNC' has a wrong offset!");
static_assert(offsetof(ACrabC, MeshToSpawn) == 0x0004E0, "Member 'ACrabC::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabC, MeshMat) == 0x0004E8, "Member 'ACrabC::MeshMat' has a wrong offset!");
static_assert(offsetof(ACrabC, AnimationBlueprintToUse) == 0x0004F0, "Member 'ACrabC::AnimationBlueprintToUse' has a wrong offset!");
static_assert(offsetof(ACrabC, Tint) == 0x0004F8, "Member 'ACrabC::Tint' has a wrong offset!");
static_assert(offsetof(ACrabC, CoreSocketName) == 0x000508, "Member 'ACrabC::CoreSocketName' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffFX) == 0x000510, "Member 'ACrabC::DebuffFX' has a wrong offset!");
static_assert(offsetof(ACrabC, LM) == 0x000518, "Member 'ACrabC::LM' has a wrong offset!");
static_assert(offsetof(ACrabC, ActorsToIgnore) == 0x000520, "Member 'ACrabC::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabC, Weapons) == 0x000538, "Member 'ACrabC::Weapons' has a wrong offset!");
static_assert(offsetof(ACrabC, UROIntervalPerLOD) == 0x000578, "Member 'ACrabC::UROIntervalPerLOD' has a wrong offset!");
static_assert(offsetof(ACrabC, UpdateMovementStateFrequency) == 0x000588, "Member 'ACrabC::UpdateMovementStateFrequency' has a wrong offset!");
static_assert(offsetof(ACrabC, bAlignToTerrain) == 0x0005A0, "Member 'ACrabC::bAlignToTerrain' has a wrong offset!");
static_assert(offsetof(ACrabC, AlignToTerrainSocketName) == 0x0005A4, "Member 'ACrabC::AlignToTerrainSocketName' has a wrong offset!");
static_assert(offsetof(ACrabC, BaseWalkSpeed) == 0x0005B8, "Member 'ACrabC::BaseWalkSpeed' has a wrong offset!");
static_assert(offsetof(ACrabC, BaseGravityScale) == 0x0005BC, "Member 'ACrabC::BaseGravityScale' has a wrong offset!");
static_assert(offsetof(ACrabC, GroundFriction) == 0x0005C4, "Member 'ACrabC::GroundFriction' has a wrong offset!");
static_assert(offsetof(ACrabC, MaxAcceleration) == 0x0005C8, "Member 'ACrabC::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(ACrabC, AirControl) == 0x0005CC, "Member 'ACrabC::AirControl' has a wrong offset!");
static_assert(offsetof(ACrabC, bCalculateViewPitch) == 0x0005D0, "Member 'ACrabC::bCalculateViewPitch' has a wrong offset!");
static_assert(offsetof(ACrabC, CurrentViewPitch) == 0x0005D4, "Member 'ACrabC::CurrentViewPitch' has a wrong offset!");
static_assert(offsetof(ACrabC, JumpSound) == 0x0005E0, "Member 'ACrabC::JumpSound' has a wrong offset!");
static_assert(offsetof(ACrabC, LandSound) == 0x0005F0, "Member 'ACrabC::LandSound' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsKnockedBack) == 0x000608, "Member 'ACrabC::bIsKnockedBack' has a wrong offset!");
static_assert(offsetof(ACrabC, KnockbackDamageCauser) == 0x000610, "Member 'ACrabC::KnockbackDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, MinTimeBetweenDamageEvents) == 0x00061C, "Member 'ACrabC::MinTimeBetweenDamageEvents' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToKnockbacks) == 0x000628, "Member 'ACrabC::bIsImmuneToKnockbacks' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToKnockbackDamage) == 0x000629, "Member 'ACrabC::bIsImmuneToKnockbackDamage' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToIce) == 0x00062A, "Member 'ACrabC::bIsImmuneToIce' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffStackMultiplier) == 0x00062C, "Member 'ACrabC::DebuffStackMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffStackLimit) == 0x000630, "Member 'ACrabC::DebuffStackLimit' has a wrong offset!");
static_assert(offsetof(ACrabC, LastDamageCauser) == 0x000638, "Member 'ACrabC::LastDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, bAwardDamageDealtWhenDamaged) == 0x000640, "Member 'ACrabC::bAwardDamageDealtWhenDamaged' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsEliminated) == 0x000660, "Member 'ACrabC::bIsEliminated' has a wrong offset!");
static_assert(offsetof(ACrabC, bShouldRagdoll) == 0x000661, "Member 'ACrabC::bShouldRagdoll' has a wrong offset!");
static_assert(offsetof(ACrabC, RagdollImpulseStrength) == 0x000664, "Member 'ACrabC::RagdollImpulseStrength' has a wrong offset!");
static_assert(offsetof(ACrabC, LifeSpanCleanupTime) == 0x000668, "Member 'ACrabC::LifeSpanCleanupTime' has a wrong offset!");
static_assert(offsetof(ACrabC, DOTDamageCauser) == 0x000670, "Member 'ACrabC::DOTDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, FreezeDuration) == 0x00067C, "Member 'ACrabC::FreezeDuration' has a wrong offset!");
static_assert(offsetof(ACrabC, MinTimeBetweenFreezes) == 0x000680, "Member 'ACrabC::MinTimeBetweenFreezes' has a wrong offset!");
static_assert(offsetof(ACrabC, MinTimeBetweenShocks) == 0x000688, "Member 'ACrabC::MinTimeBetweenShocks' has a wrong offset!");
static_assert(offsetof(ACrabC, IceDamageCauser) == 0x000690, "Member 'ACrabC::IceDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, FireDamageCauser) == 0x000698, "Member 'ACrabC::FireDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, LightningDamageCauser) == 0x0006A0, "Member 'ACrabC::LightningDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, ArcaneDamageCauser) == 0x0006B0, "Member 'ACrabC::ArcaneDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffState) == 0x0006E0, "Member 'ACrabC::DebuffState' has a wrong offset!");
static_assert(offsetof(ACrabC, ChainedToC) == 0x0006F8, "Member 'ACrabC::ChainedToC' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsInvulnerable) == 0x000708, "Member 'ACrabC::bIsInvulnerable' has a wrong offset!");

// Class CrabChampions.CrabEnemyC
// 0x0280 (0x0990 - 0x0710)
#pragma pack(push, 0x1)
class alignas(0x10) ACrabEnemyC : public ACrabC
{
public:
	class UWidgetComponent*                       HealthBarWC;                                       // 0x0710(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleScaleMultiplier;                            // 0x0718(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleMultiplier;                                   // 0x071C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MeshDMI;                                           // 0x0720(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x9];                                      // 0x0728(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCollideWithCharacters;                            // 0x0731(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_732[0xE];                                      // 0x0732(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabEnemySpawnSettings                EnemySpawnSettings;                                // 0x0740(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ACrabEnemyAIC*                          OwningAIC;                                         // 0x0768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabEnemyCategory                            EnemyCategory;                                     // 0x0770(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0x7];                                      // 0x0771(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EnemyName;                                         // 0x0778(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarHeightOffset;                             // 0x0788(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldFloat;                                      // 0x078C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78D[0x3];                                      // 0x078D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightOffset;                                      // 0x0790(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_794[0x14];                                     // 0x0794(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageReductionWhenNoActionIsActive;               // 0x07A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentDamageReduction;                            // 0x07AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECrabEnemyBuff>                        BannedEnemyBuffs;                                  // 0x07B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ECrabEnemyBuff                                EnemyBuff;                                         // 0x07C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C1[0x7];                                      // 0x07C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabAISettings                        AISettings;                                        // 0x07C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F0[0x8];                                      // 0x07F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 BestEnemyC;                                        // 0x07F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCrabActionDA*>                  ActionDAs;                                         // 0x0800(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         CurrentActionIndex;                                // 0x0810(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabActionDA*                          CurrentActionDA;                                   // 0x0818(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ActionNC;                                          // 0x0820(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ActionAC;                                          // 0x0828(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x10];                                     // 0x0830(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SequenceShotFormation;                             // 0x0840(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0x18];                                     // 0x0850(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        PendingLesserEnemiesToSpawn;                       // 0x0868(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_878[0x18];                                     // 0x0878(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpSpeed;                                         // 0x0890(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpHeight;                                        // 0x0894(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashSpeed;                                         // 0x0898(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashHeight;                                        // 0x089C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabDebuff                            EnemyDebuff;                                       // 0x08A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabHealthBarUI>           HealthBarUIToSpawn;                                // 0x08A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EnemySpawnMontage;                                 // 0x08B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         EnemySpawnFX;                                      // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              EnemySpawnSound;                                   // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MeshNC;                                            // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MeshFX;                                            // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        MeshAC;                                            // 0x08E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MeshSound;                                         // 0x08E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeshFXSocketName;                                  // 0x08F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLesserEnemy;                                    // 0x08F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F9[0x17];                                     // 0x08F9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   HitReactMontages;                                  // 0x0910(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_920[0x8];                                      // 0x0920(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 EliminatingC;                                      // 0x0928(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_930[0xC];                                      // 0x0930(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToSpawnOnEliminatedEnemies;                  // 0x093C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACrabEnemyC>>        OnEliminatedEnemiesToSpawn;                        // 0x0940(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EliminatedMontage;                                 // 0x0950(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EliminatedSoundChance;                             // 0x0958(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95C[0x4];                                      // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              EliminatedSound;                                   // 0x0960(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x8];                                      // 0x0968(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         GibFX;                                             // 0x0970(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              GibSound;                                          // 0x0978(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_980[0x8];                                      // 0x0980(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastHitReact();
	void MulticastShowHealthBar();
	void MulticastSpawnHomingThornProjectiles();
	void MulticastSpawnMirroredProjectile(class ACrabC* DamagingC);
	void MulticastSpawnShrapnelProjectiles();
	void OnRep_CurrentActionIndex();
	void OnRep_CurrentDamageReduction();
	void OnRep_EnemyBuff();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyC">();
	}
	static class ACrabEnemyC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabEnemyC>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACrabEnemyC) == 0x000010, "Wrong alignment on ACrabEnemyC");
static_assert(sizeof(ACrabEnemyC) == 0x000990, "Wrong size on ACrabEnemyC");
static_assert(offsetof(ACrabEnemyC, HealthBarWC) == 0x000710, "Member 'ACrabEnemyC::HealthBarWC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, CapsuleScaleMultiplier) == 0x000718, "Member 'ACrabEnemyC::CapsuleScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ScaleMultiplier) == 0x00071C, "Member 'ACrabEnemyC::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshDMI) == 0x000720, "Member 'ACrabEnemyC::MeshDMI' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bCollideWithCharacters) == 0x000731, "Member 'ACrabEnemyC::bCollideWithCharacters' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnSettings) == 0x000740, "Member 'ACrabEnemyC::EnemySpawnSettings' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, OwningAIC) == 0x000768, "Member 'ACrabEnemyC::OwningAIC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyCategory) == 0x000770, "Member 'ACrabEnemyC::EnemyCategory' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyName) == 0x000778, "Member 'ACrabEnemyC::EnemyName' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HealthBarHeightOffset) == 0x000788, "Member 'ACrabEnemyC::HealthBarHeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bShouldFloat) == 0x00078C, "Member 'ACrabEnemyC::bShouldFloat' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HeightOffset) == 0x000790, "Member 'ACrabEnemyC::HeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, DamageReductionWhenNoActionIsActive) == 0x0007A8, "Member 'ACrabEnemyC::DamageReductionWhenNoActionIsActive' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, CurrentDamageReduction) == 0x0007AC, "Member 'ACrabEnemyC::CurrentDamageReduction' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, BannedEnemyBuffs) == 0x0007B0, "Member 'ACrabEnemyC::BannedEnemyBuffs' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyBuff) == 0x0007C0, "Member 'ACrabEnemyC::EnemyBuff' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, AISettings) == 0x0007C8, "Member 'ACrabEnemyC::AISettings' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, BestEnemyC) == 0x0007F8, "Member 'ACrabEnemyC::BestEnemyC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ActionDAs) == 0x000800, "Member 'ACrabEnemyC::ActionDAs' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, CurrentActionIndex) == 0x000810, "Member 'ACrabEnemyC::CurrentActionIndex' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, CurrentActionDA) == 0x000818, "Member 'ACrabEnemyC::CurrentActionDA' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ActionNC) == 0x000820, "Member 'ACrabEnemyC::ActionNC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ActionAC) == 0x000828, "Member 'ACrabEnemyC::ActionAC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, SequenceShotFormation) == 0x000840, "Member 'ACrabEnemyC::SequenceShotFormation' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, PendingLesserEnemiesToSpawn) == 0x000868, "Member 'ACrabEnemyC::PendingLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, JumpSpeed) == 0x000890, "Member 'ACrabEnemyC::JumpSpeed' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, JumpHeight) == 0x000894, "Member 'ACrabEnemyC::JumpHeight' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, DashSpeed) == 0x000898, "Member 'ACrabEnemyC::DashSpeed' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, DashHeight) == 0x00089C, "Member 'ACrabEnemyC::DashHeight' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyDebuff) == 0x0008A0, "Member 'ACrabEnemyC::EnemyDebuff' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HealthBarUIToSpawn) == 0x0008A8, "Member 'ACrabEnemyC::HealthBarUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, WeaponDA) == 0x0008B0, "Member 'ACrabEnemyC::WeaponDA' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnMontage) == 0x0008B8, "Member 'ACrabEnemyC::EnemySpawnMontage' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnFX) == 0x0008C0, "Member 'ACrabEnemyC::EnemySpawnFX' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnSound) == 0x0008C8, "Member 'ACrabEnemyC::EnemySpawnSound' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshNC) == 0x0008D0, "Member 'ACrabEnemyC::MeshNC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshFX) == 0x0008D8, "Member 'ACrabEnemyC::MeshFX' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshAC) == 0x0008E0, "Member 'ACrabEnemyC::MeshAC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshSound) == 0x0008E8, "Member 'ACrabEnemyC::MeshSound' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshFXSocketName) == 0x0008F0, "Member 'ACrabEnemyC::MeshFXSocketName' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bIsLesserEnemy) == 0x0008F8, "Member 'ACrabEnemyC::bIsLesserEnemy' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HitReactMontages) == 0x000910, "Member 'ACrabEnemyC::HitReactMontages' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EliminatingC) == 0x000928, "Member 'ACrabEnemyC::EliminatingC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ChanceToSpawnOnEliminatedEnemies) == 0x00093C, "Member 'ACrabEnemyC::ChanceToSpawnOnEliminatedEnemies' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, OnEliminatedEnemiesToSpawn) == 0x000940, "Member 'ACrabEnemyC::OnEliminatedEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EliminatedMontage) == 0x000950, "Member 'ACrabEnemyC::EliminatedMontage' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EliminatedSoundChance) == 0x000958, "Member 'ACrabEnemyC::EliminatedSoundChance' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EliminatedSound) == 0x000960, "Member 'ACrabEnemyC::EliminatedSound' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, GibFX) == 0x000970, "Member 'ACrabEnemyC::GibFX' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, GibSound) == 0x000978, "Member 'ACrabEnemyC::GibSound' has a wrong offset!");

// Class CrabChampions.CrabBossC
// 0x0020 (0x09B0 - 0x0990)
class ACrabBossC : public ACrabEnemyC
{
public:
	uint8                                         Pad_988[0x8];                                      // 0x0988(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        PotentialPhaseLesserEnemiesToSpawn;                // 0x0990(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         NumPhaseTwoLesserEnemiesToSpawn;                   // 0x09A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPhaseThreeLesserEnemiesToSpawn;                 // 0x09A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A8[0x8];                                      // 0x09A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBossC">();
	}
	static class ACrabBossC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabBossC>();
	}
};
static_assert(alignof(ACrabBossC) == 0x000010, "Wrong alignment on ACrabBossC");
static_assert(sizeof(ACrabBossC) == 0x0009B0, "Wrong size on ACrabBossC");
static_assert(offsetof(ACrabBossC, PotentialPhaseLesserEnemiesToSpawn) == 0x000990, "Member 'ACrabBossC::PotentialPhaseLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabBossC, NumPhaseTwoLesserEnemiesToSpawn) == 0x0009A0, "Member 'ACrabBossC::NumPhaseTwoLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabBossC, NumPhaseThreeLesserEnemiesToSpawn) == 0x0009A4, "Member 'ACrabBossC::NumPhaseThreeLesserEnemiesToSpawn' has a wrong offset!");

// Class CrabChampions.CrabChatEntryRowUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabChatEntryRowUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChatMessageText;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabChatEntryRowUI">();
	}
	static class UCrabChatEntryRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabChatEntryRowUI>();
	}
};
static_assert(alignof(UCrabChatEntryRowUI) == 0x000008, "Wrong alignment on UCrabChatEntryRowUI");
static_assert(sizeof(UCrabChatEntryRowUI) == 0x0002C8, "Wrong size on UCrabChatEntryRowUI");
static_assert(offsetof(UCrabChatEntryRowUI, PlayerNameText) == 0x0002B8, "Member 'UCrabChatEntryRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabChatEntryRowUI, ChatMessageText) == 0x0002C0, "Member 'UCrabChatEntryRowUI::ChatMessageText' has a wrong offset!");

// Class CrabChampions.CrabCheckpoint
// 0x0030 (0x0250 - 0x0220)
class ACrabCheckpoint final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CheckpointCollision;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CheckpointNC;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         CheckpointFX;                                      // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinalCheckpoint;                                // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              CheckpointActiveSound;                             // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCheckpoint">();
	}
	static class ACrabCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCheckpoint>();
	}
};
static_assert(alignof(ACrabCheckpoint) == 0x000008, "Wrong alignment on ACrabCheckpoint");
static_assert(sizeof(ACrabCheckpoint) == 0x000250, "Wrong size on ACrabCheckpoint");
static_assert(offsetof(ACrabCheckpoint, CheckpointCollision) == 0x000228, "Member 'ACrabCheckpoint::CheckpointCollision' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, CheckpointNC) == 0x000230, "Member 'ACrabCheckpoint::CheckpointNC' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, CheckpointFX) == 0x000238, "Member 'ACrabCheckpoint::CheckpointFX' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, bIsFinalCheckpoint) == 0x000240, "Member 'ACrabCheckpoint::bIsFinalCheckpoint' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, CheckpointActiveSound) == 0x000248, "Member 'ACrabCheckpoint::CheckpointActiveSound' has a wrong offset!");

// Class CrabChampions.CrabChest
// 0x00C8 (0x0340 - 0x0278)
class ACrabChest : public ACrabInteractable
{
public:
	class USkeletalMeshComponent*                 ChestMesh;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChestNC;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ChestAC;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       ChestLocationWC;                                   // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Name_0;                                            // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabLootPool                                 LootPool;                                          // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabRarity                                   Rarity;                                            // 0x02A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x2];                                      // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPickupsToSpawn;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabCurrencyType                             CurrencyType;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          ChestMeshToSpawn;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ChestSound;                                        // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              OpenSound;                                         // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         OpenFX;                                            // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          SpawnAnim;                                         // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          OpenAnim;                                          // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x02E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                ChestLocationUIToSpawn;                            // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChestOpened;                                    // 0x02F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabPickupInfo>                PickupsToSpawn;                                    // 0x0300(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabInteractPickup*>            SpawnedPickups;                                    // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsChestOpened();
	void OnRep_OwningPS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabChest">();
	}
	static class ACrabChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabChest>();
	}
};
static_assert(alignof(ACrabChest) == 0x000008, "Wrong alignment on ACrabChest");
static_assert(sizeof(ACrabChest) == 0x000340, "Wrong size on ACrabChest");
static_assert(offsetof(ACrabChest, ChestMesh) == 0x000278, "Member 'ACrabChest::ChestMesh' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestNC) == 0x000280, "Member 'ACrabChest::ChestNC' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestAC) == 0x000288, "Member 'ACrabChest::ChestAC' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestLocationWC) == 0x000290, "Member 'ACrabChest::ChestLocationWC' has a wrong offset!");
static_assert(offsetof(ACrabChest, Name_0) == 0x000298, "Member 'ACrabChest::Name_0' has a wrong offset!");
static_assert(offsetof(ACrabChest, LootPool) == 0x0002A8, "Member 'ACrabChest::LootPool' has a wrong offset!");
static_assert(offsetof(ACrabChest, Rarity) == 0x0002A9, "Member 'ACrabChest::Rarity' has a wrong offset!");
static_assert(offsetof(ACrabChest, NumPickupsToSpawn) == 0x0002AC, "Member 'ACrabChest::NumPickupsToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabChest, CurrencyType) == 0x0002B0, "Member 'ACrabChest::CurrencyType' has a wrong offset!");
static_assert(offsetof(ACrabChest, Cost) == 0x0002B4, "Member 'ACrabChest::Cost' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestMeshToSpawn) == 0x0002B8, "Member 'ACrabChest::ChestMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestSound) == 0x0002C0, "Member 'ACrabChest::ChestSound' has a wrong offset!");
static_assert(offsetof(ACrabChest, OpenSound) == 0x0002C8, "Member 'ACrabChest::OpenSound' has a wrong offset!");
static_assert(offsetof(ACrabChest, OpenFX) == 0x0002D0, "Member 'ACrabChest::OpenFX' has a wrong offset!");
static_assert(offsetof(ACrabChest, SpawnAnim) == 0x0002D8, "Member 'ACrabChest::SpawnAnim' has a wrong offset!");
static_assert(offsetof(ACrabChest, OpenAnim) == 0x0002E0, "Member 'ACrabChest::OpenAnim' has a wrong offset!");
static_assert(offsetof(ACrabChest, OwningPS) == 0x0002E8, "Member 'ACrabChest::OwningPS' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestLocationUIToSpawn) == 0x0002F0, "Member 'ACrabChest::ChestLocationUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabChest, bIsChestOpened) == 0x0002F8, "Member 'ACrabChest::bIsChestOpened' has a wrong offset!");
static_assert(offsetof(ACrabChest, PickupsToSpawn) == 0x000300, "Member 'ACrabChest::PickupsToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabChest, SpawnedPickups) == 0x000328, "Member 'ACrabChest::SpawnedPickups' has a wrong offset!");

// Class CrabChampions.CrabCMC
// 0x0060 (0x0B50 - 0x0AF0)
class UCrabCMC final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_AF0[0x8];                                      // 0x0AF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientAuthoritativeMoveData           ServerLatestMoveData;                              // 0x0AF8(0x0050)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B48[0x8];                                      // 0x0B48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCMC">();
	}
	static class UCrabCMC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCMC>();
	}
};
static_assert(alignof(UCrabCMC) == 0x000010, "Wrong alignment on UCrabCMC");
static_assert(sizeof(UCrabCMC) == 0x000B50, "Wrong size on UCrabCMC");
static_assert(offsetof(UCrabCMC, ServerLatestMoveData) == 0x000AF8, "Member 'UCrabCMC::ServerLatestMoveData' has a wrong offset!");

// Class CrabChampions.CrabConfirmationPromptUI
// 0x0030 (0x0400 - 0x03D0)
class UCrabConfirmationPromptUI : public UCrabFocusMenuUI
{
public:
	class UTextBlock*                             ConfirmationPromptMessageText;                     // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                YesButton;                                         // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NoButton;                                          // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredNoButton();
	void OnHoveredYesButton();
	void OnPressedNoButton();
	void OnPressedYesButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabConfirmationPromptUI">();
	}
	static class UCrabConfirmationPromptUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabConfirmationPromptUI>();
	}
};
static_assert(alignof(UCrabConfirmationPromptUI) == 0x000008, "Wrong alignment on UCrabConfirmationPromptUI");
static_assert(sizeof(UCrabConfirmationPromptUI) == 0x000400, "Wrong size on UCrabConfirmationPromptUI");
static_assert(offsetof(UCrabConfirmationPromptUI, ConfirmationPromptMessageText) == 0x0003D0, "Member 'UCrabConfirmationPromptUI::ConfirmationPromptMessageText' has a wrong offset!");
static_assert(offsetof(UCrabConfirmationPromptUI, YesButton) == 0x0003D8, "Member 'UCrabConfirmationPromptUI::YesButton' has a wrong offset!");
static_assert(offsetof(UCrabConfirmationPromptUI, NoButton) == 0x0003E0, "Member 'UCrabConfirmationPromptUI::NoButton' has a wrong offset!");

// Class CrabChampions.CrabConsumableDA
// 0x0008 (0x00B8 - 0x00B0)
class UCrabConsumableDA final : public UCrabPickupDA
{
public:
	ECrabConsumableType                           ConsumableType;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Buff;                                              // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabConsumableDA">();
	}
	static class UCrabConsumableDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabConsumableDA>();
	}
};
static_assert(alignof(UCrabConsumableDA) == 0x000008, "Wrong alignment on UCrabConsumableDA");
static_assert(sizeof(UCrabConsumableDA) == 0x0000B8, "Wrong size on UCrabConsumableDA");
static_assert(offsetof(UCrabConsumableDA, ConsumableType) == 0x0000B0, "Member 'UCrabConsumableDA::ConsumableType' has a wrong offset!");
static_assert(offsetof(UCrabConsumableDA, Buff) == 0x0000B4, "Member 'UCrabConsumableDA::Buff' has a wrong offset!");

// Class CrabChampions.CrabControlsMenuUI
// 0x0068 (0x0320 - 0x02B8)
class UCrabControlsMenuUI : public UCrabUI
{
public:
	TArray<class UWidget*>                        ControlsMenuFocusableWidgetArray;                  // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          LookSensitivitySlider;                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          AimingSensitivityMultiplierSlider;                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  VerticalLookInversionAS;                           // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  AimAssistStrengthAS;                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  AutoSlideAS;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabKeyBindRowUI>          KeyBindRowUIToSpawn;                               // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ControlsVerticalBox;                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabKeyBind>                   CurrentKeyBinds;                                   // 0x0300(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UCrabKeyBindRowUI*>              KeyBindRows;                                       // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabControlsMenuUI">();
	}
	static class UCrabControlsMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabControlsMenuUI>();
	}
};
static_assert(alignof(UCrabControlsMenuUI) == 0x000008, "Wrong alignment on UCrabControlsMenuUI");
static_assert(sizeof(UCrabControlsMenuUI) == 0x000320, "Wrong size on UCrabControlsMenuUI");
static_assert(offsetof(UCrabControlsMenuUI, ControlsMenuFocusableWidgetArray) == 0x0002B8, "Member 'UCrabControlsMenuUI::ControlsMenuFocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, LookSensitivitySlider) == 0x0002C8, "Member 'UCrabControlsMenuUI::LookSensitivitySlider' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, AimingSensitivityMultiplierSlider) == 0x0002D0, "Member 'UCrabControlsMenuUI::AimingSensitivityMultiplierSlider' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, VerticalLookInversionAS) == 0x0002D8, "Member 'UCrabControlsMenuUI::VerticalLookInversionAS' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, AimAssistStrengthAS) == 0x0002E0, "Member 'UCrabControlsMenuUI::AimAssistStrengthAS' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, AutoSlideAS) == 0x0002E8, "Member 'UCrabControlsMenuUI::AutoSlideAS' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, KeyBindRowUIToSpawn) == 0x0002F0, "Member 'UCrabControlsMenuUI::KeyBindRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, ControlsVerticalBox) == 0x0002F8, "Member 'UCrabControlsMenuUI::ControlsVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, CurrentKeyBinds) == 0x000300, "Member 'UCrabControlsMenuUI::CurrentKeyBinds' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, KeyBindRows) == 0x000310, "Member 'UCrabControlsMenuUI::KeyBindRows' has a wrong offset!");

// Class CrabChampions.CrabCosmeticC
// 0x0048 (0x0268 - 0x0220)
class ACrabCosmeticC final : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WeaponMesh;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          MeshToSpawn;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              AnimationBlueprintToUse;                           // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            WeaponMeshToSpawn;                                 // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           OnEquippedNewCrabSkinMontage;                      // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CrabSkin;                                          // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           OnEquippedNewWeaponSkinMontage;                    // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     WeaponSkin;                                        // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticC">();
	}
	static class ACrabCosmeticC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCosmeticC>();
	}
};
static_assert(alignof(ACrabCosmeticC) == 0x000008, "Wrong alignment on ACrabCosmeticC");
static_assert(sizeof(ACrabCosmeticC) == 0x000268, "Wrong size on ACrabCosmeticC");
static_assert(offsetof(ACrabCosmeticC, Mesh) == 0x000220, "Member 'ACrabCosmeticC::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, WeaponMesh) == 0x000228, "Member 'ACrabCosmeticC::WeaponMesh' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, MeshToSpawn) == 0x000230, "Member 'ACrabCosmeticC::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, AnimationBlueprintToUse) == 0x000238, "Member 'ACrabCosmeticC::AnimationBlueprintToUse' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, WeaponMeshToSpawn) == 0x000240, "Member 'ACrabCosmeticC::WeaponMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, OnEquippedNewCrabSkinMontage) == 0x000248, "Member 'ACrabCosmeticC::OnEquippedNewCrabSkinMontage' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, CrabSkin) == 0x000250, "Member 'ACrabCosmeticC::CrabSkin' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, OnEquippedNewWeaponSkinMontage) == 0x000258, "Member 'ACrabCosmeticC::OnEquippedNewWeaponSkinMontage' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, WeaponSkin) == 0x000260, "Member 'ACrabCosmeticC::WeaponSkin' has a wrong offset!");

// Class CrabChampions.CrabCosmeticsDA
// 0x0010 (0x0040 - 0x0030)
class UCrabCosmeticsDA final : public UDataAsset
{
public:
	TArray<struct FCrabCosmetic>                  CrabSkins;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticsDA">();
	}
	static class UCrabCosmeticsDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCosmeticsDA>();
	}
};
static_assert(alignof(UCrabCosmeticsDA) == 0x000008, "Wrong alignment on UCrabCosmeticsDA");
static_assert(sizeof(UCrabCosmeticsDA) == 0x000040, "Wrong size on UCrabCosmeticsDA");
static_assert(offsetof(UCrabCosmeticsDA, CrabSkins) == 0x000030, "Member 'UCrabCosmeticsDA::CrabSkins' has a wrong offset!");

// Class CrabChampions.CrabCosmeticSlotUI
// 0x0078 (0x0330 - 0x02B8)
class UCrabCosmeticSlotUI : public UCrabUI
{
public:
	struct FCrabChallenge                         ChallengeToUnlock;                                 // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UCrabCosmeticsMenuUI*                   OwningCosmeticsMenuUI;                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SlotButton;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotIconImage;                                     // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SlotLockedOverlay;                                 // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                SlotSelectedBorder;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredSlotButton();
	void OnPressedSlotButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticSlotUI">();
	}
	static class UCrabCosmeticSlotUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCosmeticSlotUI>();
	}
};
static_assert(alignof(UCrabCosmeticSlotUI) == 0x000008, "Wrong alignment on UCrabCosmeticSlotUI");
static_assert(sizeof(UCrabCosmeticSlotUI) == 0x000330, "Wrong size on UCrabCosmeticSlotUI");
static_assert(offsetof(UCrabCosmeticSlotUI, ChallengeToUnlock) == 0x0002B8, "Member 'UCrabCosmeticSlotUI::ChallengeToUnlock' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, OwningCosmeticsMenuUI) == 0x000308, "Member 'UCrabCosmeticSlotUI::OwningCosmeticsMenuUI' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotButton) == 0x000310, "Member 'UCrabCosmeticSlotUI::SlotButton' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotIconImage) == 0x000318, "Member 'UCrabCosmeticSlotUI::SlotIconImage' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotLockedOverlay) == 0x000320, "Member 'UCrabCosmeticSlotUI::SlotLockedOverlay' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotSelectedBorder) == 0x000328, "Member 'UCrabCosmeticSlotUI::SlotSelectedBorder' has a wrong offset!");

// Class CrabChampions.CrabCosmeticsMenuUI
// 0x0058 (0x0428 - 0x03D0)
class UCrabCosmeticsMenuUI : public UCrabFocusMenuUI
{
public:
	class ACrabCosmeticC*                         CosmeticC;                                         // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabCosmeticSlotUI>        CosmeticSlotUIToSpawn;                             // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      CosmeticsUniformGridPanel;                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                CrabSkinsButton;                                   // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                WeaponSkinsButton;                                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCosmeticSlotUI*                    SelectedCosmeticSlotUI;                            // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticNameText;                                  // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeDescriptionText;                          // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeProgressText;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeGoalText;                                 // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ChallengePB;                                       // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedCrabSkinsButton();
	void OnPressedWeaponSkinsButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticsMenuUI">();
	}
	static class UCrabCosmeticsMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCosmeticsMenuUI>();
	}
};
static_assert(alignof(UCrabCosmeticsMenuUI) == 0x000008, "Wrong alignment on UCrabCosmeticsMenuUI");
static_assert(sizeof(UCrabCosmeticsMenuUI) == 0x000428, "Wrong size on UCrabCosmeticsMenuUI");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticC) == 0x0003D0, "Member 'UCrabCosmeticsMenuUI::CosmeticC' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticSlotUIToSpawn) == 0x0003D8, "Member 'UCrabCosmeticsMenuUI::CosmeticSlotUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticsUniformGridPanel) == 0x0003E0, "Member 'UCrabCosmeticsMenuUI::CosmeticsUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CrabSkinsButton) == 0x0003E8, "Member 'UCrabCosmeticsMenuUI::CrabSkinsButton' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, WeaponSkinsButton) == 0x0003F0, "Member 'UCrabCosmeticsMenuUI::WeaponSkinsButton' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, SelectedCosmeticSlotUI) == 0x0003F8, "Member 'UCrabCosmeticsMenuUI::SelectedCosmeticSlotUI' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticNameText) == 0x000400, "Member 'UCrabCosmeticsMenuUI::CosmeticNameText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengeDescriptionText) == 0x000408, "Member 'UCrabCosmeticsMenuUI::ChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengeProgressText) == 0x000410, "Member 'UCrabCosmeticsMenuUI::ChallengeProgressText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengeGoalText) == 0x000418, "Member 'UCrabCosmeticsMenuUI::ChallengeGoalText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengePB) == 0x000420, "Member 'UCrabCosmeticsMenuUI::ChallengePB' has a wrong offset!");

// Class CrabChampions.CrabCrosshairUI
// 0x0090 (0x0348 - 0x02B8)
class UCrabCrosshairUI : public UCrabUI
{
public:
	class UMaterialInterface*                     CrossMat;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CircleMat;                                         // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BrokenCircleMat;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DotMat;                                            // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           OwningC;                                           // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabWeapon*                            EquippedWeapon;                                    // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrosshairImage;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CrosshairMI;                                       // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 HitmarkerImage;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       GenericHitmarkerAnim;                              // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ArmorBreakHitmarkerAnim;                           // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       EliminationHitmarkerAnim;                          // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ReloadProgressOverlay;                             // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ReloadProgressImage;                               // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ReloadProgressMI;                                  // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCrosshairUI">();
	}
	static class UCrabCrosshairUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCrosshairUI>();
	}
};
static_assert(alignof(UCrabCrosshairUI) == 0x000008, "Wrong alignment on UCrabCrosshairUI");
static_assert(sizeof(UCrabCrosshairUI) == 0x000348, "Wrong size on UCrabCrosshairUI");
static_assert(offsetof(UCrabCrosshairUI, CrossMat) == 0x0002B8, "Member 'UCrabCrosshairUI::CrossMat' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, CircleMat) == 0x0002C0, "Member 'UCrabCrosshairUI::CircleMat' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, BrokenCircleMat) == 0x0002C8, "Member 'UCrabCrosshairUI::BrokenCircleMat' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, DotMat) == 0x0002D0, "Member 'UCrabCrosshairUI::DotMat' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, OwningC) == 0x0002D8, "Member 'UCrabCrosshairUI::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, EquippedWeapon) == 0x0002E0, "Member 'UCrabCrosshairUI::EquippedWeapon' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, CrosshairImage) == 0x0002E8, "Member 'UCrabCrosshairUI::CrosshairImage' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, CrosshairMI) == 0x0002F0, "Member 'UCrabCrosshairUI::CrosshairMI' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, HitmarkerImage) == 0x000308, "Member 'UCrabCrosshairUI::HitmarkerImage' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, GenericHitmarkerAnim) == 0x000310, "Member 'UCrabCrosshairUI::GenericHitmarkerAnim' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, ArmorBreakHitmarkerAnim) == 0x000318, "Member 'UCrabCrosshairUI::ArmorBreakHitmarkerAnim' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, EliminationHitmarkerAnim) == 0x000320, "Member 'UCrabCrosshairUI::EliminationHitmarkerAnim' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, ReloadProgressOverlay) == 0x000328, "Member 'UCrabCrosshairUI::ReloadProgressOverlay' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, ReloadProgressImage) == 0x000330, "Member 'UCrabCrosshairUI::ReloadProgressImage' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, ReloadProgressMI) == 0x000338, "Member 'UCrabCrosshairUI::ReloadProgressMI' has a wrong offset!");

// Class CrabChampions.CrabCrown
// 0x0030 (0x02A8 - 0x0278)
class ACrabCrown final : public ACrabInteractable
{
public:
	class UStaticMeshComponent*                   CrownMesh;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CrownNC;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CrownAC;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Mesh;                                              // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCrown">();
	}
	static class ACrabCrown* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCrown>();
	}
};
static_assert(alignof(ACrabCrown) == 0x000008, "Wrong alignment on ACrabCrown");
static_assert(sizeof(ACrabCrown) == 0x0002A8, "Wrong size on ACrabCrown");
static_assert(offsetof(ACrabCrown, CrownMesh) == 0x000278, "Member 'ACrabCrown::CrownMesh' has a wrong offset!");
static_assert(offsetof(ACrabCrown, CrownNC) == 0x000280, "Member 'ACrabCrown::CrownNC' has a wrong offset!");
static_assert(offsetof(ACrabCrown, CrownAC) == 0x000288, "Member 'ACrabCrown::CrownAC' has a wrong offset!");
static_assert(offsetof(ACrabCrown, Mesh) == 0x000290, "Member 'ACrabCrown::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabCrown, FX) == 0x000298, "Member 'ACrabCrown::FX' has a wrong offset!");
static_assert(offsetof(ACrabCrown, Sound) == 0x0002A0, "Member 'ACrabCrown::Sound' has a wrong offset!");

// Class CrabChampions.CrabCrystalPickup
// 0x0010 (0x0278 - 0x0268)
class ACrabCrystalPickup : public ACrabOverlapPickup
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECrabCrystalDropType                          CrystalDropType;                                   // 0x0270(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CrystalDropType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCrystalPickup">();
	}
	static class ACrabCrystalPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCrystalPickup>();
	}
};
static_assert(alignof(ACrabCrystalPickup) == 0x000008, "Wrong alignment on ACrabCrystalPickup");
static_assert(sizeof(ACrabCrystalPickup) == 0x000278, "Wrong size on ACrabCrystalPickup");
static_assert(offsetof(ACrabCrystalPickup, CrystalDropType) == 0x000270, "Member 'ACrabCrystalPickup::CrystalDropType' has a wrong offset!");

// Class CrabChampions.CrabDamageArea
// 0x0120 (0x0340 - 0x0220)
class ACrabDamageArea : public AActor
{
public:
	class UNiagaraComponent*                      DamageAreaNC;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        DamageAreaAC;                                      // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowOverlappingDamageAreas;                      // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignToGround;                                    // 0x0231(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageAreaType                           DamageAreaType;                                    // 0x0232(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_233[0x1];                                      // 0x0233(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusMultiplier;                                  // 0x0238(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMat;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DamageAreaDC;                                      // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0260(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0270(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FCrabDamageInfo                        DamageInfo;                                        // 0x0280(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               DamageType;                                        // 0x02CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            Debuff;                                            // 0x02D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bScaleDebuffStackByDamageMultiplier;               // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockbackStrength;                                 // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyDealDamageIfGrounded;                         // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageInterval;                                    // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabPlayerC*>                   DamagedPlayers;                                    // 0x02F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabC*>                         OverlappingCharacters;                             // 0x0308(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         OverlappingPhysicsActors;                          // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         EnergyRingSpeed;                                   // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuctionForce;                                      // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0xC];                                      // 0x0334(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastDeactivateDamageArea();
	void OnRep_RadiusMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageArea">();
	}
	static class ACrabDamageArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabDamageArea>();
	}
};
static_assert(alignof(ACrabDamageArea) == 0x000008, "Wrong alignment on ACrabDamageArea");
static_assert(sizeof(ACrabDamageArea) == 0x000340, "Wrong size on ACrabDamageArea");
static_assert(offsetof(ACrabDamageArea, DamageAreaNC) == 0x000220, "Member 'ACrabDamageArea::DamageAreaNC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageAreaAC) == 0x000228, "Member 'ACrabDamageArea::DamageAreaAC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, bAllowOverlappingDamageAreas) == 0x000230, "Member 'ACrabDamageArea::bAllowOverlappingDamageAreas' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, bAlignToGround) == 0x000231, "Member 'ACrabDamageArea::bAlignToGround' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageAreaType) == 0x000232, "Member 'ACrabDamageArea::DamageAreaType' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Radius) == 0x000234, "Member 'ACrabDamageArea::Radius' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, RadiusMultiplier) == 0x000238, "Member 'ACrabDamageArea::RadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, LifeTime) == 0x00023C, "Member 'ACrabDamageArea::LifeTime' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, FX) == 0x000240, "Member 'ACrabDamageArea::FX' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Sound) == 0x000248, "Member 'ACrabDamageArea::Sound' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DecalMat) == 0x000250, "Member 'ACrabDamageArea::DecalMat' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageAreaDC) == 0x000258, "Member 'ACrabDamageArea::DamageAreaDC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, OwningC) == 0x000260, "Member 'ACrabDamageArea::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, ActorsToIgnore) == 0x000270, "Member 'ACrabDamageArea::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageInfo) == 0x000280, "Member 'ACrabDamageArea::DamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Damage) == 0x0002C8, "Member 'ACrabDamageArea::Damage' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageType) == 0x0002CC, "Member 'ACrabDamageArea::DamageType' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Debuff) == 0x0002D0, "Member 'ACrabDamageArea::Debuff' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, bScaleDebuffStackByDamageMultiplier) == 0x0002D8, "Member 'ACrabDamageArea::bScaleDebuffStackByDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, KnockbackStrength) == 0x0002DC, "Member 'ACrabDamageArea::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, bOnlyDealDamageIfGrounded) == 0x0002E0, "Member 'ACrabDamageArea::bOnlyDealDamageIfGrounded' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageInterval) == 0x0002E4, "Member 'ACrabDamageArea::DamageInterval' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamagedPlayers) == 0x0002F0, "Member 'ACrabDamageArea::DamagedPlayers' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, OverlappingCharacters) == 0x000308, "Member 'ACrabDamageArea::OverlappingCharacters' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, OverlappingPhysicsActors) == 0x000318, "Member 'ACrabDamageArea::OverlappingPhysicsActors' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, EnergyRingSpeed) == 0x000328, "Member 'ACrabDamageArea::EnergyRingSpeed' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, SuctionForce) == 0x000330, "Member 'ACrabDamageArea::SuctionForce' has a wrong offset!");

// Class CrabChampions.CrabDamageInterface
// 0x0000 (0x0000 - 0x0000)
class ICrabDamageInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageInterface">();
	}
	static class ICrabDamageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICrabDamageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICrabDamageInterface) == 0x000001, "Wrong alignment on ICrabDamageInterface");
static_assert(sizeof(ICrabDamageInterface) == 0x000001, "Wrong size on ICrabDamageInterface");

// Class CrabChampions.CrabDamageTextActor
// 0x0020 (0x0240 - 0x0220)
class ACrabDamageTextActor final : public AActor
{
public:
	class UWidgetComponent*                       DamageTextWC;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabDamageTextUI*                      DamageTextUI;                                      // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageTextActor">();
	}
	static class ACrabDamageTextActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabDamageTextActor>();
	}
};
static_assert(alignof(ACrabDamageTextActor) == 0x000008, "Wrong alignment on ACrabDamageTextActor");
static_assert(sizeof(ACrabDamageTextActor) == 0x000240, "Wrong size on ACrabDamageTextActor");
static_assert(offsetof(ACrabDamageTextActor, DamageTextWC) == 0x000220, "Member 'ACrabDamageTextActor::DamageTextWC' has a wrong offset!");
static_assert(offsetof(ACrabDamageTextActor, DamageTextUI) == 0x000228, "Member 'ACrabDamageTextActor::DamageTextUI' has a wrong offset!");

// Class CrabChampions.CrabDamageTextUI
// 0x0018 (0x0278 - 0x0260)
class UCrabDamageTextUI : public UUserWidget
{
public:
	class UScaleBox*                              DamageTextScaleBox;                                // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DamageText;                                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       DamageTextAnim;                                    // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageTextUI">();
	}
	static class UCrabDamageTextUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabDamageTextUI>();
	}
};
static_assert(alignof(UCrabDamageTextUI) == 0x000008, "Wrong alignment on UCrabDamageTextUI");
static_assert(sizeof(UCrabDamageTextUI) == 0x000278, "Wrong size on UCrabDamageTextUI");
static_assert(offsetof(UCrabDamageTextUI, DamageTextScaleBox) == 0x000260, "Member 'UCrabDamageTextUI::DamageTextScaleBox' has a wrong offset!");
static_assert(offsetof(UCrabDamageTextUI, DamageText) == 0x000268, "Member 'UCrabDamageTextUI::DamageText' has a wrong offset!");
static_assert(offsetof(UCrabDamageTextUI, DamageTextAnim) == 0x000270, "Member 'UCrabDamageTextUI::DamageTextAnim' has a wrong offset!");

// Class CrabChampions.CrabDestructible
// 0x01E8 (0x0408 - 0x0220)
class ACrabDestructible : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LeakAC;                                            // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabHC*                                HC;                                                // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECrabIslandType>                       BannedIslandTypes;                                 // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpawnWeight;                                       // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            MeshToSpawn;                                       // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshMat;                                           // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MeshFX;                                            // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MeshNC;                                            // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       HealthBarWC;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabHealthBarUI>           HealthBarUIToSpawn;                                // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreCharacterCollision;                         // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDamageType>                       ImmuneDamageTypes;                                 // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bScaleMaxHealthByIsland;                           // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinScale;                                          // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScale;                                          // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleMultiplier;                                   // 0x02BC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProximityExplosionOverlapRadius;                   // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProximityExplosionDelay;                           // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsProximityExplosionTriggered;                    // 0x02D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ProximityExplosionTriggeredFX;                     // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ProximityExplosionTriggeredSound;                  // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPhysicallySimulated;                            // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsMassScale;                                  // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsLinearDamping;                              // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsImpulseMultiplier;                          // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChaoticPhysicsMovement;                           // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsHomingScale;                                // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 HomingTarget;                                      // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PhysicsImpactSound;                                // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x18];                                     // 0x0320(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 DamagingC;                                         // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        PotentialNestEnemiesToSpawn;                       // 0x0348(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x4];                                      // 0x0358(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanLeak;                                          // 0x035C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35D[0xB];                                      // 0x035D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         LeakFX;                                            // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LeakSound;                                         // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              Leaks;                                             // 0x0378(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x14];                                     // 0x0388(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionRadius;                                   // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleExplosionDamageByIsland;                     // 0x03A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDamage;                                   // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               ExplosionDamageType;                               // 0x03A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            ExplosionDebuff;                                   // 0x03AC(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ExplosionKnockbackStrength;                        // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawn;                                 // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabRarity                                   CrystalsToSpawnRarity;                             // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToSpawnRandomPickup;                         // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACrabEnemyC>>        PotentialChallengeEnemiesToSpawn;                  // 0x03C8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         ChanceToSpawnChallengeEnemies;                     // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinChallengeEnemiesToSpawn;                        // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxChallengeEnemiesToSpawn;                        // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabProjectileDA*                      SecondaryProjectileToSpawn;                        // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSecondaryProjectilesToSpawn;                    // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastAddLeak(const struct FVector_NetQuantize& DamageLoc);
	void MulticastExplode(class ACrabC* ExplodingC);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_IsProximityExplosionTriggered();
	void OnRep_ScaleMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDestructible">();
	}
	static class ACrabDestructible* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabDestructible>();
	}
};
static_assert(alignof(ACrabDestructible) == 0x000008, "Wrong alignment on ACrabDestructible");
static_assert(sizeof(ACrabDestructible) == 0x000408, "Wrong size on ACrabDestructible");
static_assert(offsetof(ACrabDestructible, Mesh) == 0x000228, "Member 'ACrabDestructible::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, LeakAC) == 0x000230, "Member 'ACrabDestructible::LeakAC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HC) == 0x000238, "Member 'ACrabDestructible::HC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, BannedIslandTypes) == 0x000240, "Member 'ACrabDestructible::BannedIslandTypes' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, SpawnWeight) == 0x000250, "Member 'ACrabDestructible::SpawnWeight' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshToSpawn) == 0x000258, "Member 'ACrabDestructible::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshMat) == 0x000260, "Member 'ACrabDestructible::MeshMat' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshFX) == 0x000268, "Member 'ACrabDestructible::MeshFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshNC) == 0x000270, "Member 'ACrabDestructible::MeshNC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, Tint) == 0x000278, "Member 'ACrabDestructible::Tint' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HealthBarWC) == 0x000288, "Member 'ACrabDestructible::HealthBarWC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HealthBarUIToSpawn) == 0x000290, "Member 'ACrabDestructible::HealthBarUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bIgnoreCharacterCollision) == 0x000298, "Member 'ACrabDestructible::bIgnoreCharacterCollision' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ImmuneDamageTypes) == 0x0002A0, "Member 'ACrabDestructible::ImmuneDamageTypes' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bScaleMaxHealthByIsland) == 0x0002B0, "Member 'ACrabDestructible::bScaleMaxHealthByIsland' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MinScale) == 0x0002B4, "Member 'ACrabDestructible::MinScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MaxScale) == 0x0002B8, "Member 'ACrabDestructible::MaxScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ScaleMultiplier) == 0x0002BC, "Member 'ACrabDestructible::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionOverlapRadius) == 0x0002D0, "Member 'ACrabDestructible::ProximityExplosionOverlapRadius' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionDelay) == 0x0002D4, "Member 'ACrabDestructible::ProximityExplosionDelay' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bIsProximityExplosionTriggered) == 0x0002D8, "Member 'ACrabDestructible::bIsProximityExplosionTriggered' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionTriggeredFX) == 0x0002E0, "Member 'ACrabDestructible::ProximityExplosionTriggeredFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionTriggeredSound) == 0x0002E8, "Member 'ACrabDestructible::ProximityExplosionTriggeredSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bIsPhysicallySimulated) == 0x0002F8, "Member 'ACrabDestructible::bIsPhysicallySimulated' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsMassScale) == 0x0002FC, "Member 'ACrabDestructible::PhysicsMassScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsLinearDamping) == 0x000300, "Member 'ACrabDestructible::PhysicsLinearDamping' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsImpulseMultiplier) == 0x000304, "Member 'ACrabDestructible::PhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bChaoticPhysicsMovement) == 0x000308, "Member 'ACrabDestructible::bChaoticPhysicsMovement' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsHomingScale) == 0x00030C, "Member 'ACrabDestructible::PhysicsHomingScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HomingTarget) == 0x000310, "Member 'ACrabDestructible::HomingTarget' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsImpactSound) == 0x000318, "Member 'ACrabDestructible::PhysicsImpactSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, DamagingC) == 0x000338, "Member 'ACrabDestructible::DamagingC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PotentialNestEnemiesToSpawn) == 0x000348, "Member 'ACrabDestructible::PotentialNestEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bCanLeak) == 0x00035C, "Member 'ACrabDestructible::bCanLeak' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, LeakFX) == 0x000368, "Member 'ACrabDestructible::LeakFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, LeakSound) == 0x000370, "Member 'ACrabDestructible::LeakSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, Leaks) == 0x000378, "Member 'ACrabDestructible::Leaks' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionRadius) == 0x00039C, "Member 'ACrabDestructible::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bScaleExplosionDamageByIsland) == 0x0003A0, "Member 'ACrabDestructible::bScaleExplosionDamageByIsland' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionDamage) == 0x0003A4, "Member 'ACrabDestructible::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionDamageType) == 0x0003A8, "Member 'ACrabDestructible::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionDebuff) == 0x0003AC, "Member 'ACrabDestructible::ExplosionDebuff' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionKnockbackStrength) == 0x0003B4, "Member 'ACrabDestructible::ExplosionKnockbackStrength' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, DamageAreaToSpawn) == 0x0003B8, "Member 'ACrabDestructible::DamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, CrystalsToSpawnRarity) == 0x0003C0, "Member 'ACrabDestructible::CrystalsToSpawnRarity' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ChanceToSpawnRandomPickup) == 0x0003C4, "Member 'ACrabDestructible::ChanceToSpawnRandomPickup' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PotentialChallengeEnemiesToSpawn) == 0x0003C8, "Member 'ACrabDestructible::PotentialChallengeEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ChanceToSpawnChallengeEnemies) == 0x0003D8, "Member 'ACrabDestructible::ChanceToSpawnChallengeEnemies' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MinChallengeEnemiesToSpawn) == 0x0003DC, "Member 'ACrabDestructible::MinChallengeEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MaxChallengeEnemiesToSpawn) == 0x0003E0, "Member 'ACrabDestructible::MaxChallengeEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionFX) == 0x0003E8, "Member 'ACrabDestructible::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionSound) == 0x0003F0, "Member 'ACrabDestructible::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, SecondaryProjectileToSpawn) == 0x0003F8, "Member 'ACrabDestructible::SecondaryProjectileToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, NumSecondaryProjectilesToSpawn) == 0x000400, "Member 'ACrabDestructible::NumSecondaryProjectilesToSpawn' has a wrong offset!");

// Class CrabChampions.CrabDifficultyMenuUI
// 0x0080 (0x0450 - 0x03D0)
class UCrabDifficultyMenuUI : public UCrabFocusMenuUI
{
public:
	class UOverlay*                               EasyButtonOverlay;                                 // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                EasyButton;                                        // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               EasyChallengeLevelOverlay;                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NormalButtonOverlay;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NormalButton;                                      // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NormalChallengeLevelOverlay;                       // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NightmareButtonOverlay;                            // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NightmareButton;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NightmareChallengeLevelOverlay;                    // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         UltraChaosHorizontalBox;                           // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               UltraChaosButtonOverlay;                           // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                UltraChaosButton;                                  // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               UltraChaosChallengeLevelOverlay;                   // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeLevelText;                                // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           DifficultyModifiersVerticalBox;                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDifficultyModifierUI>  DifficultyModifierUIToSpawn;                       // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredEasyButton();
	void OnHoveredNightmareButton();
	void OnHoveredNormalButton();
	void OnHoveredUltraChaosButton();
	void OnPressedEasyButton();
	void OnPressedNightmareButton();
	void OnPressedNormalButton();
	void OnPressedUltraChaosButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDifficultyMenuUI">();
	}
	static class UCrabDifficultyMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabDifficultyMenuUI>();
	}
};
static_assert(alignof(UCrabDifficultyMenuUI) == 0x000008, "Wrong alignment on UCrabDifficultyMenuUI");
static_assert(sizeof(UCrabDifficultyMenuUI) == 0x000450, "Wrong size on UCrabDifficultyMenuUI");
static_assert(offsetof(UCrabDifficultyMenuUI, EasyButtonOverlay) == 0x0003D0, "Member 'UCrabDifficultyMenuUI::EasyButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, EasyButton) == 0x0003D8, "Member 'UCrabDifficultyMenuUI::EasyButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, EasyChallengeLevelOverlay) == 0x0003E0, "Member 'UCrabDifficultyMenuUI::EasyChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NormalButtonOverlay) == 0x0003E8, "Member 'UCrabDifficultyMenuUI::NormalButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NormalButton) == 0x0003F0, "Member 'UCrabDifficultyMenuUI::NormalButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NormalChallengeLevelOverlay) == 0x0003F8, "Member 'UCrabDifficultyMenuUI::NormalChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NightmareButtonOverlay) == 0x000400, "Member 'UCrabDifficultyMenuUI::NightmareButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NightmareButton) == 0x000408, "Member 'UCrabDifficultyMenuUI::NightmareButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NightmareChallengeLevelOverlay) == 0x000410, "Member 'UCrabDifficultyMenuUI::NightmareChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosHorizontalBox) == 0x000418, "Member 'UCrabDifficultyMenuUI::UltraChaosHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosButtonOverlay) == 0x000420, "Member 'UCrabDifficultyMenuUI::UltraChaosButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosButton) == 0x000428, "Member 'UCrabDifficultyMenuUI::UltraChaosButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosChallengeLevelOverlay) == 0x000430, "Member 'UCrabDifficultyMenuUI::UltraChaosChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, ChallengeLevelText) == 0x000438, "Member 'UCrabDifficultyMenuUI::ChallengeLevelText' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, DifficultyModifiersVerticalBox) == 0x000440, "Member 'UCrabDifficultyMenuUI::DifficultyModifiersVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, DifficultyModifierUIToSpawn) == 0x000448, "Member 'UCrabDifficultyMenuUI::DifficultyModifierUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabDifficultyModifierUI
// 0x0040 (0x02F8 - 0x02B8)
class UCrabDifficultyModifierUI : public UCrabUI
{
public:
	class UCrabDifficultyMenuUI*                  OwningDifficultyMenuUI;                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               DifficultyModifierOverlay;                         // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                DifficultyModifierButton;                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyModifierNameText;                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyModifierDescriptionText;                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ChallengeLevelOverlay;                             // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeLevelText;                                // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredDifficultyModifierButton();
	void OnPressedDifficultyModifierButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDifficultyModifierUI">();
	}
	static class UCrabDifficultyModifierUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabDifficultyModifierUI>();
	}
};
static_assert(alignof(UCrabDifficultyModifierUI) == 0x000008, "Wrong alignment on UCrabDifficultyModifierUI");
static_assert(sizeof(UCrabDifficultyModifierUI) == 0x0002F8, "Wrong size on UCrabDifficultyModifierUI");
static_assert(offsetof(UCrabDifficultyModifierUI, OwningDifficultyMenuUI) == 0x0002B8, "Member 'UCrabDifficultyModifierUI::OwningDifficultyMenuUI' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierOverlay) == 0x0002C8, "Member 'UCrabDifficultyModifierUI::DifficultyModifierOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierButton) == 0x0002D0, "Member 'UCrabDifficultyModifierUI::DifficultyModifierButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierNameText) == 0x0002D8, "Member 'UCrabDifficultyModifierUI::DifficultyModifierNameText' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierDescriptionText) == 0x0002E0, "Member 'UCrabDifficultyModifierUI::DifficultyModifierDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, ChallengeLevelOverlay) == 0x0002E8, "Member 'UCrabDifficultyModifierUI::ChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, ChallengeLevelText) == 0x0002F0, "Member 'UCrabDifficultyModifierUI::ChallengeLevelText' has a wrong offset!");

// Class CrabChampions.CrabEnemyAIC
// 0x00C0 (0x03E8 - 0x0328)
class ACrabEnemyAIC final : public AAIController
{
public:
	struct FCrabAISettings                        AISettings;                                        // 0x0328(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabEnemyC*                            OwnedC;                                            // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 BestEnemyC;                                        // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x30];                                     // 0x0370(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              RangedActionEnvQuery;                              // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x40];                                     // 0x03A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyAIC">();
	}
	static class ACrabEnemyAIC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabEnemyAIC>();
	}
};
static_assert(alignof(ACrabEnemyAIC) == 0x000008, "Wrong alignment on ACrabEnemyAIC");
static_assert(sizeof(ACrabEnemyAIC) == 0x0003E8, "Wrong size on ACrabEnemyAIC");
static_assert(offsetof(ACrabEnemyAIC, AISettings) == 0x000328, "Member 'ACrabEnemyAIC::AISettings' has a wrong offset!");
static_assert(offsetof(ACrabEnemyAIC, OwnedC) == 0x000358, "Member 'ACrabEnemyAIC::OwnedC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyAIC, BestEnemyC) == 0x000368, "Member 'ACrabEnemyAIC::BestEnemyC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyAIC, RangedActionEnvQuery) == 0x0003A0, "Member 'ACrabEnemyAIC::RangedActionEnvQuery' has a wrong offset!");

// Class CrabChampions.CrabEnemyAnimInstance
// 0x0010 (0x02E0 - 0x02D0)
class UCrabEnemyAnimInstance : public UCrabAnimInstance
{
public:
	class ACrabEnemyC*                            OwningEnemyC;                                      // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomAnimOffset;                                  // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_Action();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyAnimInstance">();
	}
	static class UCrabEnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabEnemyAnimInstance>();
	}
};
static_assert(alignof(UCrabEnemyAnimInstance) == 0x000010, "Wrong alignment on UCrabEnemyAnimInstance");
static_assert(sizeof(UCrabEnemyAnimInstance) == 0x0002E0, "Wrong size on UCrabEnemyAnimInstance");
static_assert(offsetof(UCrabEnemyAnimInstance, OwningEnemyC) == 0x0002D0, "Member 'UCrabEnemyAnimInstance::OwningEnemyC' has a wrong offset!");
static_assert(offsetof(UCrabEnemyAnimInstance, RandomAnimOffset) == 0x0002D8, "Member 'UCrabEnemyAnimInstance::RandomAnimOffset' has a wrong offset!");

// Class CrabChampions.CrabEnemyEQC
// 0x0008 (0x0030 - 0x0028)
class UCrabEnemyEQC : public UEnvQueryContext
{
public:
	ECrabEQCType                                  EQCType;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyEQC">();
	}
	static class UCrabEnemyEQC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabEnemyEQC>();
	}
};
static_assert(alignof(UCrabEnemyEQC) == 0x000008, "Wrong alignment on UCrabEnemyEQC");
static_assert(sizeof(UCrabEnemyEQC) == 0x000030, "Wrong size on UCrabEnemyEQC");
static_assert(offsetof(UCrabEnemyEQC, EQCType) == 0x000028, "Member 'UCrabEnemyEQC::EQCType' has a wrong offset!");

// Class CrabChampions.CrabEnhancementUI
// 0x0020 (0x02D8 - 0x02B8)
class UCrabEnhancementUI : public UCrabUI
{
public:
	class UImage*                                 IconImage;                                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameText;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DescriptionText;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RarityBorder;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnhancementUI">();
	}
	static class UCrabEnhancementUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabEnhancementUI>();
	}
};
static_assert(alignof(UCrabEnhancementUI) == 0x000008, "Wrong alignment on UCrabEnhancementUI");
static_assert(sizeof(UCrabEnhancementUI) == 0x0002D8, "Wrong size on UCrabEnhancementUI");
static_assert(offsetof(UCrabEnhancementUI, IconImage) == 0x0002B8, "Member 'UCrabEnhancementUI::IconImage' has a wrong offset!");
static_assert(offsetof(UCrabEnhancementUI, NameText) == 0x0002C0, "Member 'UCrabEnhancementUI::NameText' has a wrong offset!");
static_assert(offsetof(UCrabEnhancementUI, DescriptionText) == 0x0002C8, "Member 'UCrabEnhancementUI::DescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabEnhancementUI, RarityBorder) == 0x0002D0, "Member 'UCrabEnhancementUI::RarityBorder' has a wrong offset!");

// Class CrabChampions.CrabFireWeaponActionDA
// 0x0008 (0x0070 - 0x0068)
class UCrabFireWeaponActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Spread;                                            // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabFireWeaponActionDA">();
	}
	static class UCrabFireWeaponActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabFireWeaponActionDA>();
	}
};
static_assert(alignof(UCrabFireWeaponActionDA) == 0x000008, "Wrong alignment on UCrabFireWeaponActionDA");
static_assert(sizeof(UCrabFireWeaponActionDA) == 0x000070, "Wrong size on UCrabFireWeaponActionDA");
static_assert(offsetof(UCrabFireWeaponActionDA, TargetType) == 0x000068, "Member 'UCrabFireWeaponActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabFireWeaponActionDA, Spread) == 0x00006C, "Member 'UCrabFireWeaponActionDA::Spread' has a wrong offset!");

// Class CrabChampions.CrabGameOverRowUI
// 0x0030 (0x02E8 - 0x02B8)
class UCrabGameOverRowUI : public UCrabUI
{
public:
	class UImage*                                 MVPCrownImage;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DamageDealtText;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EliminationsText;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DamageTakenText;                                   // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FlawlessIslandsText;                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameOverRowUI">();
	}
	static class UCrabGameOverRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameOverRowUI>();
	}
};
static_assert(alignof(UCrabGameOverRowUI) == 0x000008, "Wrong alignment on UCrabGameOverRowUI");
static_assert(sizeof(UCrabGameOverRowUI) == 0x0002E8, "Wrong size on UCrabGameOverRowUI");
static_assert(offsetof(UCrabGameOverRowUI, MVPCrownImage) == 0x0002B8, "Member 'UCrabGameOverRowUI::MVPCrownImage' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, PlayerNameText) == 0x0002C0, "Member 'UCrabGameOverRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, DamageDealtText) == 0x0002C8, "Member 'UCrabGameOverRowUI::DamageDealtText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, EliminationsText) == 0x0002D0, "Member 'UCrabGameOverRowUI::EliminationsText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, DamageTakenText) == 0x0002D8, "Member 'UCrabGameOverRowUI::DamageTakenText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, FlawlessIslandsText) == 0x0002E0, "Member 'UCrabGameOverRowUI::FlawlessIslandsText' has a wrong offset!");

// Class CrabChampions.CrabGameOverUI
// 0x00D8 (0x04A8 - 0x03D0)
class UCrabGameOverUI : public UCrabFocusMenuUI
{
public:
	class UTextBlock*                             RunResultText;                                     // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyText;                                    // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AttemptsText;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinsText;                                          // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinStreakText;                                     // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandsSurvivedText;                               // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighestIslandReachedText;                          // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalTimeTakenText;                                // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           GameOverRowUIVerticalBox;                          // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameOverRowUI>         GameOverRowUIToSpawn;                              // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0420(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCrabUnlockedCosmeticUI>    UnlockedCosmeticUIToSpawn;                         // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         UnlockedCosmeticsHorizontalBox;                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpWeaponText;                                // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RankedUpWeaponMedalIconImage;                      // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpWeaponRankText;                            // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RankedUpWeaponAnim;                                // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpAbilityText;                               // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RankedUpAbilityMedalIconImage;                     // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpAbilityRankText;                           // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RankedUpAbilityAnim;                               // 0x0480(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpMeleeWeaponText;                           // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RankedUpMeleeWeaponMedalIconImage;                 // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpMeleeWeaponRankText;                       // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RankedUpMeleeWeaponAnim;                           // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameOverUI">();
	}
	static class UCrabGameOverUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameOverUI>();
	}
};
static_assert(alignof(UCrabGameOverUI) == 0x000008, "Wrong alignment on UCrabGameOverUI");
static_assert(sizeof(UCrabGameOverUI) == 0x0004A8, "Wrong size on UCrabGameOverUI");
static_assert(offsetof(UCrabGameOverUI, RunResultText) == 0x0003D0, "Member 'UCrabGameOverUI::RunResultText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, DifficultyText) == 0x0003D8, "Member 'UCrabGameOverUI::DifficultyText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, AttemptsText) == 0x0003E0, "Member 'UCrabGameOverUI::AttemptsText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, WinsText) == 0x0003E8, "Member 'UCrabGameOverUI::WinsText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, WinStreakText) == 0x0003F0, "Member 'UCrabGameOverUI::WinStreakText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, IslandsSurvivedText) == 0x0003F8, "Member 'UCrabGameOverUI::IslandsSurvivedText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, HighestIslandReachedText) == 0x000400, "Member 'UCrabGameOverUI::HighestIslandReachedText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, TotalTimeTakenText) == 0x000408, "Member 'UCrabGameOverUI::TotalTimeTakenText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, GameOverRowUIVerticalBox) == 0x000410, "Member 'UCrabGameOverUI::GameOverRowUIVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, GameOverRowUIToSpawn) == 0x000418, "Member 'UCrabGameOverUI::GameOverRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, CompletedChallenges) == 0x000420, "Member 'UCrabGameOverUI::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, UnlockedCosmeticUIToSpawn) == 0x000438, "Member 'UCrabGameOverUI::UnlockedCosmeticUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, UnlockedCosmeticsHorizontalBox) == 0x000440, "Member 'UCrabGameOverUI::UnlockedCosmeticsHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponText) == 0x000448, "Member 'UCrabGameOverUI::RankedUpWeaponText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponMedalIconImage) == 0x000450, "Member 'UCrabGameOverUI::RankedUpWeaponMedalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponRankText) == 0x000458, "Member 'UCrabGameOverUI::RankedUpWeaponRankText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponAnim) == 0x000460, "Member 'UCrabGameOverUI::RankedUpWeaponAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpAbilityText) == 0x000468, "Member 'UCrabGameOverUI::RankedUpAbilityText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpAbilityMedalIconImage) == 0x000470, "Member 'UCrabGameOverUI::RankedUpAbilityMedalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpAbilityRankText) == 0x000478, "Member 'UCrabGameOverUI::RankedUpAbilityRankText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpAbilityAnim) == 0x000480, "Member 'UCrabGameOverUI::RankedUpAbilityAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpMeleeWeaponText) == 0x000488, "Member 'UCrabGameOverUI::RankedUpMeleeWeaponText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpMeleeWeaponMedalIconImage) == 0x000490, "Member 'UCrabGameOverUI::RankedUpMeleeWeaponMedalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpMeleeWeaponRankText) == 0x000498, "Member 'UCrabGameOverUI::RankedUpMeleeWeaponRankText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpMeleeWeaponAnim) == 0x0004A0, "Member 'UCrabGameOverUI::RankedUpMeleeWeaponAnim' has a wrong offset!");

// Class CrabChampions.CrabGameplayUI
// 0x0238 (0x04F0 - 0x02B8)
class UCrabGameplayUI : public UCrabUI
{
public:
	class ACrabPlayerC*                           OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnArmorBreakAnim;                                  // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnTookDamageAnim;                                  // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EliminatedByText;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       EliminatedByAnim;                                  // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCrosshairUI*                       CrosshairUI;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabHealthBarUI*                       HealthBarUI;                                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ComboText;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedComboSmallAnim;                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedComboLargeAnim;                           // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x28];                                     // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CrystalsText;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CrystalsDifferenceText;                            // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedCrystalsAnim;                             // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x18];                                     // 0x0350(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             KeysText;                                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KeysDifferenceText;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedKeysAnim;                                 // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CrabChampionsVersionText;                          // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           FPSVerticalBox;                                    // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FPSText;                                           // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PingText;                                          // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabWeapon*                            EquippedWeapon;                                    // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ScopeImage;                                        // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnStartedScopeAimingAnim;                          // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnStoppedScopeAimingAnim;                          // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentAmmoText;                                   // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DualWieldCurrentAmmoText;                          // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponNameText;                                    // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityKeyText;                                    // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AbilityControllerIcon;                             // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AbilityIcon;                                       // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityCooldownText;                               // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnAbilityCooldownExpiredAnim;                      // 0x0408(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityStackText;                                  // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeKeyText;                                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MeleeControllerIcon;                               // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MeleeIcon;                                         // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeCooldownText;                                 // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnMeleeCooldownExpiredAnim;                        // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InventoryKeyText;                                  // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 InventoryControllerIcon;                           // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                NewPickupBorder;                                   // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupNameText;                                 // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NewPickupIcon;                                     // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupDescriptionText;                          // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupTypeText;                                 // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupLevelText;                                // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NewPickupAnim;                                     // 0x0480(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           InventoryEventVerticalBox;                         // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInventoryEventUI>      InventoryEventUIToSpawn;                           // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               ChallengeModifierSizeBox;                          // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeModifierTitleText;                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeModifierText;                             // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeModifierDescriptionText;                  // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingGoalText;                                  // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                AdditionalChallengeModifierBorder;                 // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeModifierText;                   // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeModifierDescriptionText;        // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnStartedChallengeAnim;                            // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnCompletedChallengeAnim;                          // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FlawlessIslandClearAnim;                           // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameplayUI">();
	}
	static class UCrabGameplayUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameplayUI>();
	}
};
static_assert(alignof(UCrabGameplayUI) == 0x000008, "Wrong alignment on UCrabGameplayUI");
static_assert(sizeof(UCrabGameplayUI) == 0x0004F0, "Wrong size on UCrabGameplayUI");
static_assert(offsetof(UCrabGameplayUI, OwningC) == 0x0002B8, "Member 'UCrabGameplayUI::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OwningPS) == 0x0002C0, "Member 'UCrabGameplayUI::OwningPS' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnArmorBreakAnim) == 0x0002C8, "Member 'UCrabGameplayUI::OnArmorBreakAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnTookDamageAnim) == 0x0002D0, "Member 'UCrabGameplayUI::OnTookDamageAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, EliminatedByText) == 0x0002D8, "Member 'UCrabGameplayUI::EliminatedByText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, EliminatedByAnim) == 0x0002E0, "Member 'UCrabGameplayUI::EliminatedByAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrosshairUI) == 0x0002E8, "Member 'UCrabGameplayUI::CrosshairUI' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, HealthBarUI) == 0x0002F0, "Member 'UCrabGameplayUI::HealthBarUI' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ComboText) == 0x0002F8, "Member 'UCrabGameplayUI::ComboText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedComboSmallAnim) == 0x000300, "Member 'UCrabGameplayUI::OnUpdatedComboSmallAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedComboLargeAnim) == 0x000308, "Member 'UCrabGameplayUI::OnUpdatedComboLargeAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrystalsText) == 0x000338, "Member 'UCrabGameplayUI::CrystalsText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrystalsDifferenceText) == 0x000340, "Member 'UCrabGameplayUI::CrystalsDifferenceText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedCrystalsAnim) == 0x000348, "Member 'UCrabGameplayUI::OnUpdatedCrystalsAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, KeysText) == 0x000368, "Member 'UCrabGameplayUI::KeysText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, KeysDifferenceText) == 0x000370, "Member 'UCrabGameplayUI::KeysDifferenceText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedKeysAnim) == 0x000378, "Member 'UCrabGameplayUI::OnUpdatedKeysAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrabChampionsVersionText) == 0x000390, "Member 'UCrabGameplayUI::CrabChampionsVersionText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, FPSVerticalBox) == 0x000398, "Member 'UCrabGameplayUI::FPSVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, FPSText) == 0x0003A0, "Member 'UCrabGameplayUI::FPSText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, PingText) == 0x0003A8, "Member 'UCrabGameplayUI::PingText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, EquippedWeapon) == 0x0003B0, "Member 'UCrabGameplayUI::EquippedWeapon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ScopeImage) == 0x0003B8, "Member 'UCrabGameplayUI::ScopeImage' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnStartedScopeAimingAnim) == 0x0003C0, "Member 'UCrabGameplayUI::OnStartedScopeAimingAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnStoppedScopeAimingAnim) == 0x0003C8, "Member 'UCrabGameplayUI::OnStoppedScopeAimingAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CurrentAmmoText) == 0x0003D0, "Member 'UCrabGameplayUI::CurrentAmmoText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, DualWieldCurrentAmmoText) == 0x0003D8, "Member 'UCrabGameplayUI::DualWieldCurrentAmmoText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, WeaponNameText) == 0x0003E0, "Member 'UCrabGameplayUI::WeaponNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityKeyText) == 0x0003E8, "Member 'UCrabGameplayUI::AbilityKeyText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityControllerIcon) == 0x0003F0, "Member 'UCrabGameplayUI::AbilityControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityIcon) == 0x0003F8, "Member 'UCrabGameplayUI::AbilityIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityCooldownText) == 0x000400, "Member 'UCrabGameplayUI::AbilityCooldownText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnAbilityCooldownExpiredAnim) == 0x000408, "Member 'UCrabGameplayUI::OnAbilityCooldownExpiredAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityStackText) == 0x000410, "Member 'UCrabGameplayUI::AbilityStackText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeKeyText) == 0x000418, "Member 'UCrabGameplayUI::MeleeKeyText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeControllerIcon) == 0x000420, "Member 'UCrabGameplayUI::MeleeControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeIcon) == 0x000428, "Member 'UCrabGameplayUI::MeleeIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeCooldownText) == 0x000430, "Member 'UCrabGameplayUI::MeleeCooldownText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnMeleeCooldownExpiredAnim) == 0x000438, "Member 'UCrabGameplayUI::OnMeleeCooldownExpiredAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryKeyText) == 0x000440, "Member 'UCrabGameplayUI::InventoryKeyText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryControllerIcon) == 0x000448, "Member 'UCrabGameplayUI::InventoryControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupBorder) == 0x000450, "Member 'UCrabGameplayUI::NewPickupBorder' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupNameText) == 0x000458, "Member 'UCrabGameplayUI::NewPickupNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupIcon) == 0x000460, "Member 'UCrabGameplayUI::NewPickupIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupDescriptionText) == 0x000468, "Member 'UCrabGameplayUI::NewPickupDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupTypeText) == 0x000470, "Member 'UCrabGameplayUI::NewPickupTypeText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupLevelText) == 0x000478, "Member 'UCrabGameplayUI::NewPickupLevelText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupAnim) == 0x000480, "Member 'UCrabGameplayUI::NewPickupAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryEventVerticalBox) == 0x000488, "Member 'UCrabGameplayUI::InventoryEventVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryEventUIToSpawn) == 0x000490, "Member 'UCrabGameplayUI::InventoryEventUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ChallengeModifierSizeBox) == 0x000498, "Member 'UCrabGameplayUI::ChallengeModifierSizeBox' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ChallengeModifierTitleText) == 0x0004A0, "Member 'UCrabGameplayUI::ChallengeModifierTitleText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ChallengeModifierText) == 0x0004A8, "Member 'UCrabGameplayUI::ChallengeModifierText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ChallengeModifierDescriptionText) == 0x0004B0, "Member 'UCrabGameplayUI::ChallengeModifierDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, BlessingGoalText) == 0x0004B8, "Member 'UCrabGameplayUI::BlessingGoalText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AdditionalChallengeModifierBorder) == 0x0004C0, "Member 'UCrabGameplayUI::AdditionalChallengeModifierBorder' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AdditionalChallengeModifierText) == 0x0004C8, "Member 'UCrabGameplayUI::AdditionalChallengeModifierText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AdditionalChallengeModifierDescriptionText) == 0x0004D0, "Member 'UCrabGameplayUI::AdditionalChallengeModifierDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnStartedChallengeAnim) == 0x0004D8, "Member 'UCrabGameplayUI::OnStartedChallengeAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnCompletedChallengeAnim) == 0x0004E0, "Member 'UCrabGameplayUI::OnCompletedChallengeAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, FlawlessIslandClearAnim) == 0x0004E8, "Member 'UCrabGameplayUI::FlawlessIslandClearAnim' has a wrong offset!");

// Class CrabChampions.CrabGameStateUI
// 0x0150 (0x0408 - 0x02B8)
class UCrabGameStateUI : public UCrabUI
{
public:
	class UVerticalBox*                           PlayerStateUIVerticalBox;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabPlayerStateUI>         PlayerStateUIToSpawn;                              // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentTimeText;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           CountdownVerticalBox;                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CountdownMessageText;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CountdownTime;                                     // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CountdownAnim;                                     // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         IslandProgressionHorizontalBox;                    // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             RandomIslandsIcon;                                 // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentIslandText;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyText;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GameplayMessageText;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       GameplayMessageAnim;                               // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ChatVerticalBox;                                   // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ChatEntriesVerticalBox;                            // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabChatEntryRowUI>        ChatEntryRowUIToSpawn;                             // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCrabChatEntryRowUI*>            ChatEntryRows;                                     // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       ChatInputEditableTextBox;                          // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ReceivedChatSound;                                 // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             BiomeText;                                         // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandTypeText;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandDescriptionText;                             // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       IslandIntroductionAnim;                            // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              CountdownSound;                                    // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ObjectiveVerticalBox;                              // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectiveGoalText;                                 // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedObjectiveGoalAnim;                        // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectiveText;                                     // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           IslandRewardVerticalBox;                           // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandRewardText;                                  // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedIslandRewardRarityAnim;                   // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SpectatingVerticalBox;                             // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SpectatingPlayerNameText;                          // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         MinigameHorizontalBox;                             // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameScoreTitleText;                            // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameScoreText;                                 // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedMinigameScoreAnim;                        // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameHighScoreTitleText;                        // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameHighScoreText;                             // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChatTextCommitted(const class FText& Text, ETextCommit CommitMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameStateUI">();
	}
	static class UCrabGameStateUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameStateUI>();
	}
};
static_assert(alignof(UCrabGameStateUI) == 0x000008, "Wrong alignment on UCrabGameStateUI");
static_assert(sizeof(UCrabGameStateUI) == 0x000408, "Wrong size on UCrabGameStateUI");
static_assert(offsetof(UCrabGameStateUI, PlayerStateUIVerticalBox) == 0x0002B8, "Member 'UCrabGameStateUI::PlayerStateUIVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, PlayerStateUIToSpawn) == 0x0002C0, "Member 'UCrabGameStateUI::PlayerStateUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CurrentTimeText) == 0x0002C8, "Member 'UCrabGameStateUI::CurrentTimeText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownVerticalBox) == 0x0002D8, "Member 'UCrabGameStateUI::CountdownVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownMessageText) == 0x0002E0, "Member 'UCrabGameStateUI::CountdownMessageText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownTime) == 0x0002E8, "Member 'UCrabGameStateUI::CountdownTime' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownAnim) == 0x0002F0, "Member 'UCrabGameStateUI::CountdownAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandProgressionHorizontalBox) == 0x0002F8, "Member 'UCrabGameStateUI::IslandProgressionHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, RandomIslandsIcon) == 0x000300, "Member 'UCrabGameStateUI::RandomIslandsIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CurrentIslandText) == 0x000308, "Member 'UCrabGameStateUI::CurrentIslandText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, DifficultyText) == 0x000310, "Member 'UCrabGameStateUI::DifficultyText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, GameplayMessageText) == 0x000318, "Member 'UCrabGameStateUI::GameplayMessageText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, GameplayMessageAnim) == 0x000320, "Member 'UCrabGameStateUI::GameplayMessageAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatVerticalBox) == 0x000328, "Member 'UCrabGameStateUI::ChatVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatEntriesVerticalBox) == 0x000330, "Member 'UCrabGameStateUI::ChatEntriesVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatEntryRowUIToSpawn) == 0x000338, "Member 'UCrabGameStateUI::ChatEntryRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatEntryRows) == 0x000340, "Member 'UCrabGameStateUI::ChatEntryRows' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatInputEditableTextBox) == 0x000350, "Member 'UCrabGameStateUI::ChatInputEditableTextBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ReceivedChatSound) == 0x000358, "Member 'UCrabGameStateUI::ReceivedChatSound' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, BiomeText) == 0x000368, "Member 'UCrabGameStateUI::BiomeText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandTypeText) == 0x000370, "Member 'UCrabGameStateUI::IslandTypeText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandDescriptionText) == 0x000378, "Member 'UCrabGameStateUI::IslandDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandIntroductionAnim) == 0x000380, "Member 'UCrabGameStateUI::IslandIntroductionAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownSound) == 0x000388, "Member 'UCrabGameStateUI::CountdownSound' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ObjectiveVerticalBox) == 0x000390, "Member 'UCrabGameStateUI::ObjectiveVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ObjectiveGoalText) == 0x000398, "Member 'UCrabGameStateUI::ObjectiveGoalText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnUpdatedObjectiveGoalAnim) == 0x0003A0, "Member 'UCrabGameStateUI::OnUpdatedObjectiveGoalAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ObjectiveText) == 0x0003A8, "Member 'UCrabGameStateUI::ObjectiveText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandRewardVerticalBox) == 0x0003B0, "Member 'UCrabGameStateUI::IslandRewardVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandRewardText) == 0x0003B8, "Member 'UCrabGameStateUI::IslandRewardText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnUpdatedIslandRewardRarityAnim) == 0x0003C0, "Member 'UCrabGameStateUI::OnUpdatedIslandRewardRarityAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, SpectatingVerticalBox) == 0x0003C8, "Member 'UCrabGameStateUI::SpectatingVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, SpectatingPlayerNameText) == 0x0003D0, "Member 'UCrabGameStateUI::SpectatingPlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameHorizontalBox) == 0x0003D8, "Member 'UCrabGameStateUI::MinigameHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameScoreTitleText) == 0x0003E0, "Member 'UCrabGameStateUI::MinigameScoreTitleText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameScoreText) == 0x0003E8, "Member 'UCrabGameStateUI::MinigameScoreText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnUpdatedMinigameScoreAnim) == 0x0003F0, "Member 'UCrabGameStateUI::OnUpdatedMinigameScoreAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameHighScoreTitleText) == 0x0003F8, "Member 'UCrabGameStateUI::MinigameHighScoreTitleText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameHighScoreText) == 0x000400, "Member 'UCrabGameStateUI::MinigameHighScoreText' has a wrong offset!");

// Class CrabChampions.CrabGI
// 0x0618 (0x07C0 - 0x01A8)
class UCrabGI : public UGameInstance
{
public:
	TSubclassOf<class UUserWidget>                LoadingScreenUIToSpawn;                            // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            LoadingScreenUI;                                   // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x30];                                     // 0x01B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabSG*                                SG;                                                // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabSettingsSG*                        SettingsSG;                                        // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x4];                                      // 0x0208(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CrabChampionsVersion;                              // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabKeyBind>                   CrabKeyBinds;                                      // 0x0210(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackButton;                                        // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BumperL;                                           // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BumperR;                                           // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonD;                                           // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonL;                                           // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonR;                                           // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonU;                                           // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadD;                                             // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadL;                                             // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadR;                                             // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadU;                                             // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StartButton;                                       // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickL;                                            // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickLHorizontal;                                  // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickLVertical;                                    // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickR;                                            // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickRHorizontal;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickRVertical;                                    // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TriggerL;                                          // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TriggerR;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            MasterSoundClass;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              MasterSoundMix;                                    // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            GameplaySoundClass;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              GameplaySoundMix;                                  // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            MusicSoundClass;                                   // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              MusicSoundMix;                                     // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCosmeticsDA*                       CosmeticsDA;                                       // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabChallenge>                 Challenges;                                        // 0x02F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugUnlockAllContent;                            // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabAutoSave                          DebugAutoSave;                                     // 0x0310(0x0148)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x368];                                    // 0x0458(0x0368)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStreamLevelLoaded();
	void OnStreamLevelUnloaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGI">();
	}
	static class UCrabGI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGI>();
	}
};
static_assert(alignof(UCrabGI) == 0x000008, "Wrong alignment on UCrabGI");
static_assert(sizeof(UCrabGI) == 0x0007C0, "Wrong size on UCrabGI");
static_assert(offsetof(UCrabGI, LoadingScreenUIToSpawn) == 0x0001A8, "Member 'UCrabGI::LoadingScreenUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGI, LoadingScreenUI) == 0x0001B0, "Member 'UCrabGI::LoadingScreenUI' has a wrong offset!");
static_assert(offsetof(UCrabGI, SG) == 0x0001E8, "Member 'UCrabGI::SG' has a wrong offset!");
static_assert(offsetof(UCrabGI, SettingsSG) == 0x000200, "Member 'UCrabGI::SettingsSG' has a wrong offset!");
static_assert(offsetof(UCrabGI, CrabChampionsVersion) == 0x00020C, "Member 'UCrabGI::CrabChampionsVersion' has a wrong offset!");
static_assert(offsetof(UCrabGI, CrabKeyBinds) == 0x000210, "Member 'UCrabGI::CrabKeyBinds' has a wrong offset!");
static_assert(offsetof(UCrabGI, BackButton) == 0x000220, "Member 'UCrabGI::BackButton' has a wrong offset!");
static_assert(offsetof(UCrabGI, BumperL) == 0x000228, "Member 'UCrabGI::BumperL' has a wrong offset!");
static_assert(offsetof(UCrabGI, BumperR) == 0x000230, "Member 'UCrabGI::BumperR' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonD) == 0x000238, "Member 'UCrabGI::ButtonD' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonL) == 0x000240, "Member 'UCrabGI::ButtonL' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonR) == 0x000248, "Member 'UCrabGI::ButtonR' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonU) == 0x000250, "Member 'UCrabGI::ButtonU' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadD) == 0x000258, "Member 'UCrabGI::DPadD' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadL) == 0x000260, "Member 'UCrabGI::DPadL' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadR) == 0x000268, "Member 'UCrabGI::DPadR' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadU) == 0x000270, "Member 'UCrabGI::DPadU' has a wrong offset!");
static_assert(offsetof(UCrabGI, StartButton) == 0x000278, "Member 'UCrabGI::StartButton' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickL) == 0x000280, "Member 'UCrabGI::StickL' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickLHorizontal) == 0x000288, "Member 'UCrabGI::StickLHorizontal' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickLVertical) == 0x000290, "Member 'UCrabGI::StickLVertical' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickR) == 0x000298, "Member 'UCrabGI::StickR' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickRHorizontal) == 0x0002A0, "Member 'UCrabGI::StickRHorizontal' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickRVertical) == 0x0002A8, "Member 'UCrabGI::StickRVertical' has a wrong offset!");
static_assert(offsetof(UCrabGI, TriggerL) == 0x0002B0, "Member 'UCrabGI::TriggerL' has a wrong offset!");
static_assert(offsetof(UCrabGI, TriggerR) == 0x0002B8, "Member 'UCrabGI::TriggerR' has a wrong offset!");
static_assert(offsetof(UCrabGI, MasterSoundClass) == 0x0002C0, "Member 'UCrabGI::MasterSoundClass' has a wrong offset!");
static_assert(offsetof(UCrabGI, MasterSoundMix) == 0x0002C8, "Member 'UCrabGI::MasterSoundMix' has a wrong offset!");
static_assert(offsetof(UCrabGI, GameplaySoundClass) == 0x0002D0, "Member 'UCrabGI::GameplaySoundClass' has a wrong offset!");
static_assert(offsetof(UCrabGI, GameplaySoundMix) == 0x0002D8, "Member 'UCrabGI::GameplaySoundMix' has a wrong offset!");
static_assert(offsetof(UCrabGI, MusicSoundClass) == 0x0002E0, "Member 'UCrabGI::MusicSoundClass' has a wrong offset!");
static_assert(offsetof(UCrabGI, MusicSoundMix) == 0x0002E8, "Member 'UCrabGI::MusicSoundMix' has a wrong offset!");
static_assert(offsetof(UCrabGI, CosmeticsDA) == 0x0002F0, "Member 'UCrabGI::CosmeticsDA' has a wrong offset!");
static_assert(offsetof(UCrabGI, Challenges) == 0x0002F8, "Member 'UCrabGI::Challenges' has a wrong offset!");
static_assert(offsetof(UCrabGI, bDebugUnlockAllContent) == 0x000308, "Member 'UCrabGI::bDebugUnlockAllContent' has a wrong offset!");
static_assert(offsetof(UCrabGI, DebugAutoSave) == 0x000310, "Member 'UCrabGI::DebugAutoSave' has a wrong offset!");

// Class CrabChampions.CrabInteractUI
// 0x00A8 (0x0360 - 0x02B8)
class UCrabInteractUI : public UCrabUI
{
public:
	class UImage*                                 IconImage;                                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TypeText;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameText;                                          // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DescriptionText;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RarityBorder;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LootPoolText;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InteractKeyText;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 InteractControllerIcon;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InteractMessageText;                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         CostHorizontalBox;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrystalIconImage;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KeyIconImage;                                      // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HealthIconImage;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MaxHealthIconImage;                                // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CostText;                                          // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SalvageHorizontalBox;                              // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SalvageKeyText;                                    // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SalvageControllerIcon;                             // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SalvageRewardText;                                 // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           SalvageProgressBar;                                // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       SalvageAnim;                                       // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInteractUI">();
	}
	static class UCrabInteractUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInteractUI>();
	}
};
static_assert(alignof(UCrabInteractUI) == 0x000008, "Wrong alignment on UCrabInteractUI");
static_assert(sizeof(UCrabInteractUI) == 0x000360, "Wrong size on UCrabInteractUI");
static_assert(offsetof(UCrabInteractUI, IconImage) == 0x0002B8, "Member 'UCrabInteractUI::IconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, TypeText) == 0x0002C0, "Member 'UCrabInteractUI::TypeText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, NameText) == 0x0002C8, "Member 'UCrabInteractUI::NameText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, DescriptionText) == 0x0002D0, "Member 'UCrabInteractUI::DescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, RarityBorder) == 0x0002D8, "Member 'UCrabInteractUI::RarityBorder' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, LootPoolText) == 0x0002E0, "Member 'UCrabInteractUI::LootPoolText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, InteractKeyText) == 0x0002E8, "Member 'UCrabInteractUI::InteractKeyText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, InteractControllerIcon) == 0x0002F0, "Member 'UCrabInteractUI::InteractControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, InteractMessageText) == 0x0002F8, "Member 'UCrabInteractUI::InteractMessageText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, CostHorizontalBox) == 0x000300, "Member 'UCrabInteractUI::CostHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, CrystalIconImage) == 0x000308, "Member 'UCrabInteractUI::CrystalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, KeyIconImage) == 0x000310, "Member 'UCrabInteractUI::KeyIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, HealthIconImage) == 0x000318, "Member 'UCrabInteractUI::HealthIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, MaxHealthIconImage) == 0x000320, "Member 'UCrabInteractUI::MaxHealthIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, CostText) == 0x000328, "Member 'UCrabInteractUI::CostText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageHorizontalBox) == 0x000330, "Member 'UCrabInteractUI::SalvageHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageKeyText) == 0x000338, "Member 'UCrabInteractUI::SalvageKeyText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageControllerIcon) == 0x000340, "Member 'UCrabInteractUI::SalvageControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageRewardText) == 0x000348, "Member 'UCrabInteractUI::SalvageRewardText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageProgressBar) == 0x000350, "Member 'UCrabInteractUI::SalvageProgressBar' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageAnim) == 0x000358, "Member 'UCrabInteractUI::SalvageAnim' has a wrong offset!");

// Class CrabChampions.CrabJoinedPlayerRowUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabJoinedPlayerRowUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerPingText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabJoinedPlayerRowUI">();
	}
	static class UCrabJoinedPlayerRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabJoinedPlayerRowUI>();
	}
};
static_assert(alignof(UCrabJoinedPlayerRowUI) == 0x000008, "Wrong alignment on UCrabJoinedPlayerRowUI");
static_assert(sizeof(UCrabJoinedPlayerRowUI) == 0x0002C8, "Wrong size on UCrabJoinedPlayerRowUI");
static_assert(offsetof(UCrabJoinedPlayerRowUI, PlayerNameText) == 0x0002B8, "Member 'UCrabJoinedPlayerRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabJoinedPlayerRowUI, PlayerPingText) == 0x0002C0, "Member 'UCrabJoinedPlayerRowUI::PlayerPingText' has a wrong offset!");

// Class CrabChampions.CrabKeyBindRowUI
// 0x00A8 (0x0360 - 0x02B8)
class UCrabKeyBindRowUI : public UCrabUI
{
public:
	class UButton*                                KeyboardButton;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ControllerButton;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabKeyBind                           CurrentKeyBind;                                    // 0x02C8(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             KeyBindTitleText;                                  // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputKeySelector*                      KeyboardKeySelector;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputKeySelector*                      ControllerKeySelector;                             // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ControllerIcon;                                    // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ControllerIconMat;                                 // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredControllerButton();
	void OnHoveredKeyboardButton();
	void OnPressedControllerKeySelector(const struct FInputChord& SelectedKey);
	void OnPressedKeyboardKeySelector(const struct FInputChord& SelectedKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabKeyBindRowUI">();
	}
	static class UCrabKeyBindRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabKeyBindRowUI>();
	}
};
static_assert(alignof(UCrabKeyBindRowUI) == 0x000008, "Wrong alignment on UCrabKeyBindRowUI");
static_assert(sizeof(UCrabKeyBindRowUI) == 0x000360, "Wrong size on UCrabKeyBindRowUI");
static_assert(offsetof(UCrabKeyBindRowUI, KeyboardButton) == 0x0002B8, "Member 'UCrabKeyBindRowUI::KeyboardButton' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerButton) == 0x0002C0, "Member 'UCrabKeyBindRowUI::ControllerButton' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, CurrentKeyBind) == 0x0002C8, "Member 'UCrabKeyBindRowUI::CurrentKeyBind' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, KeyBindTitleText) == 0x000338, "Member 'UCrabKeyBindRowUI::KeyBindTitleText' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, KeyboardKeySelector) == 0x000340, "Member 'UCrabKeyBindRowUI::KeyboardKeySelector' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerKeySelector) == 0x000348, "Member 'UCrabKeyBindRowUI::ControllerKeySelector' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerIcon) == 0x000350, "Member 'UCrabKeyBindRowUI::ControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerIconMat) == 0x000358, "Member 'UCrabKeyBindRowUI::ControllerIconMat' has a wrong offset!");

// Class CrabChampions.CrabLaunchActionDA
// 0x0018 (0x0080 - 0x0068)
class UCrabLaunchActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreLaunchHeight;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchSpeed;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabAOEDA*                             LandAOEDA;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabLaunchActionDA">();
	}
	static class UCrabLaunchActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabLaunchActionDA>();
	}
};
static_assert(alignof(UCrabLaunchActionDA) == 0x000008, "Wrong alignment on UCrabLaunchActionDA");
static_assert(sizeof(UCrabLaunchActionDA) == 0x000080, "Wrong size on UCrabLaunchActionDA");
static_assert(offsetof(UCrabLaunchActionDA, TargetType) == 0x000068, "Member 'UCrabLaunchActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabLaunchActionDA, PreLaunchHeight) == 0x00006C, "Member 'UCrabLaunchActionDA::PreLaunchHeight' has a wrong offset!");
static_assert(offsetof(UCrabLaunchActionDA, LaunchSpeed) == 0x000070, "Member 'UCrabLaunchActionDA::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(UCrabLaunchActionDA, LandAOEDA) == 0x000078, "Member 'UCrabLaunchActionDA::LandAOEDA' has a wrong offset!");

// Class CrabChampions.CrabLaunchPad
// 0x0048 (0x0268 - 0x0220)
class ACrabLaunchPad final : public AActor
{
public:
	class UNiagaraComponent*                      LaunchPadNC;                                       // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LaunchPadAC;                                       // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchCollisionRadius;                             // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LaunchSpeed;                                       // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideXYVelocity;                               // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         LaunchFX;                                          // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LaunchSound;                                       // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabLaunchPad">();
	}
	static class ACrabLaunchPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabLaunchPad>();
	}
};
static_assert(alignof(ACrabLaunchPad) == 0x000008, "Wrong alignment on ACrabLaunchPad");
static_assert(sizeof(ACrabLaunchPad) == 0x000268, "Wrong size on ACrabLaunchPad");
static_assert(offsetof(ACrabLaunchPad, LaunchPadNC) == 0x000220, "Member 'ACrabLaunchPad::LaunchPadNC' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchPadAC) == 0x000228, "Member 'ACrabLaunchPad::LaunchPadAC' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, FX) == 0x000230, "Member 'ACrabLaunchPad::FX' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, Sound) == 0x000238, "Member 'ACrabLaunchPad::Sound' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchCollisionRadius) == 0x000248, "Member 'ACrabLaunchPad::LaunchCollisionRadius' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchSpeed) == 0x00024C, "Member 'ACrabLaunchPad::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, bOverrideXYVelocity) == 0x000250, "Member 'ACrabLaunchPad::bOverrideXYVelocity' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchFX) == 0x000258, "Member 'ACrabLaunchPad::LaunchFX' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchSound) == 0x000260, "Member 'ACrabLaunchPad::LaunchSound' has a wrong offset!");

// Class CrabChampions.CrabLM
// 0x0328 (0x0548 - 0x0220)
class ACrabLM : public AActor
{
public:
	class USceneComponent*                        LMRoot;                                            // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Skydome;                                           // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionalLightComponent*             DL;                                                // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkyLightComponent*                     SL;                                                // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PP;                                                // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExponentialHeightFogComponent*         HF;                                                // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Ocean;                                             // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          UnderwaterBounds;                                  // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  UnderwaterPP;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   IslandBounds;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AmbienceAC;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        MusicAC;                                           // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            SkydomeMesh;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            OceanMesh;                                         // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            IslandBoundsMesh;                                  // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BananaPPDistortionMat;                             // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     UnderwaterPPDistortionMat;                         // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           GlobalMPC;                                         // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollectionInstance*   GlobalMPCInstance;                                 // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRandomLightingPreset;                          // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LightingPresetIndex;                               // 0x02BC(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabLightingPreset>            LightingPresets;                                   // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCrabLightingPreset                    CurrentLightingPreset;                             // 0x02D0(0x00A0)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                GlobalSaturation;                                  // 0x0370(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlobalContrast;                                    // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumProjectilesToPool;                              // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabProjectile*>                PooledProjectiles;                                 // 0x0388(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCrabSpawnablesDA*                      SpawnablesDA;                                      // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           LocalC;                                            // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACrabC*>                         CharactersAffectingRippleSim;                      // 0x03A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         RippleSimUpdateRate;                               // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RippleViewDistance;                                // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RippleRTResolution;                                // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RippleHeightSimRTA;                                // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RippleHeightSimRTB;                                // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RippleHeightSimRTC;                                // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RippleNormalRT;                                    // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RippleDrawMat;                                     // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RippleDrawDMI;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RippleHeightSimMat;                                // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RippleHeightSimDMI;                                // 0x0400(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RippleNormalSimMat;                                // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RippleNormalSimDMI;                                // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RippleRadius;                                      // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RippleIntensity;                                   // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCrabPickupDA*>                  AllUnlockedPickups;                                // 0x0428(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x90];                                     // 0x0438(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        EnemyTypesToSpawn;                                 // 0x04C8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACrabEnemyC>>        EnemiesToSpawn;                                    // 0x04D8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ACrabSpawnPoint*>                EnemySpawnPoints;                                  // 0x04E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x50];                                     // 0x04F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastPlayOneShotFX(class UNiagaraSystem* FXToPlay, class USoundCue* SoundToPlay, const struct FVector& SpawnLoc);
	void MulticastSpawnCosmeticProjectile(const struct FCrabProjectileInfo& ProjectileInfo, class AActor* ProjectileOwner, const struct FVector_NetQuantize& StartLoc);
	void OnRep_LightingPresetIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabLM">();
	}
	static class ACrabLM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabLM>();
	}
};
static_assert(alignof(ACrabLM) == 0x000008, "Wrong alignment on ACrabLM");
static_assert(sizeof(ACrabLM) == 0x000548, "Wrong size on ACrabLM");
static_assert(offsetof(ACrabLM, LMRoot) == 0x000220, "Member 'ACrabLM::LMRoot' has a wrong offset!");
static_assert(offsetof(ACrabLM, Skydome) == 0x000228, "Member 'ACrabLM::Skydome' has a wrong offset!");
static_assert(offsetof(ACrabLM, DL) == 0x000230, "Member 'ACrabLM::DL' has a wrong offset!");
static_assert(offsetof(ACrabLM, SL) == 0x000238, "Member 'ACrabLM::SL' has a wrong offset!");
static_assert(offsetof(ACrabLM, PP) == 0x000240, "Member 'ACrabLM::PP' has a wrong offset!");
static_assert(offsetof(ACrabLM, HF) == 0x000248, "Member 'ACrabLM::HF' has a wrong offset!");
static_assert(offsetof(ACrabLM, Ocean) == 0x000250, "Member 'ACrabLM::Ocean' has a wrong offset!");
static_assert(offsetof(ACrabLM, UnderwaterBounds) == 0x000258, "Member 'ACrabLM::UnderwaterBounds' has a wrong offset!");
static_assert(offsetof(ACrabLM, UnderwaterPP) == 0x000260, "Member 'ACrabLM::UnderwaterPP' has a wrong offset!");
static_assert(offsetof(ACrabLM, IslandBounds) == 0x000268, "Member 'ACrabLM::IslandBounds' has a wrong offset!");
static_assert(offsetof(ACrabLM, AmbienceAC) == 0x000270, "Member 'ACrabLM::AmbienceAC' has a wrong offset!");
static_assert(offsetof(ACrabLM, MusicAC) == 0x000278, "Member 'ACrabLM::MusicAC' has a wrong offset!");
static_assert(offsetof(ACrabLM, SkydomeMesh) == 0x000280, "Member 'ACrabLM::SkydomeMesh' has a wrong offset!");
static_assert(offsetof(ACrabLM, OceanMesh) == 0x000288, "Member 'ACrabLM::OceanMesh' has a wrong offset!");
static_assert(offsetof(ACrabLM, IslandBoundsMesh) == 0x000290, "Member 'ACrabLM::IslandBoundsMesh' has a wrong offset!");
static_assert(offsetof(ACrabLM, BananaPPDistortionMat) == 0x000298, "Member 'ACrabLM::BananaPPDistortionMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, UnderwaterPPDistortionMat) == 0x0002A0, "Member 'ACrabLM::UnderwaterPPDistortionMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalMPC) == 0x0002A8, "Member 'ACrabLM::GlobalMPC' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalMPCInstance) == 0x0002B0, "Member 'ACrabLM::GlobalMPCInstance' has a wrong offset!");
static_assert(offsetof(ACrabLM, bUseRandomLightingPreset) == 0x0002B8, "Member 'ACrabLM::bUseRandomLightingPreset' has a wrong offset!");
static_assert(offsetof(ACrabLM, LightingPresetIndex) == 0x0002BC, "Member 'ACrabLM::LightingPresetIndex' has a wrong offset!");
static_assert(offsetof(ACrabLM, LightingPresets) == 0x0002C0, "Member 'ACrabLM::LightingPresets' has a wrong offset!");
static_assert(offsetof(ACrabLM, CurrentLightingPreset) == 0x0002D0, "Member 'ACrabLM::CurrentLightingPreset' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalSaturation) == 0x000370, "Member 'ACrabLM::GlobalSaturation' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalContrast) == 0x00037C, "Member 'ACrabLM::GlobalContrast' has a wrong offset!");
static_assert(offsetof(ACrabLM, NumProjectilesToPool) == 0x000380, "Member 'ACrabLM::NumProjectilesToPool' has a wrong offset!");
static_assert(offsetof(ACrabLM, PooledProjectiles) == 0x000388, "Member 'ACrabLM::PooledProjectiles' has a wrong offset!");
static_assert(offsetof(ACrabLM, SpawnablesDA) == 0x000398, "Member 'ACrabLM::SpawnablesDA' has a wrong offset!");
static_assert(offsetof(ACrabLM, LocalC) == 0x0003A0, "Member 'ACrabLM::LocalC' has a wrong offset!");
static_assert(offsetof(ACrabLM, CharactersAffectingRippleSim) == 0x0003A8, "Member 'ACrabLM::CharactersAffectingRippleSim' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleSimUpdateRate) == 0x0003B8, "Member 'ACrabLM::RippleSimUpdateRate' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleViewDistance) == 0x0003BC, "Member 'ACrabLM::RippleViewDistance' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleRTResolution) == 0x0003C0, "Member 'ACrabLM::RippleRTResolution' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimRTA) == 0x0003C8, "Member 'ACrabLM::RippleHeightSimRTA' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimRTB) == 0x0003D0, "Member 'ACrabLM::RippleHeightSimRTB' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimRTC) == 0x0003D8, "Member 'ACrabLM::RippleHeightSimRTC' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleNormalRT) == 0x0003E0, "Member 'ACrabLM::RippleNormalRT' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleDrawMat) == 0x0003E8, "Member 'ACrabLM::RippleDrawMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleDrawDMI) == 0x0003F0, "Member 'ACrabLM::RippleDrawDMI' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimMat) == 0x0003F8, "Member 'ACrabLM::RippleHeightSimMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimDMI) == 0x000400, "Member 'ACrabLM::RippleHeightSimDMI' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleNormalSimMat) == 0x000408, "Member 'ACrabLM::RippleNormalSimMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleNormalSimDMI) == 0x000410, "Member 'ACrabLM::RippleNormalSimDMI' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleRadius) == 0x000418, "Member 'ACrabLM::RippleRadius' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleIntensity) == 0x00041C, "Member 'ACrabLM::RippleIntensity' has a wrong offset!");
static_assert(offsetof(ACrabLM, AllUnlockedPickups) == 0x000428, "Member 'ACrabLM::AllUnlockedPickups' has a wrong offset!");
static_assert(offsetof(ACrabLM, EnemyTypesToSpawn) == 0x0004C8, "Member 'ACrabLM::EnemyTypesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabLM, EnemiesToSpawn) == 0x0004D8, "Member 'ACrabLM::EnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabLM, EnemySpawnPoints) == 0x0004E8, "Member 'ACrabLM::EnemySpawnPoints' has a wrong offset!");

// Class CrabChampions.CrabMeleeDA
// 0x0078 (0x0128 - 0x00B0)
class UCrabMeleeDA final : public UCrabPickupDA
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabHitmarkerType                            HitmarkerType;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeModDebuffMultiplier;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FX;                                                // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchSpeed;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchHeight;                                      // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlamDelay;                                         // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlamSpeed;                                         // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SlamMontage;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlamSelfKnockbackStrength;                         // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackStrength;                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            ExplosionDamageAreaToSpawn;                        // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabStrikeActionDA*                    ExplosionLineStrikeAction;                         // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLineStrikeDistance;                       // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMeleeDA">();
	}
	static class UCrabMeleeDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMeleeDA>();
	}
};
static_assert(alignof(UCrabMeleeDA) == 0x000008, "Wrong alignment on UCrabMeleeDA");
static_assert(sizeof(UCrabMeleeDA) == 0x000128, "Wrong size on UCrabMeleeDA");
static_assert(offsetof(UCrabMeleeDA, Mesh) == 0x0000B0, "Member 'UCrabMeleeDA::Mesh' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, HitmarkerType) == 0x0000B8, "Member 'UCrabMeleeDA::HitmarkerType' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Cooldown) == 0x0000BC, "Member 'UCrabMeleeDA::Cooldown' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, MeleeModDebuffMultiplier) == 0x0000C0, "Member 'UCrabMeleeDA::MeleeModDebuffMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Montage) == 0x0000C8, "Member 'UCrabMeleeDA::Montage' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, FX) == 0x0000D0, "Member 'UCrabMeleeDA::FX' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, LaunchSpeed) == 0x0000D8, "Member 'UCrabMeleeDA::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, LaunchHeight) == 0x0000DC, "Member 'UCrabMeleeDA::LaunchHeight' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, SlamDelay) == 0x0000E0, "Member 'UCrabMeleeDA::SlamDelay' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, SlamSpeed) == 0x0000E4, "Member 'UCrabMeleeDA::SlamSpeed' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, SlamMontage) == 0x0000E8, "Member 'UCrabMeleeDA::SlamMontage' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, SlamSelfKnockbackStrength) == 0x0000F0, "Member 'UCrabMeleeDA::SlamSelfKnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Range) == 0x0000F4, "Member 'UCrabMeleeDA::Range' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Damage) == 0x0000F8, "Member 'UCrabMeleeDA::Damage' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, KnockbackStrength) == 0x0000FC, "Member 'UCrabMeleeDA::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, ExplosionDamageAreaToSpawn) == 0x000100, "Member 'UCrabMeleeDA::ExplosionDamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, ExplosionLineStrikeAction) == 0x000108, "Member 'UCrabMeleeDA::ExplosionLineStrikeAction' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, ExplosionLineStrikeDistance) == 0x000110, "Member 'UCrabMeleeDA::ExplosionLineStrikeDistance' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, ExplosionFX) == 0x000118, "Member 'UCrabMeleeDA::ExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, ExplosionCameraShake) == 0x000120, "Member 'UCrabMeleeDA::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabMeleeModDA
// 0x0008 (0x00E0 - 0x00D8)
class UCrabMeleeModDA final : public UCrabInventoryDA
{
public:
	ECrabMeleeModType                             MeleeModType;                                      // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMeleeModDA">();
	}
	static class UCrabMeleeModDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMeleeModDA>();
	}
};
static_assert(alignof(UCrabMeleeModDA) == 0x000008, "Wrong alignment on UCrabMeleeModDA");
static_assert(sizeof(UCrabMeleeModDA) == 0x0000E0, "Wrong size on UCrabMeleeModDA");
static_assert(offsetof(UCrabMeleeModDA, MeleeModType) == 0x0000D8, "Member 'UCrabMeleeModDA::MeleeModType' has a wrong offset!");

// Class CrabChampions.CrabMinigameGameOverRowUI
// 0x0020 (0x02D8 - 0x02B8)
class UCrabMinigameGameOverRowUI : public UCrabUI
{
public:
	class UTextBlock*                             PlacementText;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MVPCrownImage;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EliminationsText;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMinigameGameOverRowUI">();
	}
	static class UCrabMinigameGameOverRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMinigameGameOverRowUI>();
	}
};
static_assert(alignof(UCrabMinigameGameOverRowUI) == 0x000008, "Wrong alignment on UCrabMinigameGameOverRowUI");
static_assert(sizeof(UCrabMinigameGameOverRowUI) == 0x0002D8, "Wrong size on UCrabMinigameGameOverRowUI");
static_assert(offsetof(UCrabMinigameGameOverRowUI, PlacementText) == 0x0002B8, "Member 'UCrabMinigameGameOverRowUI::PlacementText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverRowUI, MVPCrownImage) == 0x0002C0, "Member 'UCrabMinigameGameOverRowUI::MVPCrownImage' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverRowUI, PlayerNameText) == 0x0002C8, "Member 'UCrabMinigameGameOverRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverRowUI, EliminationsText) == 0x0002D0, "Member 'UCrabMinigameGameOverRowUI::EliminationsText' has a wrong offset!");

// Class CrabChampions.CrabMinigameGameOverUI
// 0x0030 (0x0400 - 0x03D0)
class UCrabMinigameGameOverUI : public UCrabFocusMenuUI
{
public:
	class UTextBlock*                             MinigameNameText;                                  // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        MinigameGameOverWidgetSwitcher;                    // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ScoreText;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighScoreText;                                     // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           MinigameGameOverRowUIVerticalBox;                  // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabMinigameGameOverRowUI> MinigameGameOverRowUIToSpawn;                      // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMinigameGameOverUI">();
	}
	static class UCrabMinigameGameOverUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMinigameGameOverUI>();
	}
};
static_assert(alignof(UCrabMinigameGameOverUI) == 0x000008, "Wrong alignment on UCrabMinigameGameOverUI");
static_assert(sizeof(UCrabMinigameGameOverUI) == 0x000400, "Wrong size on UCrabMinigameGameOverUI");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameNameText) == 0x0003D0, "Member 'UCrabMinigameGameOverUI::MinigameNameText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameGameOverWidgetSwitcher) == 0x0003D8, "Member 'UCrabMinigameGameOverUI::MinigameGameOverWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, ScoreText) == 0x0003E0, "Member 'UCrabMinigameGameOverUI::ScoreText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, HighScoreText) == 0x0003E8, "Member 'UCrabMinigameGameOverUI::HighScoreText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameGameOverRowUIVerticalBox) == 0x0003F0, "Member 'UCrabMinigameGameOverUI::MinigameGameOverRowUIVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameGameOverRowUIToSpawn) == 0x0003F8, "Member 'UCrabMinigameGameOverUI::MinigameGameOverRowUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabMultiplayerMenuUI
// 0x0038 (0x0408 - 0x03D0)
class UCrabMultiplayerMenuUI : public UCrabFocusMenuUI
{
public:
	class UCrabArrowSelectionUI*                  QuickplayDifficultyAS;                             // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuickplayButton;                                   // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             QuickplayButtonText;                               // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             FriendsScrollBox;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInviteFriendRowUI>     InviteFriendRowUIToSpawn;                          // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           JoinedPlayersVerticalBox;                          // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabJoinedPlayerRowUI>     JoinedPlayerRowUIToSpawn;                          // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredQuickplayButton();
	void OnPressedQuickplayButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMultiplayerMenuUI">();
	}
	static class UCrabMultiplayerMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMultiplayerMenuUI>();
	}
};
static_assert(alignof(UCrabMultiplayerMenuUI) == 0x000008, "Wrong alignment on UCrabMultiplayerMenuUI");
static_assert(sizeof(UCrabMultiplayerMenuUI) == 0x000408, "Wrong size on UCrabMultiplayerMenuUI");
static_assert(offsetof(UCrabMultiplayerMenuUI, QuickplayDifficultyAS) == 0x0003D0, "Member 'UCrabMultiplayerMenuUI::QuickplayDifficultyAS' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, QuickplayButton) == 0x0003D8, "Member 'UCrabMultiplayerMenuUI::QuickplayButton' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, QuickplayButtonText) == 0x0003E0, "Member 'UCrabMultiplayerMenuUI::QuickplayButtonText' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, FriendsScrollBox) == 0x0003E8, "Member 'UCrabMultiplayerMenuUI::FriendsScrollBox' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, InviteFriendRowUIToSpawn) == 0x0003F0, "Member 'UCrabMultiplayerMenuUI::InviteFriendRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, JoinedPlayersVerticalBox) == 0x0003F8, "Member 'UCrabMultiplayerMenuUI::JoinedPlayersVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, JoinedPlayerRowUIToSpawn) == 0x000400, "Member 'UCrabMultiplayerMenuUI::JoinedPlayerRowUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabOverlapInterface
// 0x0000 (0x0000 - 0x0000)
class ICrabOverlapInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabOverlapInterface">();
	}
	static class ICrabOverlapInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICrabOverlapInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICrabOverlapInterface) == 0x000001, "Wrong alignment on ICrabOverlapInterface");
static_assert(sizeof(ICrabOverlapInterface) == 0x000001, "Wrong size on ICrabOverlapInterface");

// Class CrabChampions.CrabPC
// 0x01A8 (0x0718 - 0x0570)
class ACrabPC : public APlayerController
{
public:
	class USoundCue*                              ArmorHitmarkerSound;                               // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ArmorBreakHitmarkerSound;                          // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              QuietHitmarkerSound;                               // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              NormalHitmarkerSound;                              // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LoudHitmarkerSound;                                // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              QuietCritHitmarkerSound;                           // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              NormalCritHitmarkerSound;                          // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LoudCritHitmarkerSound;                            // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              KnockbackDamageHitmarkerSound;                     // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              EliminationHitmarkerSound;                         // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SlomoRampCurve;                                    // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    LSActor;                                           // 0x05D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x48];                                     // 0x05E0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class USubmixEffectFilterPreset*              LowPassSubmixEffect;                               // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         PortalTransitionLS;                                // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDamageTextUI>          DamageTextUIToSpawn;                               // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACrabDamageTextActor*>           PooledDamageTextActors;                            // 0x0640(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDamageTextUI>          SpecialDamageTextUIToSpawn;                        // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACrabDamageTextActor*>           PooledSpecialDamageTextActors;                     // 0x0658(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0668(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           ClientOwnedC;                                      // 0x0678(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameStateUI>           GameStateUIToSpawn;                                // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabGameStateUI*                       GameStateUI;                                       // 0x0688(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameplayUI>            GameplayUIToSpawn;                                 // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabGameplayUI*                        GameplayUI;                                        // 0x0698(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInventoryUI>           InventoryUIToSpawn;                                // 0x06A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInventoryUI*                       InventoryUI;                                       // 0x06A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInGameMenuUI>          InGameMenuToSpawn;                                 // 0x06B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInGameMenuUI*                      InGameMenuUI;                                      // 0x06B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabCosmeticsMenuUI>       CosmeticsMenuUIToSpawn;                            // 0x06C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCosmeticsMenuUI*                   CosmeticsMenuUI;                                   // 0x06C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDifficultyMenuUI>      DifficultyMenuUIToSpawn;                           // 0x06D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabDifficultyMenuUI*                  DifficultyMenuUI;                                  // 0x06D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabMultiplayerMenuUI>     MultiplayerMenuUIToSpawn;                          // 0x06E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMultiplayerMenuUI*                 MultiplayerMenuUI;                                 // 0x06E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameOverUI>            GameOverUIToSpawn;                                 // 0x06F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabGameOverUI*                        GameOverUI;                                        // 0x06F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabMinigameGameOverUI>    MinigameGameOverUIToSpawn;                         // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMinigameGameOverUI*                MinigameGameOverUI;                                // 0x0708(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabFocusMenuUI*                       ActiveFocusMenuUI;                                 // 0x0710(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClientClearAutoSave();
	void ClientInventoryEvent(const class FString& InventoryEventMessage);
	void ClientLeaveGame();
	void ClientNotifyDamageDealt(const struct FCrabDamageInfo& DamageInfo, ECrabDamageHitType DamageHitType);
	void ClientOnClearedIsland(bool bWasFlawlessClear);
	void ClientOnEliminated(const class FString& EliminatedByPlayerName);
	void ClientOnEnteredPortal(const struct FCrabNextIslandInfo& NextIslandInfo, bool bSaveAutoSave);
	void ClientOnInteractedWithKeyTotem(class ACrabTotem* KeyTotem);
	void ClientOnPickedUpPickup(class UCrabPickupDA* PickupDA, uint8 Level);
	void ClientOnReceivedChatMessage(class ACrabPS* PS, const class FString& ChatMessage);
	void ClientOnTookDamage(ECrabDamageHitType DamageHitType);
	void ClientPlayerLeftGame();
	void ClientRefreshPSUI();
	void ClientSetIsCharacterInputEnabled(bool bNewIsCharacterInputEnabled);
	void ClientShowCosmeticsMenuUI();
	void ClientShowLoadingScreenUI();
	void ClientStartSlomoRamp();
	void ClientUploadLobbyStats();
	void ServerRestoreAutoSave(const struct FCrabAutoSave& AutoSave);
	void ServerSendChatMessage(const class FString& ChatMessage);
	void ServerSpawnKeyTotemPickup(class ACrabTotem* KeyTotem, class UCrabPickupDA* PickupToSpawn);
	void ServerSpectateNextPlayer();
	void ServerUploadLobbyStats(const struct FCrabLobbyStats& LobbyStats);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPC">();
	}
	static class ACrabPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPC>();
	}
};
static_assert(alignof(ACrabPC) == 0x000008, "Wrong alignment on ACrabPC");
static_assert(sizeof(ACrabPC) == 0x000718, "Wrong size on ACrabPC");
static_assert(offsetof(ACrabPC, ArmorHitmarkerSound) == 0x000570, "Member 'ACrabPC::ArmorHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, ArmorBreakHitmarkerSound) == 0x000578, "Member 'ACrabPC::ArmorBreakHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, QuietHitmarkerSound) == 0x000580, "Member 'ACrabPC::QuietHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, NormalHitmarkerSound) == 0x000588, "Member 'ACrabPC::NormalHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, LoudHitmarkerSound) == 0x000590, "Member 'ACrabPC::LoudHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, QuietCritHitmarkerSound) == 0x000598, "Member 'ACrabPC::QuietCritHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, NormalCritHitmarkerSound) == 0x0005A0, "Member 'ACrabPC::NormalCritHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, LoudCritHitmarkerSound) == 0x0005A8, "Member 'ACrabPC::LoudCritHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, KnockbackDamageHitmarkerSound) == 0x0005B0, "Member 'ACrabPC::KnockbackDamageHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, EliminationHitmarkerSound) == 0x0005B8, "Member 'ACrabPC::EliminationHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, SlomoRampCurve) == 0x0005C8, "Member 'ACrabPC::SlomoRampCurve' has a wrong offset!");
static_assert(offsetof(ACrabPC, LSActor) == 0x0005D8, "Member 'ACrabPC::LSActor' has a wrong offset!");
static_assert(offsetof(ACrabPC, LowPassSubmixEffect) == 0x000628, "Member 'ACrabPC::LowPassSubmixEffect' has a wrong offset!");
static_assert(offsetof(ACrabPC, PortalTransitionLS) == 0x000630, "Member 'ACrabPC::PortalTransitionLS' has a wrong offset!");
static_assert(offsetof(ACrabPC, DamageTextUIToSpawn) == 0x000638, "Member 'ACrabPC::DamageTextUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, PooledDamageTextActors) == 0x000640, "Member 'ACrabPC::PooledDamageTextActors' has a wrong offset!");
static_assert(offsetof(ACrabPC, SpecialDamageTextUIToSpawn) == 0x000650, "Member 'ACrabPC::SpecialDamageTextUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, PooledSpecialDamageTextActors) == 0x000658, "Member 'ACrabPC::PooledSpecialDamageTextActors' has a wrong offset!");
static_assert(offsetof(ACrabPC, CompletedChallenges) == 0x000668, "Member 'ACrabPC::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(ACrabPC, ClientOwnedC) == 0x000678, "Member 'ACrabPC::ClientOwnedC' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameStateUIToSpawn) == 0x000680, "Member 'ACrabPC::GameStateUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameStateUI) == 0x000688, "Member 'ACrabPC::GameStateUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameplayUIToSpawn) == 0x000690, "Member 'ACrabPC::GameplayUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameplayUI) == 0x000698, "Member 'ACrabPC::GameplayUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, InventoryUIToSpawn) == 0x0006A0, "Member 'ACrabPC::InventoryUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, InventoryUI) == 0x0006A8, "Member 'ACrabPC::InventoryUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, InGameMenuToSpawn) == 0x0006B0, "Member 'ACrabPC::InGameMenuToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, InGameMenuUI) == 0x0006B8, "Member 'ACrabPC::InGameMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, CosmeticsMenuUIToSpawn) == 0x0006C0, "Member 'ACrabPC::CosmeticsMenuUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, CosmeticsMenuUI) == 0x0006C8, "Member 'ACrabPC::CosmeticsMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, DifficultyMenuUIToSpawn) == 0x0006D0, "Member 'ACrabPC::DifficultyMenuUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, DifficultyMenuUI) == 0x0006D8, "Member 'ACrabPC::DifficultyMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, MultiplayerMenuUIToSpawn) == 0x0006E0, "Member 'ACrabPC::MultiplayerMenuUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, MultiplayerMenuUI) == 0x0006E8, "Member 'ACrabPC::MultiplayerMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameOverUIToSpawn) == 0x0006F0, "Member 'ACrabPC::GameOverUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameOverUI) == 0x0006F8, "Member 'ACrabPC::GameOverUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, MinigameGameOverUIToSpawn) == 0x000700, "Member 'ACrabPC::MinigameGameOverUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, MinigameGameOverUI) == 0x000708, "Member 'ACrabPC::MinigameGameOverUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, ActiveFocusMenuUI) == 0x000710, "Member 'ACrabPC::ActiveFocusMenuUI' has a wrong offset!");

// Class CrabChampions.CrabPerkDA
// 0x0008 (0x00E0 - 0x00D8)
class UCrabPerkDA final : public UCrabInventoryDA
{
public:
	ECrabPerkType                                 PerkType;                                          // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPerkDA">();
	}
	static class UCrabPerkDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPerkDA>();
	}
};
static_assert(alignof(UCrabPerkDA) == 0x000008, "Wrong alignment on UCrabPerkDA");
static_assert(sizeof(UCrabPerkDA) == 0x0000E0, "Wrong size on UCrabPerkDA");
static_assert(offsetof(UCrabPerkDA, PerkType) == 0x0000D8, "Member 'UCrabPerkDA::PerkType' has a wrong offset!");

// Class CrabChampions.CrabPhysicsActor
// 0x0058 (0x0278 - 0x0220)
class ACrabPhysicsActor : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MeshToSpawn;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScale;                                          // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScale;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomizeInitialRotation;                         // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ImpactSound;                                       // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExplodeWhenTakingDamage;                          // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExploded;                                       // 0x0261(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_IsExploded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPhysicsActor">();
	}
	static class ACrabPhysicsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPhysicsActor>();
	}
};
static_assert(alignof(ACrabPhysicsActor) == 0x000008, "Wrong alignment on ACrabPhysicsActor");
static_assert(sizeof(ACrabPhysicsActor) == 0x000278, "Wrong size on ACrabPhysicsActor");
static_assert(offsetof(ACrabPhysicsActor, Mesh) == 0x000228, "Member 'ACrabPhysicsActor::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, MeshToSpawn) == 0x000230, "Member 'ACrabPhysicsActor::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, MinScale) == 0x000238, "Member 'ACrabPhysicsActor::MinScale' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, MaxScale) == 0x00023C, "Member 'ACrabPhysicsActor::MaxScale' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, bRandomizeInitialRotation) == 0x000240, "Member 'ACrabPhysicsActor::bRandomizeInitialRotation' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, ImpactSound) == 0x000248, "Member 'ACrabPhysicsActor::ImpactSound' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, bExplodeWhenTakingDamage) == 0x000260, "Member 'ACrabPhysicsActor::bExplodeWhenTakingDamage' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, bIsExploded) == 0x000261, "Member 'ACrabPhysicsActor::bIsExploded' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, ExplosionFX) == 0x000268, "Member 'ACrabPhysicsActor::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, ExplosionSound) == 0x000270, "Member 'ACrabPhysicsActor::ExplosionSound' has a wrong offset!");

// Class CrabChampions.CrabPingUI
// 0x0008 (0x02C0 - 0x02B8)
class UCrabPingUI : public UCrabUI
{
public:
	class UImage*                                 PingIconImage;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPingUI">();
	}
	static class UCrabPingUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPingUI>();
	}
};
static_assert(alignof(UCrabPingUI) == 0x000008, "Wrong alignment on UCrabPingUI");
static_assert(sizeof(UCrabPingUI) == 0x0002C0, "Wrong size on UCrabPingUI");
static_assert(offsetof(UCrabPingUI, PingIconImage) == 0x0002B8, "Member 'UCrabPingUI::PingIconImage' has a wrong offset!");

// Class CrabChampions.CrabPlayerAnimInstance
// 0x0020 (0x02F0 - 0x02D0)
class UCrabPlayerAnimInstance : public UCrabAnimInstance
{
public:
	class ACrabPlayerC*                           OwningPlayerC;                                     // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTurnDir;                                    // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CurrentInputDir;                                   // 0x02DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSliding;                                        // 0x02E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5[0xB];                                      // 0x02E5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_Melee();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerAnimInstance">();
	}
	static class UCrabPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPlayerAnimInstance>();
	}
};
static_assert(alignof(UCrabPlayerAnimInstance) == 0x000010, "Wrong alignment on UCrabPlayerAnimInstance");
static_assert(sizeof(UCrabPlayerAnimInstance) == 0x0002F0, "Wrong size on UCrabPlayerAnimInstance");
static_assert(offsetof(UCrabPlayerAnimInstance, OwningPlayerC) == 0x0002D0, "Member 'UCrabPlayerAnimInstance::OwningPlayerC' has a wrong offset!");
static_assert(offsetof(UCrabPlayerAnimInstance, CurrentTurnDir) == 0x0002D8, "Member 'UCrabPlayerAnimInstance::CurrentTurnDir' has a wrong offset!");
static_assert(offsetof(UCrabPlayerAnimInstance, CurrentInputDir) == 0x0002DC, "Member 'UCrabPlayerAnimInstance::CurrentInputDir' has a wrong offset!");
static_assert(offsetof(UCrabPlayerAnimInstance, bIsSliding) == 0x0002E4, "Member 'UCrabPlayerAnimInstance::bIsSliding' has a wrong offset!");

// Class CrabChampions.CrabPlayerC
// 0x0410 (0x0B20 - 0x0710)
class ACrabPlayerC : public ACrabC
{
public:
	class USpringArmComponent*                    CameraSpringArm;                                   // 0x0710(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera;                                            // 0x0718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeleeMesh;                                         // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CosmeticMesh;                                      // 0x0728(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PlayerNameWC;                                      // 0x0730(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PingWC;                                            // 0x0738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SlideNC;                                           // 0x0740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        SlideAC;                                           // 0x0748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AmbienceNC;                                        // 0x0750(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      UnderwaterNC;                                      // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_760[0x4C];                                     // 0x0760(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBananaActive;                                   // 0x07AC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7AD[0x3];                                      // 0x07AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x07B0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x07B8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CrabSkin;                                          // 0x07C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CosmeticToSpawn;                                   // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabDamageInfo>                PendingDamageInfoArray;                            // 0x07D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E0[0x20];                                     // 0x07E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOverlapResult>                 NearbyActors;                                      // 0x0800(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         OverlapSearchRadius;                               // 0x0810(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_814[0x4];                                      // 0x0814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabInteractable*                      BestInteractable;                                  // 0x0818(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_820[0x8];                                      // 0x0820(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCrabPlayerNameUI>          PlayerNameUIToSpawn;                               // 0x0828(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabPingUI>                PingUIToSpawn;                                     // 0x0830(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPC*                                OwningPC;                                          // 0x0838(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0x10];                                     // 0x0840(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             InteractControllerIcon;                            // 0x0850(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x10];                                     // 0x0858(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SalvageControllerIcon;                             // 0x0868(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0xC];                                      // 0x0870(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultSpringArmOffset;                            // 0x087C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_888[0xC];                                      // 0x0888(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingSpringArmZOffset;                           // 0x0894(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0xC];                                      // 0x0898(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistRadius;                                   // 0x08A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistSpeed;                                    // 0x08A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8AC[0x4];                                      // 0x08AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimAssistTarget;                                   // 0x08B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B8[0x10];                                     // 0x08B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FlipMontageF;                                      // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlipMontageB;                                      // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlipMontageR;                                      // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlipMontageL;                                      // 0x08E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlipSpeed;                                         // 0x08E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlipHeight;                                        // 0x08EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F0[0x8];                                      // 0x08F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopFlipDelay;                                     // 0x08F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostFlipVelocityMultiplier;                        // 0x08FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_900[0xC];                                      // 0x0900(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDashCooldown;                                  // 0x090C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageF;                                      // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageB;                                      // 0x0918(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageR;                                      // 0x0920(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageL;                                      // 0x0928(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashSpeed;                                         // 0x0930(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashHeight;                                        // 0x0934(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostDashVelocityMultiplier;                        // 0x0938(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93C[0x4];                                      // 0x093C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         DashBlockedDamageFX;                               // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DashBlockedDamageSound;                            // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_950[0x19];                                     // 0x0950(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSliding;                                        // 0x0969(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_96A[0x6];                                      // 0x096A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SlideSpeedCurve;                                   // 0x0970(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_978[0x8];                                      // 0x0978(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         IceSlideFX;                                        // 0x0980(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              IceSlideSound;                                     // 0x0988(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         RockSlideFX;                                       // 0x0990(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RockSlideSound;                                    // 0x0998(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         SandSlideFX;                                       // 0x09A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SandSlideSound;                                    // 0x09A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideMaxAcceleration;                              // 0x09B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideBrakingFrictionFactor;                        // 0x09B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideGroundFriction;                               // 0x09B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9BC[0xC];                                      // 0x09BC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlideDamageIteration;                              // 0x09C8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAiming;                                         // 0x09CC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9CD[0xB];                                      // 0x09CD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AimingMontage;                                     // 0x09D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              StartAimSound;                                     // 0x09E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              StopAimSound;                                      // 0x09E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F0[0x38];                                     // 0x09F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MeleeDMI;                                          // 0x0A28(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A30[0x28];                                     // 0x0A30(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           InteractMontage;                                   // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              InteractFailureSound;                              // 0x0A60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabInteractPickup*                    PendingPickupToSalvage;                            // 0x0A68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A70[0x10];                                     // 0x0A70(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabChest*>                     ChestsToAutoLoot;                                  // 0x0A80(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A90[0x8];                                      // 0x0A90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    PingLoc;                                           // 0x0A98(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA4[0x4];                                      // 0x0AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PingFX;                                            // 0x0AA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PingSound;                                         // 0x0AB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB8[0x10];                                     // 0x0AB8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PrePortalFX;                                       // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PrePortalSound;                                    // 0x0AD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PostPortalFX;                                      // 0x0AD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PostPortalSound;                                   // 0x0AE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE8[0x8];                                      // 0x0AE8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECrabPerkType                                 CurrentTriggeredPerk;                              // 0x0AF0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF1[0x1F];                                     // 0x0AF1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabInteractable*                      ActiveInteractable;                                // 0x0B10(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B18[0x8];                                      // 0x0B18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientDashBlockedDamage();
	void ClientOnTriggeredRingOfDestruction();
	void ClientPostPortal();
	void ClientPrePortal(class ACrabPortal* Portal);
	void ClientTeleport(const struct FVector_NetQuantize& Loc, float Yaw);
	void MulticastAbility(const struct FVector_NetQuantize& InAbilityTelegraphLoc);
	void MulticastDash(ECrabInputDir DashDir);
	void MulticastFlip(ECrabInputDir FlipDir);
	void MulticastHideStalePing();
	void MulticastInteract();
	void MulticastMelee();
	void OnRep_AbilityDA();
	void OnRep_ActiveInteractable();
	void OnRep_CrabSkin();
	void OnRep_CurrentTriggeredPerk();
	void OnRep_IsAiming();
	void OnRep_IsBananaActive();
	void OnRep_IsSliding();
	void OnRep_MeleeDA();
	void OnRep_PingLoc(const struct FVector_NetQuantize& PreviousPingLoc);
	void OnRep_SlideDamageIteration();
	void ServerAbility(const struct FVector_NetQuantize& InAbilityTelegraphLoc);
	void ServerApplyEnhancement(class UCrabInventoryDA* InventoryDA);
	void ServerAutoLoot();
	void ServerDash(ECrabInputDir DashDir);
	void ServerDealDamage(const TArray<struct FCrabDamageInfo>& DamageInfoArray);
	void ServerDealFallDamage();
	void ServerDropPickup(class UCrabPickupDA* PickupDA, const struct FCrabInventoryInfo& InventoryInfo);
	void ServerFlip(ECrabInputDir FlipDir);
	void ServerInteract(class ACrabInteractable* ActorToInteractWith);
	void ServerMelee();
	void ServerPing(const struct FVector_NetQuantize& InPingLoc);
	void ServerSalvage(class ACrabInteractPickup* PickupToSalvage);
	void ServerSetActiveInteractable(class ACrabInteractable* NewActiveInteractable);
	void ServerStartAim();
	void ServerStartSlide();
	void ServerStopAim();
	void ServerStopSlide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerC">();
	}
	static class ACrabPlayerC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPlayerC>();
	}
};
static_assert(alignof(ACrabPlayerC) == 0x000010, "Wrong alignment on ACrabPlayerC");
static_assert(sizeof(ACrabPlayerC) == 0x000B20, "Wrong size on ACrabPlayerC");
static_assert(offsetof(ACrabPlayerC, CameraSpringArm) == 0x000710, "Member 'ACrabPlayerC::CameraSpringArm' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, Camera) == 0x000718, "Member 'ACrabPlayerC::Camera' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, MeleeMesh) == 0x000720, "Member 'ACrabPlayerC::MeleeMesh' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CosmeticMesh) == 0x000728, "Member 'ACrabPlayerC::CosmeticMesh' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PlayerNameWC) == 0x000730, "Member 'ACrabPlayerC::PlayerNameWC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingWC) == 0x000738, "Member 'ACrabPlayerC::PingWC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideNC) == 0x000740, "Member 'ACrabPlayerC::SlideNC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideAC) == 0x000748, "Member 'ACrabPlayerC::SlideAC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AmbienceNC) == 0x000750, "Member 'ACrabPlayerC::AmbienceNC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, UnderwaterNC) == 0x000758, "Member 'ACrabPlayerC::UnderwaterNC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, bIsBananaActive) == 0x0007AC, "Member 'ACrabPlayerC::bIsBananaActive' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AbilityDA) == 0x0007B0, "Member 'ACrabPlayerC::AbilityDA' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, MeleeDA) == 0x0007B8, "Member 'ACrabPlayerC::MeleeDA' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CrabSkin) == 0x0007C0, "Member 'ACrabPlayerC::CrabSkin' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CosmeticToSpawn) == 0x0007C8, "Member 'ACrabPlayerC::CosmeticToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PendingDamageInfoArray) == 0x0007D0, "Member 'ACrabPlayerC::PendingDamageInfoArray' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, NearbyActors) == 0x000800, "Member 'ACrabPlayerC::NearbyActors' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, OverlapSearchRadius) == 0x000810, "Member 'ACrabPlayerC::OverlapSearchRadius' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, BestInteractable) == 0x000818, "Member 'ACrabPlayerC::BestInteractable' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PlayerNameUIToSpawn) == 0x000828, "Member 'ACrabPlayerC::PlayerNameUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingUIToSpawn) == 0x000830, "Member 'ACrabPlayerC::PingUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, OwningPC) == 0x000838, "Member 'ACrabPlayerC::OwningPC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, InteractControllerIcon) == 0x000850, "Member 'ACrabPlayerC::InteractControllerIcon' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SalvageControllerIcon) == 0x000868, "Member 'ACrabPlayerC::SalvageControllerIcon' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DefaultSpringArmOffset) == 0x00087C, "Member 'ACrabPlayerC::DefaultSpringArmOffset' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FallingSpringArmZOffset) == 0x000894, "Member 'ACrabPlayerC::FallingSpringArmZOffset' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimAssistRadius) == 0x0008A4, "Member 'ACrabPlayerC::AimAssistRadius' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimAssistSpeed) == 0x0008A8, "Member 'ACrabPlayerC::AimAssistSpeed' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimAssistTarget) == 0x0008B0, "Member 'ACrabPlayerC::AimAssistTarget' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageF) == 0x0008C8, "Member 'ACrabPlayerC::FlipMontageF' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageB) == 0x0008D0, "Member 'ACrabPlayerC::FlipMontageB' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageR) == 0x0008D8, "Member 'ACrabPlayerC::FlipMontageR' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageL) == 0x0008E0, "Member 'ACrabPlayerC::FlipMontageL' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipSpeed) == 0x0008E8, "Member 'ACrabPlayerC::FlipSpeed' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipHeight) == 0x0008EC, "Member 'ACrabPlayerC::FlipHeight' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, StopFlipDelay) == 0x0008F8, "Member 'ACrabPlayerC::StopFlipDelay' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostFlipVelocityMultiplier) == 0x0008FC, "Member 'ACrabPlayerC::PostFlipVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, BaseDashCooldown) == 0x00090C, "Member 'ACrabPlayerC::BaseDashCooldown' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageF) == 0x000910, "Member 'ACrabPlayerC::DashMontageF' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageB) == 0x000918, "Member 'ACrabPlayerC::DashMontageB' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageR) == 0x000920, "Member 'ACrabPlayerC::DashMontageR' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageL) == 0x000928, "Member 'ACrabPlayerC::DashMontageL' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashSpeed) == 0x000930, "Member 'ACrabPlayerC::DashSpeed' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashHeight) == 0x000934, "Member 'ACrabPlayerC::DashHeight' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostDashVelocityMultiplier) == 0x000938, "Member 'ACrabPlayerC::PostDashVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashBlockedDamageFX) == 0x000940, "Member 'ACrabPlayerC::DashBlockedDamageFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashBlockedDamageSound) == 0x000948, "Member 'ACrabPlayerC::DashBlockedDamageSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, bIsSliding) == 0x000969, "Member 'ACrabPlayerC::bIsSliding' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideSpeedCurve) == 0x000970, "Member 'ACrabPlayerC::SlideSpeedCurve' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, IceSlideFX) == 0x000980, "Member 'ACrabPlayerC::IceSlideFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, IceSlideSound) == 0x000988, "Member 'ACrabPlayerC::IceSlideSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, RockSlideFX) == 0x000990, "Member 'ACrabPlayerC::RockSlideFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, RockSlideSound) == 0x000998, "Member 'ACrabPlayerC::RockSlideSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SandSlideFX) == 0x0009A0, "Member 'ACrabPlayerC::SandSlideFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SandSlideSound) == 0x0009A8, "Member 'ACrabPlayerC::SandSlideSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideMaxAcceleration) == 0x0009B0, "Member 'ACrabPlayerC::SlideMaxAcceleration' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideBrakingFrictionFactor) == 0x0009B4, "Member 'ACrabPlayerC::SlideBrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideGroundFriction) == 0x0009B8, "Member 'ACrabPlayerC::SlideGroundFriction' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideDamageIteration) == 0x0009C8, "Member 'ACrabPlayerC::SlideDamageIteration' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, bIsAiming) == 0x0009CC, "Member 'ACrabPlayerC::bIsAiming' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimingMontage) == 0x0009D8, "Member 'ACrabPlayerC::AimingMontage' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, StartAimSound) == 0x0009E0, "Member 'ACrabPlayerC::StartAimSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, StopAimSound) == 0x0009E8, "Member 'ACrabPlayerC::StopAimSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, MeleeDMI) == 0x000A28, "Member 'ACrabPlayerC::MeleeDMI' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, InteractMontage) == 0x000A58, "Member 'ACrabPlayerC::InteractMontage' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, InteractFailureSound) == 0x000A60, "Member 'ACrabPlayerC::InteractFailureSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PendingPickupToSalvage) == 0x000A68, "Member 'ACrabPlayerC::PendingPickupToSalvage' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, ChestsToAutoLoot) == 0x000A80, "Member 'ACrabPlayerC::ChestsToAutoLoot' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingLoc) == 0x000A98, "Member 'ACrabPlayerC::PingLoc' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingFX) == 0x000AA8, "Member 'ACrabPlayerC::PingFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingSound) == 0x000AB0, "Member 'ACrabPlayerC::PingSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PrePortalFX) == 0x000AC8, "Member 'ACrabPlayerC::PrePortalFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PrePortalSound) == 0x000AD0, "Member 'ACrabPlayerC::PrePortalSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostPortalFX) == 0x000AD8, "Member 'ACrabPlayerC::PostPortalFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostPortalSound) == 0x000AE0, "Member 'ACrabPlayerC::PostPortalSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CurrentTriggeredPerk) == 0x000AF0, "Member 'ACrabPlayerC::CurrentTriggeredPerk' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, ActiveInteractable) == 0x000B10, "Member 'ACrabPlayerC::ActiveInteractable' has a wrong offset!");

// Class CrabChampions.CrabPlayerNameUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabPlayerNameUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerArrowImage;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerNameUI">();
	}
	static class UCrabPlayerNameUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPlayerNameUI>();
	}
};
static_assert(alignof(UCrabPlayerNameUI) == 0x000008, "Wrong alignment on UCrabPlayerNameUI");
static_assert(sizeof(UCrabPlayerNameUI) == 0x0002C8, "Wrong size on UCrabPlayerNameUI");
static_assert(offsetof(UCrabPlayerNameUI, PlayerNameText) == 0x0002B8, "Member 'UCrabPlayerNameUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerNameUI, PlayerArrowImage) == 0x0002C0, "Member 'UCrabPlayerNameUI::PlayerArrowImage' has a wrong offset!");

// Class CrabChampions.CrabPlayerStateUI
// 0x0048 (0x0300 - 0x02B8)
class UCrabPlayerStateUI : public UCrabUI
{
public:
	class UImage*                                 PlayerTintImage;                                   // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerEliminationsText;                            // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerCrystalsText;                                // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerAccountRankImage;                            // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerAccountLevelText;                            // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PlayerHealthBar;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PlayerEliminatedAnim;                              // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                PlayerPS;                                          // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerStateUI">();
	}
	static class UCrabPlayerStateUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPlayerStateUI>();
	}
};
static_assert(alignof(UCrabPlayerStateUI) == 0x000008, "Wrong alignment on UCrabPlayerStateUI");
static_assert(sizeof(UCrabPlayerStateUI) == 0x000300, "Wrong size on UCrabPlayerStateUI");
static_assert(offsetof(UCrabPlayerStateUI, PlayerTintImage) == 0x0002B8, "Member 'UCrabPlayerStateUI::PlayerTintImage' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerNameText) == 0x0002C0, "Member 'UCrabPlayerStateUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerEliminationsText) == 0x0002C8, "Member 'UCrabPlayerStateUI::PlayerEliminationsText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerCrystalsText) == 0x0002D0, "Member 'UCrabPlayerStateUI::PlayerCrystalsText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerAccountRankImage) == 0x0002D8, "Member 'UCrabPlayerStateUI::PlayerAccountRankImage' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerAccountLevelText) == 0x0002E0, "Member 'UCrabPlayerStateUI::PlayerAccountLevelText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerHealthBar) == 0x0002E8, "Member 'UCrabPlayerStateUI::PlayerHealthBar' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerEliminatedAnim) == 0x0002F0, "Member 'UCrabPlayerStateUI::PlayerEliminatedAnim' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerPS) == 0x0002F8, "Member 'UCrabPlayerStateUI::PlayerPS' has a wrong offset!");

// Class CrabChampions.CrabPMC
// 0x00C8 (0x01B8 - 0x00F0)
class UCrabPMC final : public UMovementComponent
{
public:
	uint8                                         Pad_F0[0x40];                                      // 0x00F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 HomingTarget;                                      // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabProjectile*                        OwningProjectile;                                  // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x60];                                     // 0x0158(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPMC">();
	}
	static class UCrabPMC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPMC>();
	}
};
static_assert(alignof(UCrabPMC) == 0x000008, "Wrong alignment on UCrabPMC");
static_assert(sizeof(UCrabPMC) == 0x0001B8, "Wrong size on UCrabPMC");
static_assert(offsetof(UCrabPMC, HomingTarget) == 0x000130, "Member 'UCrabPMC::HomingTarget' has a wrong offset!");
static_assert(offsetof(UCrabPMC, ProjectileDA) == 0x000148, "Member 'UCrabPMC::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabPMC, OwningProjectile) == 0x000150, "Member 'UCrabPMC::OwningProjectile' has a wrong offset!");

// Class CrabChampions.CrabPortal
// 0x0080 (0x02F8 - 0x0278)
class ACrabPortal : public ACrabInteractable
{
public:
	class UStaticMeshComponent*                   PortalMesh;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PortalNC;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PortalAC;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabIslandType                               IslandType;                                        // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Description;                                       // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Mesh;                                              // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabPortalInfo                        PortalInfo;                                        // 0x02D8(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_PortalInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPortal">();
	}
	static class ACrabPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPortal>();
	}
};
static_assert(alignof(ACrabPortal) == 0x000008, "Wrong alignment on ACrabPortal");
static_assert(sizeof(ACrabPortal) == 0x0002F8, "Wrong size on ACrabPortal");
static_assert(offsetof(ACrabPortal, PortalMesh) == 0x000278, "Member 'ACrabPortal::PortalMesh' has a wrong offset!");
static_assert(offsetof(ACrabPortal, PortalNC) == 0x000280, "Member 'ACrabPortal::PortalNC' has a wrong offset!");
static_assert(offsetof(ACrabPortal, PortalAC) == 0x000288, "Member 'ACrabPortal::PortalAC' has a wrong offset!");
static_assert(offsetof(ACrabPortal, IslandType) == 0x000290, "Member 'ACrabPortal::IslandType' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Icon) == 0x000298, "Member 'ACrabPortal::Icon' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Description) == 0x0002A0, "Member 'ACrabPortal::Description' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Tint) == 0x0002B0, "Member 'ACrabPortal::Tint' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Mesh) == 0x0002C0, "Member 'ACrabPortal::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabPortal, FX) == 0x0002C8, "Member 'ACrabPortal::FX' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Sound) == 0x0002D0, "Member 'ACrabPortal::Sound' has a wrong offset!");
static_assert(offsetof(ACrabPortal, PortalInfo) == 0x0002D8, "Member 'ACrabPortal::PortalInfo' has a wrong offset!");

// Class CrabChampions.CrabPortalInteractUI
// 0x0068 (0x03C8 - 0x0360)
class UCrabPortalInteractUI : public UCrabInteractUI
{
public:
	class UBorder*                                ChallengeBorder;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeNameText;                                 // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeDescriptionText;                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                AdditionalChallengeBorder;                         // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeNameText;                       // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeDescriptionText;                // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                BlessingBorder;                                    // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingNameText;                                  // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingDescriptionText;                           // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RewardBorder;                                      // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DoubleRewardText;                                  // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RewardNameText;                                    // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RewardDescriptionText;                             // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPortalInteractUI">();
	}
	static class UCrabPortalInteractUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPortalInteractUI>();
	}
};
static_assert(alignof(UCrabPortalInteractUI) == 0x000008, "Wrong alignment on UCrabPortalInteractUI");
static_assert(sizeof(UCrabPortalInteractUI) == 0x0003C8, "Wrong size on UCrabPortalInteractUI");
static_assert(offsetof(UCrabPortalInteractUI, ChallengeBorder) == 0x000360, "Member 'UCrabPortalInteractUI::ChallengeBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, ChallengeNameText) == 0x000368, "Member 'UCrabPortalInteractUI::ChallengeNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, ChallengeDescriptionText) == 0x000370, "Member 'UCrabPortalInteractUI::ChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, AdditionalChallengeBorder) == 0x000378, "Member 'UCrabPortalInteractUI::AdditionalChallengeBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, AdditionalChallengeNameText) == 0x000380, "Member 'UCrabPortalInteractUI::AdditionalChallengeNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, AdditionalChallengeDescriptionText) == 0x000388, "Member 'UCrabPortalInteractUI::AdditionalChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, BlessingBorder) == 0x000390, "Member 'UCrabPortalInteractUI::BlessingBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, BlessingNameText) == 0x000398, "Member 'UCrabPortalInteractUI::BlessingNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, BlessingDescriptionText) == 0x0003A0, "Member 'UCrabPortalInteractUI::BlessingDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, RewardBorder) == 0x0003A8, "Member 'UCrabPortalInteractUI::RewardBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, DoubleRewardText) == 0x0003B0, "Member 'UCrabPortalInteractUI::DoubleRewardText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, RewardNameText) == 0x0003B8, "Member 'UCrabPortalInteractUI::RewardNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, RewardDescriptionText) == 0x0003C0, "Member 'UCrabPortalInteractUI::RewardDescriptionText' has a wrong offset!");

// Class CrabChampions.CrabProjectile
// 0x0250 (0x0470 - 0x0220)
class ACrabProjectile final : public AActor
{
public:
	class USphereComponent*                       ProjectileCollision;                               // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabPMC*                               ProjectilePMC;                                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ProjectileNC;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ProjectileTrailNC;                                 // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ProjectileAC;                                      // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabProjectileInfo                    ProjectileInfo;                                    // 0x0250(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x28];                                     // 0x0280(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabEnhancementType>                  Enhancements;                                      // 0x02A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x02B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabAbilityMod>                AbilityMods;                                       // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabPerk>                      Perks;                                             // 0x02D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x02F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabBeam*                              AttachedBeam;                                      // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDamageInfo                        ExplosionDamageInfo;                               // 0x0320(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FCrabDamageInfo                        ProximityDamageInfo;                               // 0x0368(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDamageInfo                        AuraDamageInfo;                                    // 0x03B8(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x70];                                     // 0x0400(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProjectile">();
	}
	static class ACrabProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabProjectile>();
	}
};
static_assert(alignof(ACrabProjectile) == 0x000008, "Wrong alignment on ACrabProjectile");
static_assert(sizeof(ACrabProjectile) == 0x000470, "Wrong size on ACrabProjectile");
static_assert(offsetof(ACrabProjectile, ProjectileCollision) == 0x000220, "Member 'ACrabProjectile::ProjectileCollision' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectilePMC) == 0x000228, "Member 'ACrabProjectile::ProjectilePMC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileNC) == 0x000230, "Member 'ACrabProjectile::ProjectileNC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileTrailNC) == 0x000238, "Member 'ACrabProjectile::ProjectileTrailNC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileAC) == 0x000240, "Member 'ACrabProjectile::ProjectileAC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileInfo) == 0x000250, "Member 'ACrabProjectile::ProjectileInfo' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, Enhancements) == 0x0002A8, "Member 'ACrabProjectile::Enhancements' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, WeaponMods) == 0x0002B8, "Member 'ACrabProjectile::WeaponMods' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, AbilityMods) == 0x0002C8, "Member 'ACrabProjectile::AbilityMods' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, Perks) == 0x0002D8, "Member 'ACrabProjectile::Perks' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ActorsToIgnore) == 0x0002F0, "Member 'ACrabProjectile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, AttachedBeam) == 0x000308, "Member 'ACrabProjectile::AttachedBeam' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ExplosionDamageInfo) == 0x000320, "Member 'ACrabProjectile::ExplosionDamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProximityDamageInfo) == 0x000368, "Member 'ACrabProjectile::ProximityDamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, AuraDamageInfo) == 0x0003B8, "Member 'ACrabProjectile::AuraDamageInfo' has a wrong offset!");

// Class CrabChampions.CrabProjectileActionDA
// 0x0038 (0x00A0 - 0x0068)
class UCrabProjectileActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SocketNames;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFormationType                            FormationType;                                     // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireInSequence;                                   // 0x0089(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FormationSpacing;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationSpacingIterationMultiplier;               // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationExpansionDampening;                       // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationExpansionDampeningIterationMultiplier;    // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spread;                                            // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProjectileActionDA">();
	}
	static class UCrabProjectileActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabProjectileActionDA>();
	}
};
static_assert(alignof(UCrabProjectileActionDA) == 0x000008, "Wrong alignment on UCrabProjectileActionDA");
static_assert(sizeof(UCrabProjectileActionDA) == 0x0000A0, "Wrong size on UCrabProjectileActionDA");
static_assert(offsetof(UCrabProjectileActionDA, TargetType) == 0x000068, "Member 'UCrabProjectileActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, SocketNames) == 0x000070, "Member 'UCrabProjectileActionDA::SocketNames' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, ProjectileDA) == 0x000080, "Member 'UCrabProjectileActionDA::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationType) == 0x000088, "Member 'UCrabProjectileActionDA::FormationType' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, bFireInSequence) == 0x000089, "Member 'UCrabProjectileActionDA::bFireInSequence' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationSpacing) == 0x00008C, "Member 'UCrabProjectileActionDA::FormationSpacing' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationSpacingIterationMultiplier) == 0x000090, "Member 'UCrabProjectileActionDA::FormationSpacingIterationMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationExpansionDampening) == 0x000094, "Member 'UCrabProjectileActionDA::FormationExpansionDampening' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationExpansionDampeningIterationMultiplier) == 0x000098, "Member 'UCrabProjectileActionDA::FormationExpansionDampeningIterationMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, Spread) == 0x00009C, "Member 'UCrabProjectileActionDA::Spread' has a wrong offset!");

// Class CrabChampions.CrabProjectileDA
// 0x0100 (0x0130 - 0x0030)
class UCrabProjectileDA final : public UDataAsset
{
public:
	float                                         LifeTime;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationScale;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAcceleration;                               // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZigZagScale;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpiralScale;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnakeScale;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaoticScale;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoomerangScale;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrbitingScale;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityDelay;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingScale;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingDelay;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingLerpSpeed;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAccelerationScale;                           // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAccelerationRange;                           // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrapplingScale;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPiercings;                                      // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBounces;                                        // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityScale;                               // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlueToHitCharacters;                              // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProximityDamageRadius;                             // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProximityDamageMultiplier;                         // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabBeam>                  AttachedBeamToSpawn;                               // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeAfterLifetime;                             // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDelay;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplosionLOSCheck;                                // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDamage;                                   // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDamageTagType                            ExplosionDamageTag;                                // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            ExplosionDebuff;                                   // 0x00B8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExplosionKnockbackStrength;                        // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACrabBeam>                  ExplosionBeamToSpawn;                              // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          ExplosionDestructibleToSpawn;                      // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDestructiblePhysicsImpulse;               // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDamageAreaSpawnChance;                    // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            ExplosionDamageAreaToSpawn;                        // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ProjectileFX;                                      // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ProjectileTrailFX;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ProjectileSound;                                   // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeTint;                                    // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ExplosionSound;                                    // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ExplosionDecalMat;                                 // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDecalSize;                                // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProjectileDA">();
	}
	static class UCrabProjectileDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabProjectileDA>();
	}
};
static_assert(alignof(UCrabProjectileDA) == 0x000008, "Wrong alignment on UCrabProjectileDA");
static_assert(sizeof(UCrabProjectileDA) == 0x000130, "Wrong size on UCrabProjectileDA");
static_assert(offsetof(UCrabProjectileDA, LifeTime) == 0x000030, "Member 'UCrabProjectileDA::LifeTime' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, CollisionRadius) == 0x000034, "Member 'UCrabProjectileDA::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, Speed) == 0x000038, "Member 'UCrabProjectileDA::Speed' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, MaxSpeed) == 0x00003C, "Member 'UCrabProjectileDA::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, AccelerationScale) == 0x000040, "Member 'UCrabProjectileDA::AccelerationScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bIgnoreAcceleration) == 0x000044, "Member 'UCrabProjectileDA::bIgnoreAcceleration' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ZigZagScale) == 0x000048, "Member 'UCrabProjectileDA::ZigZagScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, SpiralScale) == 0x00004C, "Member 'UCrabProjectileDA::SpiralScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, SnakeScale) == 0x000050, "Member 'UCrabProjectileDA::SnakeScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ChaoticScale) == 0x000054, "Member 'UCrabProjectileDA::ChaoticScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, BoomerangScale) == 0x000058, "Member 'UCrabProjectileDA::BoomerangScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, OrbitingScale) == 0x00005C, "Member 'UCrabProjectileDA::OrbitingScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, GravityScale) == 0x000060, "Member 'UCrabProjectileDA::GravityScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, GravityDelay) == 0x000064, "Member 'UCrabProjectileDA::GravityDelay' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, HomingScale) == 0x000068, "Member 'UCrabProjectileDA::HomingScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, HomingDelay) == 0x00006C, "Member 'UCrabProjectileDA::HomingDelay' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, HomingLerpSpeed) == 0x000070, "Member 'UCrabProjectileDA::HomingLerpSpeed' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, HomingAccelerationScale) == 0x000074, "Member 'UCrabProjectileDA::HomingAccelerationScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, HomingAccelerationRange) == 0x000078, "Member 'UCrabProjectileDA::HomingAccelerationRange' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, GrapplingScale) == 0x00007C, "Member 'UCrabProjectileDA::GrapplingScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, MaxPiercings) == 0x000080, "Member 'UCrabProjectileDA::MaxPiercings' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, MaxBounces) == 0x000084, "Member 'UCrabProjectileDA::MaxBounces' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, BounceVelocityScale) == 0x000088, "Member 'UCrabProjectileDA::BounceVelocityScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bGlueToHitCharacters) == 0x00008C, "Member 'UCrabProjectileDA::bGlueToHitCharacters' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProximityDamageRadius) == 0x000090, "Member 'UCrabProjectileDA::ProximityDamageRadius' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProximityDamageMultiplier) == 0x000094, "Member 'UCrabProjectileDA::ProximityDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, AttachedBeamToSpawn) == 0x000098, "Member 'UCrabProjectileDA::AttachedBeamToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bExplodeAfterLifetime) == 0x0000A0, "Member 'UCrabProjectileDA::bExplodeAfterLifetime' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDelay) == 0x0000A4, "Member 'UCrabProjectileDA::ExplosionDelay' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionRadius) == 0x0000A8, "Member 'UCrabProjectileDA::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bExplosionLOSCheck) == 0x0000AC, "Member 'UCrabProjectileDA::bExplosionLOSCheck' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamage) == 0x0000B0, "Member 'UCrabProjectileDA::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamageTag) == 0x0000B4, "Member 'UCrabProjectileDA::ExplosionDamageTag' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDebuff) == 0x0000B8, "Member 'UCrabProjectileDA::ExplosionDebuff' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionKnockbackStrength) == 0x0000C0, "Member 'UCrabProjectileDA::ExplosionKnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionBeamToSpawn) == 0x0000C8, "Member 'UCrabProjectileDA::ExplosionBeamToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDestructibleToSpawn) == 0x0000D0, "Member 'UCrabProjectileDA::ExplosionDestructibleToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDestructiblePhysicsImpulse) == 0x0000D8, "Member 'UCrabProjectileDA::ExplosionDestructiblePhysicsImpulse' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamageAreaSpawnChance) == 0x0000DC, "Member 'UCrabProjectileDA::ExplosionDamageAreaSpawnChance' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamageAreaToSpawn) == 0x0000E0, "Member 'UCrabProjectileDA::ExplosionDamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProjectileFX) == 0x0000E8, "Member 'UCrabProjectileDA::ProjectileFX' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProjectileTrailFX) == 0x0000F0, "Member 'UCrabProjectileDA::ProjectileTrailFX' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProjectileSound) == 0x0000F8, "Member 'UCrabProjectileDA::ProjectileSound' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bRandomizeTint) == 0x000100, "Member 'UCrabProjectileDA::bRandomizeTint' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionFX) == 0x000108, "Member 'UCrabProjectileDA::ExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionSound) == 0x000110, "Member 'UCrabProjectileDA::ExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionCameraShake) == 0x000118, "Member 'UCrabProjectileDA::ExplosionCameraShake' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDecalMat) == 0x000120, "Member 'UCrabProjectileDA::ExplosionDecalMat' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDecalSize) == 0x000128, "Member 'UCrabProjectileDA::ExplosionDecalSize' has a wrong offset!");

// Class CrabChampions.CrabProximityExplodeActionDA
// 0x0008 (0x0070 - 0x0068)
class UCrabProximityExplodeActionDA final : public UCrabActionDA
{
public:
	class UCrabAOEDA*                             ExplosionAOEDA;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProximityExplodeActionDA">();
	}
	static class UCrabProximityExplodeActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabProximityExplodeActionDA>();
	}
};
static_assert(alignof(UCrabProximityExplodeActionDA) == 0x000008, "Wrong alignment on UCrabProximityExplodeActionDA");
static_assert(sizeof(UCrabProximityExplodeActionDA) == 0x000070, "Wrong size on UCrabProximityExplodeActionDA");
static_assert(offsetof(UCrabProximityExplodeActionDA, ExplosionAOEDA) == 0x000068, "Member 'UCrabProximityExplodeActionDA::ExplosionAOEDA' has a wrong offset!");

// Class CrabChampions.CrabPS
// 0x0258 (0x0578 - 0x0320)
class ACrabPS final : public APlayerState
{
public:
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabInventoryCooldown>         InventoryCooldowns;                                // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	ECrabTintType                                 PlayerTintType;                                    // 0x0338(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCrabPickupDA*>                  PSPickups;                                         // 0x0340(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         ComboCounter;                                      // 0x0350(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Combo;                                             // 0x0354(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Eliminations;                                      // 0x0358(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0xC];                                      // 0x035C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DamageDealt;                                       // 0x0368(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        HighestDamageDealt;                                // 0x036C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageTaken;                                       // 0x0370(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageTakenOnThisIsland;                           // 0x0374(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumFlawlessIslands;                                // 0x0378(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x037C(0x001C)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BaseMaxHealth;                                     // 0x0398(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealthMultiplier;                               // 0x039C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageMultiplier;                                  // 0x03A0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleMultiplier;                                   // 0x03A4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabRank                                     AccountRank;                                       // 0x03A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccountLevel;                                      // 0x03AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Keys;                                              // 0x03B0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CrabSkin;                                          // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x03C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x03C8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x03D0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumWeaponModSlots;                                 // 0x03D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x03E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         NumAbilityModSlots;                                // 0x03F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabAbilityMod>                AbilityMods;                                       // 0x03F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         NumMeleeModSlots;                                  // 0x0408(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabMeleeMod>                  MeleeMods;                                         // 0x0410(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         NumPerkSlots;                                      // 0x0420(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabPerk>                      Perks;                                             // 0x0428(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabRelic>                     Relics;                                            // 0x0438(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTimesSalvaged;                                  // 0x0460(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumShopPurchases;                                  // 0x0464(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumShopRerolls;                                    // 0x0468(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumTotemsDestroyed;                                // 0x046C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        Crystals;                                          // 0x0470(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ECrabRarity                                   IslandRewardRarity;                                // 0x0478(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabCheckpoint*                        ParkourCheckpoint;                                 // 0x0480(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACrabAnvil*>                     ChosenAnvils;                                      // 0x0488(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ACrabPortal*                            ChosenPortal;                                      // 0x0498(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalTimeTaken;                                    // 0x04A0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0xD4];                                     // 0x04A4(0x00D4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbilityDA();
	void OnRep_AccountLevel();
	void OnRep_AccountRank();
	void OnRep_Combo();
	void OnRep_Crystals();
	void OnRep_DamageTakenOnThisIsland();
	void OnRep_Eliminations();
	void OnRep_Inventory();
	void OnRep_IslandRewardRarity();
	void OnRep_Keys();
	void OnRep_MeleeDA();
	void OnRep_ScaleMultiplier();
	void OnRep_WeaponDA();
	void ServerEquipCosmetics(class UMaterialInterface* NewCrabSkin);
	void ServerEquipInventory(class UCrabWeaponDA* NewWeaponDA, class UCrabAbilityDA* NewAbilityDA, class UCrabMeleeDA* NewMeleeDA);
	void ServerIncrementNumInventorySlots(ECrabPickupType PickupType, int32 Cost);
	void ServerRefreshAccount(ECrabRank NewAccountRank, int32 NewAccountLevel, int32 NewKeys);
	void ServerRemoveAbilityMod(ECrabAbilityModType AbilityModType);
	void ServerRemoveMeleeMod(ECrabMeleeModType MeleeModType);
	void ServerRemovePerk(ECrabPerkType PerkType);
	void ServerRemoveRelic(ECrabRelicType RelicType);
	void ServerRemoveWeaponMod(ECrabWeaponModType WeaponModType);
	void ServerSetAbilityDA(class UCrabAbilityDA* NewAbilityDA);
	void ServerSetMeleeDA(class UCrabMeleeDA* NewMeleeDA);
	void ServerSetWeaponDA(class UCrabWeaponDA* NewWeaponDA);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPS">();
	}
	static class ACrabPS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPS>();
	}
};
static_assert(alignof(ACrabPS) == 0x000008, "Wrong alignment on ACrabPS");
static_assert(sizeof(ACrabPS) == 0x000578, "Wrong size on ACrabPS");
static_assert(offsetof(ACrabPS, InventoryCooldowns) == 0x000328, "Member 'ACrabPS::InventoryCooldowns' has a wrong offset!");
static_assert(offsetof(ACrabPS, PlayerTintType) == 0x000338, "Member 'ACrabPS::PlayerTintType' has a wrong offset!");
static_assert(offsetof(ACrabPS, PSPickups) == 0x000340, "Member 'ACrabPS::PSPickups' has a wrong offset!");
static_assert(offsetof(ACrabPS, ComboCounter) == 0x000350, "Member 'ACrabPS::ComboCounter' has a wrong offset!");
static_assert(offsetof(ACrabPS, Combo) == 0x000354, "Member 'ACrabPS::Combo' has a wrong offset!");
static_assert(offsetof(ACrabPS, Eliminations) == 0x000358, "Member 'ACrabPS::Eliminations' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageDealt) == 0x000368, "Member 'ACrabPS::DamageDealt' has a wrong offset!");
static_assert(offsetof(ACrabPS, HighestDamageDealt) == 0x00036C, "Member 'ACrabPS::HighestDamageDealt' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageTaken) == 0x000370, "Member 'ACrabPS::DamageTaken' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageTakenOnThisIsland) == 0x000374, "Member 'ACrabPS::DamageTakenOnThisIsland' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumFlawlessIslands) == 0x000378, "Member 'ACrabPS::NumFlawlessIslands' has a wrong offset!");
static_assert(offsetof(ACrabPS, HealthInfo) == 0x00037C, "Member 'ACrabPS::HealthInfo' has a wrong offset!");
static_assert(offsetof(ACrabPS, BaseMaxHealth) == 0x000398, "Member 'ACrabPS::BaseMaxHealth' has a wrong offset!");
static_assert(offsetof(ACrabPS, MaxHealthMultiplier) == 0x00039C, "Member 'ACrabPS::MaxHealthMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageMultiplier) == 0x0003A0, "Member 'ACrabPS::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPS, ScaleMultiplier) == 0x0003A4, "Member 'ACrabPS::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPS, AccountRank) == 0x0003A8, "Member 'ACrabPS::AccountRank' has a wrong offset!");
static_assert(offsetof(ACrabPS, AccountLevel) == 0x0003AC, "Member 'ACrabPS::AccountLevel' has a wrong offset!");
static_assert(offsetof(ACrabPS, Keys) == 0x0003B0, "Member 'ACrabPS::Keys' has a wrong offset!");
static_assert(offsetof(ACrabPS, CrabSkin) == 0x0003B8, "Member 'ACrabPS::CrabSkin' has a wrong offset!");
static_assert(offsetof(ACrabPS, WeaponDA) == 0x0003C0, "Member 'ACrabPS::WeaponDA' has a wrong offset!");
static_assert(offsetof(ACrabPS, AbilityDA) == 0x0003C8, "Member 'ACrabPS::AbilityDA' has a wrong offset!");
static_assert(offsetof(ACrabPS, MeleeDA) == 0x0003D0, "Member 'ACrabPS::MeleeDA' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumWeaponModSlots) == 0x0003D8, "Member 'ACrabPS::NumWeaponModSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, WeaponMods) == 0x0003E0, "Member 'ACrabPS::WeaponMods' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumAbilityModSlots) == 0x0003F0, "Member 'ACrabPS::NumAbilityModSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, AbilityMods) == 0x0003F8, "Member 'ACrabPS::AbilityMods' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumMeleeModSlots) == 0x000408, "Member 'ACrabPS::NumMeleeModSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, MeleeMods) == 0x000410, "Member 'ACrabPS::MeleeMods' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumPerkSlots) == 0x000420, "Member 'ACrabPS::NumPerkSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, Perks) == 0x000428, "Member 'ACrabPS::Perks' has a wrong offset!");
static_assert(offsetof(ACrabPS, Relics) == 0x000438, "Member 'ACrabPS::Relics' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumTimesSalvaged) == 0x000460, "Member 'ACrabPS::NumTimesSalvaged' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumShopPurchases) == 0x000464, "Member 'ACrabPS::NumShopPurchases' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumShopRerolls) == 0x000468, "Member 'ACrabPS::NumShopRerolls' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumTotemsDestroyed) == 0x00046C, "Member 'ACrabPS::NumTotemsDestroyed' has a wrong offset!");
static_assert(offsetof(ACrabPS, Crystals) == 0x000470, "Member 'ACrabPS::Crystals' has a wrong offset!");
static_assert(offsetof(ACrabPS, IslandRewardRarity) == 0x000478, "Member 'ACrabPS::IslandRewardRarity' has a wrong offset!");
static_assert(offsetof(ACrabPS, ParkourCheckpoint) == 0x000480, "Member 'ACrabPS::ParkourCheckpoint' has a wrong offset!");
static_assert(offsetof(ACrabPS, ChosenAnvils) == 0x000488, "Member 'ACrabPS::ChosenAnvils' has a wrong offset!");
static_assert(offsetof(ACrabPS, ChosenPortal) == 0x000498, "Member 'ACrabPS::ChosenPortal' has a wrong offset!");
static_assert(offsetof(ACrabPS, TotalTimeTaken) == 0x0004A0, "Member 'ACrabPS::TotalTimeTaken' has a wrong offset!");

// Class CrabChampions.CrabRamActionDA
// 0x0010 (0x0078 - 0x0068)
class UCrabRamActionDA final : public UCrabActionDA
{
public:
	float                                         RamSpeedMultiplier;                                // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabAOEDA*                             RamAOEDA;                                          // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabRamActionDA">();
	}
	static class UCrabRamActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabRamActionDA>();
	}
};
static_assert(alignof(UCrabRamActionDA) == 0x000008, "Wrong alignment on UCrabRamActionDA");
static_assert(sizeof(UCrabRamActionDA) == 0x000078, "Wrong size on UCrabRamActionDA");
static_assert(offsetof(UCrabRamActionDA, RamSpeedMultiplier) == 0x000068, "Member 'UCrabRamActionDA::RamSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabRamActionDA, RamAOEDA) == 0x000070, "Member 'UCrabRamActionDA::RamAOEDA' has a wrong offset!");

// Class CrabChampions.CrabRelicDA
// 0x0008 (0x00E0 - 0x00D8)
class UCrabRelicDA final : public UCrabInventoryDA
{
public:
	ECrabRelicType                                RelicType;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabRelicDA">();
	}
	static class UCrabRelicDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabRelicDA>();
	}
};
static_assert(alignof(UCrabRelicDA) == 0x000008, "Wrong alignment on UCrabRelicDA");
static_assert(sizeof(UCrabRelicDA) == 0x0000E0, "Wrong size on UCrabRelicDA");
static_assert(offsetof(UCrabRelicDA, RelicType) == 0x0000D8, "Member 'UCrabRelicDA::RelicType' has a wrong offset!");

// Class CrabChampions.CrabRevivalUI
// 0x0018 (0x02D0 - 0x02B8)
class UCrabRevivalUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerArrowImage;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PercentCompleteText;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabRevivalUI">();
	}
	static class UCrabRevivalUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabRevivalUI>();
	}
};
static_assert(alignof(UCrabRevivalUI) == 0x000008, "Wrong alignment on UCrabRevivalUI");
static_assert(sizeof(UCrabRevivalUI) == 0x0002D0, "Wrong size on UCrabRevivalUI");
static_assert(offsetof(UCrabRevivalUI, PlayerNameText) == 0x0002B8, "Member 'UCrabRevivalUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabRevivalUI, PlayerArrowImage) == 0x0002C0, "Member 'UCrabRevivalUI::PlayerArrowImage' has a wrong offset!");
static_assert(offsetof(UCrabRevivalUI, PercentCompleteText) == 0x0002C8, "Member 'UCrabRevivalUI::PercentCompleteText' has a wrong offset!");

// Class CrabChampions.CrabSettingsMenuUI
// 0x0030 (0x0400 - 0x03D0)
class UCrabSettingsMenuUI : public UCrabFocusMenuUI
{
public:
	class UCrabVideoMenuUI*                       VideoMenu;                                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSoundMenuUI*                       SoundMenu;                                         // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabControlsMenuUI*                    ControlsMenu;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                VideoButton;                                       // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SoundButton;                                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ControlsButton;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedControlsButton();
	void OnPressedSoundButton();
	void OnPressedVideoButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSettingsMenuUI">();
	}
	static class UCrabSettingsMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSettingsMenuUI>();
	}
};
static_assert(alignof(UCrabSettingsMenuUI) == 0x000008, "Wrong alignment on UCrabSettingsMenuUI");
static_assert(sizeof(UCrabSettingsMenuUI) == 0x000400, "Wrong size on UCrabSettingsMenuUI");
static_assert(offsetof(UCrabSettingsMenuUI, VideoMenu) == 0x0003D0, "Member 'UCrabSettingsMenuUI::VideoMenu' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, SoundMenu) == 0x0003D8, "Member 'UCrabSettingsMenuUI::SoundMenu' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, ControlsMenu) == 0x0003E0, "Member 'UCrabSettingsMenuUI::ControlsMenu' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, VideoButton) == 0x0003E8, "Member 'UCrabSettingsMenuUI::VideoButton' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, SoundButton) == 0x0003F0, "Member 'UCrabSettingsMenuUI::SoundButton' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, ControlsButton) == 0x0003F8, "Member 'UCrabSettingsMenuUI::ControlsButton' has a wrong offset!");

// Class CrabChampions.CrabSettingsSG
// 0x0140 (0x0168 - 0x0028)
class UCrabSettingsSG final : public USaveGame
{
public:
	class FString                                 DisplayMode;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Resolution;                                        // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResolutionQuality;                                 // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FPSLimit;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VSync;                                             // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldOfView;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GraphicsQuality;                                   // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponEffects;                                     // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AntiAliasingType;                                  // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sharpening;                                        // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MotionBlur;                                        // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShake;                                       // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hitmarkers;                                        // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageNumbers;                                     // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextChatVisibility;                                // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShowFPS;                                           // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PauseWhenLosingFocus;                              // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MasterVolume;                                      // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameplayVolume;                                    // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolume;                                       // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookSensitivity;                                   // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingSensitivityMultiplier;                       // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalLookInversion;                            // 0x014C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistStrength;                                 // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSlide;                                        // 0x0154(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabKeyBind>                   CrabKeyBinds;                                      // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSettingsSG">();
	}
	static class UCrabSettingsSG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSettingsSG>();
	}
};
static_assert(alignof(UCrabSettingsSG) == 0x000008, "Wrong alignment on UCrabSettingsSG");
static_assert(sizeof(UCrabSettingsSG) == 0x000168, "Wrong size on UCrabSettingsSG");
static_assert(offsetof(UCrabSettingsSG, DisplayMode) == 0x000028, "Member 'UCrabSettingsSG::DisplayMode' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, Resolution) == 0x000038, "Member 'UCrabSettingsSG::Resolution' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, ResolutionQuality) == 0x000048, "Member 'UCrabSettingsSG::ResolutionQuality' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, FPSLimit) == 0x000058, "Member 'UCrabSettingsSG::FPSLimit' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, VSync) == 0x000068, "Member 'UCrabSettingsSG::VSync' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, FieldOfView) == 0x000078, "Member 'UCrabSettingsSG::FieldOfView' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, GraphicsQuality) == 0x000088, "Member 'UCrabSettingsSG::GraphicsQuality' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, WeaponEffects) == 0x000098, "Member 'UCrabSettingsSG::WeaponEffects' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, AntiAliasingType) == 0x0000A8, "Member 'UCrabSettingsSG::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, Sharpening) == 0x0000B8, "Member 'UCrabSettingsSG::Sharpening' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, MotionBlur) == 0x0000C8, "Member 'UCrabSettingsSG::MotionBlur' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, CameraShake) == 0x0000D8, "Member 'UCrabSettingsSG::CameraShake' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, Hitmarkers) == 0x0000E8, "Member 'UCrabSettingsSG::Hitmarkers' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, DamageNumbers) == 0x0000F8, "Member 'UCrabSettingsSG::DamageNumbers' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, TextChatVisibility) == 0x000108, "Member 'UCrabSettingsSG::TextChatVisibility' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, ShowFPS) == 0x000118, "Member 'UCrabSettingsSG::ShowFPS' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, PauseWhenLosingFocus) == 0x000128, "Member 'UCrabSettingsSG::PauseWhenLosingFocus' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, MasterVolume) == 0x000138, "Member 'UCrabSettingsSG::MasterVolume' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, GameplayVolume) == 0x00013C, "Member 'UCrabSettingsSG::GameplayVolume' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, MusicVolume) == 0x000140, "Member 'UCrabSettingsSG::MusicVolume' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, LookSensitivity) == 0x000144, "Member 'UCrabSettingsSG::LookSensitivity' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, AimingSensitivityMultiplier) == 0x000148, "Member 'UCrabSettingsSG::AimingSensitivityMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, bVerticalLookInversion) == 0x00014C, "Member 'UCrabSettingsSG::bVerticalLookInversion' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, AimAssistStrength) == 0x000150, "Member 'UCrabSettingsSG::AimAssistStrength' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, bAutoSlide) == 0x000154, "Member 'UCrabSettingsSG::bAutoSlide' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, CrabKeyBinds) == 0x000158, "Member 'UCrabSettingsSG::CrabKeyBinds' has a wrong offset!");

// Class CrabChampions.CrabSG
// 0x0280 (0x02A8 - 0x0028)
class UCrabSG final : public USaveGame
{
public:
	int32                                         CrabChampionsVersion;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastSavedBackupA;                                 // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         XPToNextLevelUp;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabRankedWeapon>              RankedWeapons;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AccountLevel;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Keys;                                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDifficulty                               Difficulty;                                        // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CrabSkin;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrabChallenge>                 Challenges;                                        // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedWeapons;                                   // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedAbilities;                                 // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedMeleeWeapons;                              // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedWeaponMods;                                // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedAbilityMods;                               // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedMeleeMods;                                 // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedPerks;                                     // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedRelics;                                    // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EasyAttempts;                                      // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyWins;                                          // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyWinStreak;                                     // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyHighestIslandReached;                          // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAttempts;                                    // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalWins;                                        // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalWinStreak;                                   // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalHighestIslandReached;                        // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareAttempts;                                 // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareWins;                                     // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareWinStreak;                                // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareHighestIslandReached;                     // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosAttempts;                                // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosWins;                                    // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosWinStreak;                               // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosHighestIslandReached;                    // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabAutoSave                          AutoSave;                                          // 0x0158(0x0148)(NativeAccessSpecifierPublic)
	int32                                         ArcadeHighScore;                                   // 0x02A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HoldoutHighScore;                                  // 0x02A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSG">();
	}
	static class UCrabSG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSG>();
	}
};
static_assert(alignof(UCrabSG) == 0x000008, "Wrong alignment on UCrabSG");
static_assert(sizeof(UCrabSG) == 0x0002A8, "Wrong size on UCrabSG");
static_assert(offsetof(UCrabSG, CrabChampionsVersion) == 0x000028, "Member 'UCrabSG::CrabChampionsVersion' has a wrong offset!");
static_assert(offsetof(UCrabSG, bLastSavedBackupA) == 0x00002C, "Member 'UCrabSG::bLastSavedBackupA' has a wrong offset!");
static_assert(offsetof(UCrabSG, XPToNextLevelUp) == 0x000030, "Member 'UCrabSG::XPToNextLevelUp' has a wrong offset!");
static_assert(offsetof(UCrabSG, RankedWeapons) == 0x000038, "Member 'UCrabSG::RankedWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSG, AccountLevel) == 0x000048, "Member 'UCrabSG::AccountLevel' has a wrong offset!");
static_assert(offsetof(UCrabSG, Keys) == 0x00004C, "Member 'UCrabSG::Keys' has a wrong offset!");
static_assert(offsetof(UCrabSG, Difficulty) == 0x000050, "Member 'UCrabSG::Difficulty' has a wrong offset!");
static_assert(offsetof(UCrabSG, DifficultyModifiers) == 0x000058, "Member 'UCrabSG::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(UCrabSG, CrabSkin) == 0x000068, "Member 'UCrabSG::CrabSkin' has a wrong offset!");
static_assert(offsetof(UCrabSG, WeaponDA) == 0x000070, "Member 'UCrabSG::WeaponDA' has a wrong offset!");
static_assert(offsetof(UCrabSG, AbilityDA) == 0x000078, "Member 'UCrabSG::AbilityDA' has a wrong offset!");
static_assert(offsetof(UCrabSG, MeleeDA) == 0x000080, "Member 'UCrabSG::MeleeDA' has a wrong offset!");
static_assert(offsetof(UCrabSG, Challenges) == 0x000088, "Member 'UCrabSG::Challenges' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedWeapons) == 0x000098, "Member 'UCrabSG::UnlockedWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedAbilities) == 0x0000A8, "Member 'UCrabSG::UnlockedAbilities' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedMeleeWeapons) == 0x0000B8, "Member 'UCrabSG::UnlockedMeleeWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedWeaponMods) == 0x0000C8, "Member 'UCrabSG::UnlockedWeaponMods' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedAbilityMods) == 0x0000D8, "Member 'UCrabSG::UnlockedAbilityMods' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedMeleeMods) == 0x0000E8, "Member 'UCrabSG::UnlockedMeleeMods' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedPerks) == 0x0000F8, "Member 'UCrabSG::UnlockedPerks' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedRelics) == 0x000108, "Member 'UCrabSG::UnlockedRelics' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyAttempts) == 0x000118, "Member 'UCrabSG::EasyAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyWins) == 0x00011C, "Member 'UCrabSG::EasyWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyWinStreak) == 0x000120, "Member 'UCrabSG::EasyWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyHighestIslandReached) == 0x000124, "Member 'UCrabSG::EasyHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalAttempts) == 0x000128, "Member 'UCrabSG::NormalAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalWins) == 0x00012C, "Member 'UCrabSG::NormalWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalWinStreak) == 0x000130, "Member 'UCrabSG::NormalWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalHighestIslandReached) == 0x000134, "Member 'UCrabSG::NormalHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareAttempts) == 0x000138, "Member 'UCrabSG::NightmareAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareWins) == 0x00013C, "Member 'UCrabSG::NightmareWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareWinStreak) == 0x000140, "Member 'UCrabSG::NightmareWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareHighestIslandReached) == 0x000144, "Member 'UCrabSG::NightmareHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosAttempts) == 0x000148, "Member 'UCrabSG::UltraChaosAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosWins) == 0x00014C, "Member 'UCrabSG::UltraChaosWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosWinStreak) == 0x000150, "Member 'UCrabSG::UltraChaosWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosHighestIslandReached) == 0x000154, "Member 'UCrabSG::UltraChaosHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, AutoSave) == 0x000158, "Member 'UCrabSG::AutoSave' has a wrong offset!");
static_assert(offsetof(UCrabSG, ArcadeHighScore) == 0x0002A0, "Member 'UCrabSG::ArcadeHighScore' has a wrong offset!");
static_assert(offsetof(UCrabSG, HoldoutHighScore) == 0x0002A4, "Member 'UCrabSG::HoldoutHighScore' has a wrong offset!");

// Class CrabChampions.CrabShopPedestal
// 0x0048 (0x0268 - 0x0220)
class ACrabShopPedestal : public AActor
{
public:
	class UStaticMeshComponent*                   PedestalMesh;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PedestalWC;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PedestalMeshToSpawn;                               // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabShopPedestalUI>        ShopPedestalUIToSpawn;                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabLootPool                                 LootPool;                                          // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxPickups;                                        // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabCurrencyType                             CurrencyType;                                      // 0x0242(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabPickupDA*                          PickupToSpawn;                                     // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabPedestalInfo                      PedestalInfo;                                      // 0x0258(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastHidePedestalWC();
	void MulticastInitPedestalInfo(const struct FCrabPedestalInfo& NewPedestalInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabShopPedestal">();
	}
	static class ACrabShopPedestal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabShopPedestal>();
	}
};
static_assert(alignof(ACrabShopPedestal) == 0x000008, "Wrong alignment on ACrabShopPedestal");
static_assert(sizeof(ACrabShopPedestal) == 0x000268, "Wrong size on ACrabShopPedestal");
static_assert(offsetof(ACrabShopPedestal, PedestalMesh) == 0x000220, "Member 'ACrabShopPedestal::PedestalMesh' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PedestalWC) == 0x000228, "Member 'ACrabShopPedestal::PedestalWC' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PedestalMeshToSpawn) == 0x000230, "Member 'ACrabShopPedestal::PedestalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, ShopPedestalUIToSpawn) == 0x000238, "Member 'ACrabShopPedestal::ShopPedestalUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, LootPool) == 0x000240, "Member 'ACrabShopPedestal::LootPool' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, MaxPickups) == 0x000241, "Member 'ACrabShopPedestal::MaxPickups' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, CurrencyType) == 0x000242, "Member 'ACrabShopPedestal::CurrencyType' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PickupToSpawn) == 0x000248, "Member 'ACrabShopPedestal::PickupToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PedestalInfo) == 0x000258, "Member 'ACrabShopPedestal::PedestalInfo' has a wrong offset!");

// Class CrabChampions.CrabShopPedestalUI
// 0x0030 (0x02E8 - 0x02B8)
class UCrabShopPedestalUI : public UCrabUI
{
public:
	class UImage*                                 CrystalIconImage;                                  // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KeyIconImage;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HealthIconImage;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CostText;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DiscountText;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                DiscountBorder;                                    // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabShopPedestalUI">();
	}
	static class UCrabShopPedestalUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabShopPedestalUI>();
	}
};
static_assert(alignof(UCrabShopPedestalUI) == 0x000008, "Wrong alignment on UCrabShopPedestalUI");
static_assert(sizeof(UCrabShopPedestalUI) == 0x0002E8, "Wrong size on UCrabShopPedestalUI");
static_assert(offsetof(UCrabShopPedestalUI, CrystalIconImage) == 0x0002B8, "Member 'UCrabShopPedestalUI::CrystalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, KeyIconImage) == 0x0002C0, "Member 'UCrabShopPedestalUI::KeyIconImage' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, HealthIconImage) == 0x0002C8, "Member 'UCrabShopPedestalUI::HealthIconImage' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, CostText) == 0x0002D0, "Member 'UCrabShopPedestalUI::CostText' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, DiscountText) == 0x0002D8, "Member 'UCrabShopPedestalUI::DiscountText' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, DiscountBorder) == 0x0002E0, "Member 'UCrabShopPedestalUI::DiscountBorder' has a wrong offset!");

// Class CrabChampions.CrabSliderUI
// 0x0018 (0x02D0 - 0x02B8)
class UCrabSliderUI : public UCrabUI
{
public:
	class USlider*                                MainSlider;                                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           SliderPB;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SliderText;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMainSliderValueChanged(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSliderUI">();
	}
	static class UCrabSliderUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSliderUI>();
	}
};
static_assert(alignof(UCrabSliderUI) == 0x000008, "Wrong alignment on UCrabSliderUI");
static_assert(sizeof(UCrabSliderUI) == 0x0002D0, "Wrong size on UCrabSliderUI");
static_assert(offsetof(UCrabSliderUI, MainSlider) == 0x0002B8, "Member 'UCrabSliderUI::MainSlider' has a wrong offset!");
static_assert(offsetof(UCrabSliderUI, SliderPB) == 0x0002C0, "Member 'UCrabSliderUI::SliderPB' has a wrong offset!");
static_assert(offsetof(UCrabSliderUI, SliderText) == 0x0002C8, "Member 'UCrabSliderUI::SliderText' has a wrong offset!");

// Class CrabChampions.CrabSoundMenuUI
// 0x0028 (0x02E0 - 0x02B8)
class UCrabSoundMenuUI : public UCrabUI
{
public:
	TArray<class UWidget*>                        SoundMenuFocusableWidgetArray;                     // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          MasterVolumeSlider;                                // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          GameplayVolumeSlider;                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          MusicVolumeSlider;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSoundMenuUI">();
	}
	static class UCrabSoundMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSoundMenuUI>();
	}
};
static_assert(alignof(UCrabSoundMenuUI) == 0x000008, "Wrong alignment on UCrabSoundMenuUI");
static_assert(sizeof(UCrabSoundMenuUI) == 0x0002E0, "Wrong size on UCrabSoundMenuUI");
static_assert(offsetof(UCrabSoundMenuUI, SoundMenuFocusableWidgetArray) == 0x0002B8, "Member 'UCrabSoundMenuUI::SoundMenuFocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabSoundMenuUI, MasterVolumeSlider) == 0x0002C8, "Member 'UCrabSoundMenuUI::MasterVolumeSlider' has a wrong offset!");
static_assert(offsetof(UCrabSoundMenuUI, GameplayVolumeSlider) == 0x0002D0, "Member 'UCrabSoundMenuUI::GameplayVolumeSlider' has a wrong offset!");
static_assert(offsetof(UCrabSoundMenuUI, MusicVolumeSlider) == 0x0002D8, "Member 'UCrabSoundMenuUI::MusicVolumeSlider' has a wrong offset!");

// Class CrabChampions.CrabSpawnablesDA
// 0x06F0 (0x0720 - 0x0030)
class UCrabSpawnablesDA final : public UDataAsset
{
public:
	class UMaterialInterface*                     IceMat;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceSound;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceThawFX;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireSound;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningSound;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChainLightningFX;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PoisonSound;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ArcaneFX;                                          // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ArcaneSound;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ShieldBreakFX;                                     // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ShieldBreakSound;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         GenericExplosionFX;                                // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GenericExplosionSound;                             // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceExplosionFX;                                    // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceExplosionSound;                                 // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FireExplosionFX;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireExplosionSound;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightningExplosionFX;                              // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningExplosionSound;                           // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PoisonExplosionFX;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PoisonExplosionSound;                              // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCrabWeaponDA*>                  Weapons;                                           // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabAbilityDA*>                 Abilities;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabMeleeDA*>                   MeleeWeapons;                                      // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabWeaponModDA*>               WeaponMods;                                        // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabAbilityModDA*>              AbilityMods;                                       // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabMeleeModDA*>                MeleeMods;                                         // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabPerkDA*>                    Perks;                                             // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabRelicDA*>                   Relics;                                            // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabConsumableDA*>              Consumables;                                       // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabHealthPickup>          HealthPickup;                                      // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabHealthPickup>          ScavengerHealthPickup;                             // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabCrystalPickup>         CrystalPickup;                                     // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BananaAmbienceFX;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CriticalBlastFX;                                   // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CriticalBlastSound;                                // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      TimeBoltDA;                                        // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      UltraShotDA;                                       // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ReloadArcDA;                                       // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      LinkDA;                                            // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      DrillDA;                                           // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      BubbleDA;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      PumpkinDA;                                         // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      DaggerDA;                                          // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      PiercingWaveDA;                                    // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ArcaneBlastDA;                                     // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ShotgunDA;                                         // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      MaceBallDA;                                        // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      FireworkDA;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ThornDA;                                           // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      BeamDA;                                            // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      SparkDA;                                           // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ProximityBarrageDA;                                // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      HomingBladeDA;                                     // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      BombDA;                                            // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      TorpedoDA;                                         // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      FireballDA;                                        // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      SharpenedAxeDA;                                    // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      TriangleDA;                                        // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      SpinningBladeDA;                                   // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ScytheDA;                                          // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          BarrelRainBarrel;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          LandmineRainLandmine;                              // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          Landmine;                                          // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          HomingBarrel;                                      // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          SporeMushroom;                                     // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          UltraMushroom;                                     // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            CrimsonHazeDamageArea;                             // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            GiantDrillDamageArea;                              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            ScytheVortexDamageArea;                            // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            CrystalBarrageDamageArea;                          // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnergyRingDamageArea;                              // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            IceStormDamageArea;                                // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            FireStormDamageArea;                               // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            LightningStormDamageArea;                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            PoisonStormDamageArea;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            IceExplosionDamageArea;                            // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            FireExplosionDamageArea;                           // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            LightningExplosionDamageArea;                      // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            PoisonExplosionDamageArea;                         // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                MeteorShowerStrike;                                // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                CriticalArrow;                                     // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                IceStrike;                                         // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                FireStrike;                                        // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                LightningStrike;                                   // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                PoisonStrike;                                      // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                SpikeStrike;                                       // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                CrystalStrike;                                     // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                CriticalLightning;                                 // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SonicBoomFX;                                       // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SonicBoomSound;                                    // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         HealFX;                                            // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HealSound;                                         // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         MaxHealthUpFX;                                     // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MaxHealthUpSound;                                  // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ShockwaveFX;                                       // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ShockwaveSound;                                    // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BulletproofFX;                                     // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BulletproofSound;                                  // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceAuraFX;                                         // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceAuraSound;                                      // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FireAuraFX;                                        // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireAuraSound;                                     // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightningAuraFX;                                   // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningAuraSound;                                // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PoisonAuraFX;                                      // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PoisonAuraSound;                                   // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         RareTreasureFX;                                    // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              RareTreasureSound;                                 // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ExplodingEnemiesFX;                                // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ExplodingEnemiesSound;                             // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceDashFX;                                         // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceDashSound;                                      // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightningDashFX;                                   // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningDashSound;                                // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PowerslideFX;                                      // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PowerslideSound;                                   // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPhysicsActor>          LobbyPhysicsCrown;                                 // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                SentryTurret;                                      // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                SniperTurret;                                      // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                MortarTurret;                                      // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                WaveTurret;                                        // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                BeamTurret;                                        // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabTotem>>         IslandTotems;                                      // 0x0450(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabTotem>>         ShopTotems;                                        // 0x0460(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTotem>                 ContractTotem;                                     // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTotem>                 XLTotem;                                           // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTotem>                 RerollTotem;                                       // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      EnemyMirroredProjectileDA;                         // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      EnemyShrapnelProjectileDA;                         // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      EnemyHomingThornDA;                                // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          EnemyHomingBarrel;                                 // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyIceDamageArea;                                // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyFireDamageArea;                               // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyLightningDamageArea;                          // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyPoisonDamageArea;                             // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyEnergyRingDamageArea;                         // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                EnemySpikeStrike;                                  // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabHarvestArea>           RevivalHarvestArea;                                // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabHarvestArea>>   HarvestAreas;                                      // 0x04E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  DemolitionDestructibles;                           // 0x04F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  ParkourDestructibles;                              // 0x0500(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          HealthRock;                                        // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          CrystalAsteroid;                                   // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabSpawnPoint>            RewardSpawnPoint;                                  // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 DamageChest;                                       // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 CriticalChest;                                     // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 ElementalChest;                                    // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SpeedChest;                                        // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 LuckChest;                                         // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 HealthChest;                                       // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 EconomyChest;                                      // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SkillChest;                                        // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 GreedChest;                                        // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 UpgradeChest;                                      // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 RandomChest;                                       // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabAnvil>                 Anvil;                                             // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 RelicChest;                                        // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SpikedChest;                                       // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 EpicChest;                                         // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 LegendaryChest;                                    // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 RegenerationChest;                                 // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 KeyChest;                                          // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SecretChest;                                       // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CommonPickupSound;                                 // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EpicPickupSound;                                   // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LegendaryPickupSound;                              // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              StreamerLootUpgradePickupSound;                    // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PurchaseSound;                                     // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BossMusic;                                         // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              VictoryMusic;                                      // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabShopPedestal>          ShopPedestal;                                      // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabShopPedestal>          InfiniteShopPedestal;                              // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabEnemyC>                TargetDummy;                                       // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              FindSafeSpawnLocsEnvQuery;                         // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                NewRunPortal;                                      // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ContinueRunPortal;                                 // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ArenaPortal;                                       // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                HordePortal;                                       // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                DemolitionPortal;                                  // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ParkourPortal;                                     // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ShopPortal;                                        // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ElitePortal;                                       // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                BossPortal;                                        // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                BiomePortal;                                       // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                CrabIslandPortal;                                  // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                LoopPortal;                                        // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DamageIcon;                                        // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            CriticalIcon;                                      // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ElementalIcon;                                     // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SpeedIcon;                                         // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            LuckIcon;                                          // 0x0698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HealthIcon;                                        // 0x06A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            EconomyIcon;                                       // 0x06A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SkillIcon;                                         // 0x06B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GreedIcon;                                         // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            UpgradeIcon;                                       // 0x06C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RandomIcon;                                        // 0x06C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            AnvilIcon;                                         // 0x06D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RelicIcon;                                         // 0x06D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SpikedIcon;                                        // 0x06E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BronzeMedalIcon;                                   // 0x06E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SilverMedalIcon;                                   // 0x06F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GoldMedalIcon;                                     // 0x06F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SapphireMedalIcon;                                 // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EmeraldMedalIcon;                                  // 0x0708(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RubyMedalIcon;                                     // 0x0710(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DiamondMedalIcon;                                  // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpawnablesDA">();
	}
	static class UCrabSpawnablesDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSpawnablesDA>();
	}
};
static_assert(alignof(UCrabSpawnablesDA) == 0x000008, "Wrong alignment on UCrabSpawnablesDA");
static_assert(sizeof(UCrabSpawnablesDA) == 0x000720, "Wrong size on UCrabSpawnablesDA");
static_assert(offsetof(UCrabSpawnablesDA, IceMat) == 0x000030, "Member 'UCrabSpawnablesDA::IceMat' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceSound) == 0x000038, "Member 'UCrabSpawnablesDA::IceSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceThawFX) == 0x000040, "Member 'UCrabSpawnablesDA::IceThawFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireSound) == 0x000048, "Member 'UCrabSpawnablesDA::FireSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningSound) == 0x000050, "Member 'UCrabSpawnablesDA::LightningSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ChainLightningFX) == 0x000058, "Member 'UCrabSpawnablesDA::ChainLightningFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonSound) == 0x000060, "Member 'UCrabSpawnablesDA::PoisonSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArcaneFX) == 0x000068, "Member 'UCrabSpawnablesDA::ArcaneFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArcaneSound) == 0x000070, "Member 'UCrabSpawnablesDA::ArcaneSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShieldBreakFX) == 0x000078, "Member 'UCrabSpawnablesDA::ShieldBreakFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShieldBreakSound) == 0x000080, "Member 'UCrabSpawnablesDA::ShieldBreakSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GenericExplosionFX) == 0x000088, "Member 'UCrabSpawnablesDA::GenericExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GenericExplosionSound) == 0x000090, "Member 'UCrabSpawnablesDA::GenericExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceExplosionFX) == 0x000098, "Member 'UCrabSpawnablesDA::IceExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceExplosionSound) == 0x0000A0, "Member 'UCrabSpawnablesDA::IceExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireExplosionFX) == 0x0000A8, "Member 'UCrabSpawnablesDA::FireExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireExplosionSound) == 0x0000B0, "Member 'UCrabSpawnablesDA::FireExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningExplosionFX) == 0x0000B8, "Member 'UCrabSpawnablesDA::LightningExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningExplosionSound) == 0x0000C0, "Member 'UCrabSpawnablesDA::LightningExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonExplosionFX) == 0x0000C8, "Member 'UCrabSpawnablesDA::PoisonExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonExplosionSound) == 0x0000D0, "Member 'UCrabSpawnablesDA::PoisonExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Weapons) == 0x0000D8, "Member 'UCrabSpawnablesDA::Weapons' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Abilities) == 0x0000E8, "Member 'UCrabSpawnablesDA::Abilities' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MeleeWeapons) == 0x0000F8, "Member 'UCrabSpawnablesDA::MeleeWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, WeaponMods) == 0x000108, "Member 'UCrabSpawnablesDA::WeaponMods' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, AbilityMods) == 0x000118, "Member 'UCrabSpawnablesDA::AbilityMods' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MeleeMods) == 0x000128, "Member 'UCrabSpawnablesDA::MeleeMods' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Perks) == 0x000138, "Member 'UCrabSpawnablesDA::Perks' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Relics) == 0x000148, "Member 'UCrabSpawnablesDA::Relics' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Consumables) == 0x000158, "Member 'UCrabSpawnablesDA::Consumables' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthPickup) == 0x000168, "Member 'UCrabSpawnablesDA::HealthPickup' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ScavengerHealthPickup) == 0x000170, "Member 'UCrabSpawnablesDA::ScavengerHealthPickup' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalPickup) == 0x000178, "Member 'UCrabSpawnablesDA::CrystalPickup' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BananaAmbienceFX) == 0x000180, "Member 'UCrabSpawnablesDA::BananaAmbienceFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalBlastFX) == 0x000188, "Member 'UCrabSpawnablesDA::CriticalBlastFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalBlastSound) == 0x000190, "Member 'UCrabSpawnablesDA::CriticalBlastSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TimeBoltDA) == 0x000198, "Member 'UCrabSpawnablesDA::TimeBoltDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UltraShotDA) == 0x0001A0, "Member 'UCrabSpawnablesDA::UltraShotDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ReloadArcDA) == 0x0001A8, "Member 'UCrabSpawnablesDA::ReloadArcDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LinkDA) == 0x0001B0, "Member 'UCrabSpawnablesDA::LinkDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DrillDA) == 0x0001B8, "Member 'UCrabSpawnablesDA::DrillDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BubbleDA) == 0x0001C0, "Member 'UCrabSpawnablesDA::BubbleDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PumpkinDA) == 0x0001C8, "Member 'UCrabSpawnablesDA::PumpkinDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DaggerDA) == 0x0001D0, "Member 'UCrabSpawnablesDA::DaggerDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PiercingWaveDA) == 0x0001D8, "Member 'UCrabSpawnablesDA::PiercingWaveDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArcaneBlastDA) == 0x0001E0, "Member 'UCrabSpawnablesDA::ArcaneBlastDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShotgunDA) == 0x0001E8, "Member 'UCrabSpawnablesDA::ShotgunDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MaceBallDA) == 0x0001F0, "Member 'UCrabSpawnablesDA::MaceBallDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireworkDA) == 0x0001F8, "Member 'UCrabSpawnablesDA::FireworkDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ThornDA) == 0x000200, "Member 'UCrabSpawnablesDA::ThornDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BeamDA) == 0x000208, "Member 'UCrabSpawnablesDA::BeamDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SparkDA) == 0x000210, "Member 'UCrabSpawnablesDA::SparkDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ProximityBarrageDA) == 0x000218, "Member 'UCrabSpawnablesDA::ProximityBarrageDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HomingBladeDA) == 0x000220, "Member 'UCrabSpawnablesDA::HomingBladeDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BombDA) == 0x000228, "Member 'UCrabSpawnablesDA::BombDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TorpedoDA) == 0x000230, "Member 'UCrabSpawnablesDA::TorpedoDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireballDA) == 0x000238, "Member 'UCrabSpawnablesDA::FireballDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SharpenedAxeDA) == 0x000240, "Member 'UCrabSpawnablesDA::SharpenedAxeDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TriangleDA) == 0x000248, "Member 'UCrabSpawnablesDA::TriangleDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpinningBladeDA) == 0x000250, "Member 'UCrabSpawnablesDA::SpinningBladeDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ScytheDA) == 0x000258, "Member 'UCrabSpawnablesDA::ScytheDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BarrelRainBarrel) == 0x000260, "Member 'UCrabSpawnablesDA::BarrelRainBarrel' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LandmineRainLandmine) == 0x000268, "Member 'UCrabSpawnablesDA::LandmineRainLandmine' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Landmine) == 0x000270, "Member 'UCrabSpawnablesDA::Landmine' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HomingBarrel) == 0x000278, "Member 'UCrabSpawnablesDA::HomingBarrel' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SporeMushroom) == 0x000280, "Member 'UCrabSpawnablesDA::SporeMushroom' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UltraMushroom) == 0x000288, "Member 'UCrabSpawnablesDA::UltraMushroom' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrimsonHazeDamageArea) == 0x000290, "Member 'UCrabSpawnablesDA::CrimsonHazeDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GiantDrillDamageArea) == 0x000298, "Member 'UCrabSpawnablesDA::GiantDrillDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ScytheVortexDamageArea) == 0x0002A0, "Member 'UCrabSpawnablesDA::ScytheVortexDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalBarrageDamageArea) == 0x0002A8, "Member 'UCrabSpawnablesDA::CrystalBarrageDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnergyRingDamageArea) == 0x0002B0, "Member 'UCrabSpawnablesDA::EnergyRingDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceStormDamageArea) == 0x0002B8, "Member 'UCrabSpawnablesDA::IceStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireStormDamageArea) == 0x0002C0, "Member 'UCrabSpawnablesDA::FireStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningStormDamageArea) == 0x0002C8, "Member 'UCrabSpawnablesDA::LightningStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonStormDamageArea) == 0x0002D0, "Member 'UCrabSpawnablesDA::PoisonStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceExplosionDamageArea) == 0x0002D8, "Member 'UCrabSpawnablesDA::IceExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireExplosionDamageArea) == 0x0002E0, "Member 'UCrabSpawnablesDA::FireExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningExplosionDamageArea) == 0x0002E8, "Member 'UCrabSpawnablesDA::LightningExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonExplosionDamageArea) == 0x0002F0, "Member 'UCrabSpawnablesDA::PoisonExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MeteorShowerStrike) == 0x0002F8, "Member 'UCrabSpawnablesDA::MeteorShowerStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalArrow) == 0x000300, "Member 'UCrabSpawnablesDA::CriticalArrow' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceStrike) == 0x000308, "Member 'UCrabSpawnablesDA::IceStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireStrike) == 0x000310, "Member 'UCrabSpawnablesDA::FireStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningStrike) == 0x000318, "Member 'UCrabSpawnablesDA::LightningStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonStrike) == 0x000320, "Member 'UCrabSpawnablesDA::PoisonStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpikeStrike) == 0x000328, "Member 'UCrabSpawnablesDA::SpikeStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalStrike) == 0x000330, "Member 'UCrabSpawnablesDA::CrystalStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalLightning) == 0x000338, "Member 'UCrabSpawnablesDA::CriticalLightning' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SonicBoomFX) == 0x000340, "Member 'UCrabSpawnablesDA::SonicBoomFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SonicBoomSound) == 0x000348, "Member 'UCrabSpawnablesDA::SonicBoomSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealFX) == 0x000350, "Member 'UCrabSpawnablesDA::HealFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealSound) == 0x000358, "Member 'UCrabSpawnablesDA::HealSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MaxHealthUpFX) == 0x000360, "Member 'UCrabSpawnablesDA::MaxHealthUpFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MaxHealthUpSound) == 0x000368, "Member 'UCrabSpawnablesDA::MaxHealthUpSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShockwaveFX) == 0x000370, "Member 'UCrabSpawnablesDA::ShockwaveFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShockwaveSound) == 0x000378, "Member 'UCrabSpawnablesDA::ShockwaveSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BulletproofFX) == 0x000380, "Member 'UCrabSpawnablesDA::BulletproofFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BulletproofSound) == 0x000388, "Member 'UCrabSpawnablesDA::BulletproofSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceAuraFX) == 0x000390, "Member 'UCrabSpawnablesDA::IceAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceAuraSound) == 0x000398, "Member 'UCrabSpawnablesDA::IceAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireAuraFX) == 0x0003A0, "Member 'UCrabSpawnablesDA::FireAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireAuraSound) == 0x0003A8, "Member 'UCrabSpawnablesDA::FireAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningAuraFX) == 0x0003B0, "Member 'UCrabSpawnablesDA::LightningAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningAuraSound) == 0x0003B8, "Member 'UCrabSpawnablesDA::LightningAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonAuraFX) == 0x0003C0, "Member 'UCrabSpawnablesDA::PoisonAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonAuraSound) == 0x0003C8, "Member 'UCrabSpawnablesDA::PoisonAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RareTreasureFX) == 0x0003D0, "Member 'UCrabSpawnablesDA::RareTreasureFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RareTreasureSound) == 0x0003D8, "Member 'UCrabSpawnablesDA::RareTreasureSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ExplodingEnemiesFX) == 0x0003E0, "Member 'UCrabSpawnablesDA::ExplodingEnemiesFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ExplodingEnemiesSound) == 0x0003E8, "Member 'UCrabSpawnablesDA::ExplodingEnemiesSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceDashFX) == 0x0003F0, "Member 'UCrabSpawnablesDA::IceDashFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceDashSound) == 0x0003F8, "Member 'UCrabSpawnablesDA::IceDashSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningDashFX) == 0x000400, "Member 'UCrabSpawnablesDA::LightningDashFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningDashSound) == 0x000408, "Member 'UCrabSpawnablesDA::LightningDashSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PowerslideFX) == 0x000410, "Member 'UCrabSpawnablesDA::PowerslideFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PowerslideSound) == 0x000418, "Member 'UCrabSpawnablesDA::PowerslideSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LobbyPhysicsCrown) == 0x000420, "Member 'UCrabSpawnablesDA::LobbyPhysicsCrown' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SentryTurret) == 0x000428, "Member 'UCrabSpawnablesDA::SentryTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SniperTurret) == 0x000430, "Member 'UCrabSpawnablesDA::SniperTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MortarTurret) == 0x000438, "Member 'UCrabSpawnablesDA::MortarTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, WaveTurret) == 0x000440, "Member 'UCrabSpawnablesDA::WaveTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BeamTurret) == 0x000448, "Member 'UCrabSpawnablesDA::BeamTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IslandTotems) == 0x000450, "Member 'UCrabSpawnablesDA::IslandTotems' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShopTotems) == 0x000460, "Member 'UCrabSpawnablesDA::ShopTotems' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ContractTotem) == 0x000470, "Member 'UCrabSpawnablesDA::ContractTotem' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, XLTotem) == 0x000478, "Member 'UCrabSpawnablesDA::XLTotem' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RerollTotem) == 0x000480, "Member 'UCrabSpawnablesDA::RerollTotem' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyMirroredProjectileDA) == 0x000488, "Member 'UCrabSpawnablesDA::EnemyMirroredProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyShrapnelProjectileDA) == 0x000490, "Member 'UCrabSpawnablesDA::EnemyShrapnelProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyHomingThornDA) == 0x000498, "Member 'UCrabSpawnablesDA::EnemyHomingThornDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyHomingBarrel) == 0x0004A0, "Member 'UCrabSpawnablesDA::EnemyHomingBarrel' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyIceDamageArea) == 0x0004A8, "Member 'UCrabSpawnablesDA::EnemyIceDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyFireDamageArea) == 0x0004B0, "Member 'UCrabSpawnablesDA::EnemyFireDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyLightningDamageArea) == 0x0004B8, "Member 'UCrabSpawnablesDA::EnemyLightningDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyPoisonDamageArea) == 0x0004C0, "Member 'UCrabSpawnablesDA::EnemyPoisonDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyEnergyRingDamageArea) == 0x0004C8, "Member 'UCrabSpawnablesDA::EnemyEnergyRingDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemySpikeStrike) == 0x0004D0, "Member 'UCrabSpawnablesDA::EnemySpikeStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RevivalHarvestArea) == 0x0004D8, "Member 'UCrabSpawnablesDA::RevivalHarvestArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HarvestAreas) == 0x0004E0, "Member 'UCrabSpawnablesDA::HarvestAreas' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DemolitionDestructibles) == 0x0004F0, "Member 'UCrabSpawnablesDA::DemolitionDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ParkourDestructibles) == 0x000500, "Member 'UCrabSpawnablesDA::ParkourDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthRock) == 0x000510, "Member 'UCrabSpawnablesDA::HealthRock' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalAsteroid) == 0x000518, "Member 'UCrabSpawnablesDA::CrystalAsteroid' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RewardSpawnPoint) == 0x000520, "Member 'UCrabSpawnablesDA::RewardSpawnPoint' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DamageChest) == 0x000528, "Member 'UCrabSpawnablesDA::DamageChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalChest) == 0x000530, "Member 'UCrabSpawnablesDA::CriticalChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ElementalChest) == 0x000538, "Member 'UCrabSpawnablesDA::ElementalChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpeedChest) == 0x000540, "Member 'UCrabSpawnablesDA::SpeedChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LuckChest) == 0x000548, "Member 'UCrabSpawnablesDA::LuckChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthChest) == 0x000550, "Member 'UCrabSpawnablesDA::HealthChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EconomyChest) == 0x000558, "Member 'UCrabSpawnablesDA::EconomyChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SkillChest) == 0x000560, "Member 'UCrabSpawnablesDA::SkillChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GreedChest) == 0x000568, "Member 'UCrabSpawnablesDA::GreedChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UpgradeChest) == 0x000570, "Member 'UCrabSpawnablesDA::UpgradeChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RandomChest) == 0x000578, "Member 'UCrabSpawnablesDA::RandomChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Anvil) == 0x000580, "Member 'UCrabSpawnablesDA::Anvil' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RelicChest) == 0x000588, "Member 'UCrabSpawnablesDA::RelicChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpikedChest) == 0x000590, "Member 'UCrabSpawnablesDA::SpikedChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EpicChest) == 0x000598, "Member 'UCrabSpawnablesDA::EpicChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LegendaryChest) == 0x0005A0, "Member 'UCrabSpawnablesDA::LegendaryChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RegenerationChest) == 0x0005A8, "Member 'UCrabSpawnablesDA::RegenerationChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, KeyChest) == 0x0005B0, "Member 'UCrabSpawnablesDA::KeyChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SecretChest) == 0x0005B8, "Member 'UCrabSpawnablesDA::SecretChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CommonPickupSound) == 0x0005C0, "Member 'UCrabSpawnablesDA::CommonPickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EpicPickupSound) == 0x0005C8, "Member 'UCrabSpawnablesDA::EpicPickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LegendaryPickupSound) == 0x0005D0, "Member 'UCrabSpawnablesDA::LegendaryPickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, StreamerLootUpgradePickupSound) == 0x0005D8, "Member 'UCrabSpawnablesDA::StreamerLootUpgradePickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PurchaseSound) == 0x0005E0, "Member 'UCrabSpawnablesDA::PurchaseSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BossMusic) == 0x0005E8, "Member 'UCrabSpawnablesDA::BossMusic' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, VictoryMusic) == 0x0005F0, "Member 'UCrabSpawnablesDA::VictoryMusic' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShopPedestal) == 0x0005F8, "Member 'UCrabSpawnablesDA::ShopPedestal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, InfiniteShopPedestal) == 0x000600, "Member 'UCrabSpawnablesDA::InfiniteShopPedestal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TargetDummy) == 0x000608, "Member 'UCrabSpawnablesDA::TargetDummy' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FindSafeSpawnLocsEnvQuery) == 0x000610, "Member 'UCrabSpawnablesDA::FindSafeSpawnLocsEnvQuery' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, NewRunPortal) == 0x000618, "Member 'UCrabSpawnablesDA::NewRunPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ContinueRunPortal) == 0x000620, "Member 'UCrabSpawnablesDA::ContinueRunPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArenaPortal) == 0x000628, "Member 'UCrabSpawnablesDA::ArenaPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HordePortal) == 0x000630, "Member 'UCrabSpawnablesDA::HordePortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DemolitionPortal) == 0x000638, "Member 'UCrabSpawnablesDA::DemolitionPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ParkourPortal) == 0x000640, "Member 'UCrabSpawnablesDA::ParkourPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShopPortal) == 0x000648, "Member 'UCrabSpawnablesDA::ShopPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ElitePortal) == 0x000650, "Member 'UCrabSpawnablesDA::ElitePortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BossPortal) == 0x000658, "Member 'UCrabSpawnablesDA::BossPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BiomePortal) == 0x000660, "Member 'UCrabSpawnablesDA::BiomePortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrabIslandPortal) == 0x000668, "Member 'UCrabSpawnablesDA::CrabIslandPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LoopPortal) == 0x000670, "Member 'UCrabSpawnablesDA::LoopPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DamageIcon) == 0x000678, "Member 'UCrabSpawnablesDA::DamageIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalIcon) == 0x000680, "Member 'UCrabSpawnablesDA::CriticalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ElementalIcon) == 0x000688, "Member 'UCrabSpawnablesDA::ElementalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpeedIcon) == 0x000690, "Member 'UCrabSpawnablesDA::SpeedIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LuckIcon) == 0x000698, "Member 'UCrabSpawnablesDA::LuckIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthIcon) == 0x0006A0, "Member 'UCrabSpawnablesDA::HealthIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EconomyIcon) == 0x0006A8, "Member 'UCrabSpawnablesDA::EconomyIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SkillIcon) == 0x0006B0, "Member 'UCrabSpawnablesDA::SkillIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GreedIcon) == 0x0006B8, "Member 'UCrabSpawnablesDA::GreedIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UpgradeIcon) == 0x0006C0, "Member 'UCrabSpawnablesDA::UpgradeIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RandomIcon) == 0x0006C8, "Member 'UCrabSpawnablesDA::RandomIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, AnvilIcon) == 0x0006D0, "Member 'UCrabSpawnablesDA::AnvilIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RelicIcon) == 0x0006D8, "Member 'UCrabSpawnablesDA::RelicIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpikedIcon) == 0x0006E0, "Member 'UCrabSpawnablesDA::SpikedIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BronzeMedalIcon) == 0x0006E8, "Member 'UCrabSpawnablesDA::BronzeMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SilverMedalIcon) == 0x0006F0, "Member 'UCrabSpawnablesDA::SilverMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GoldMedalIcon) == 0x0006F8, "Member 'UCrabSpawnablesDA::GoldMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SapphireMedalIcon) == 0x000700, "Member 'UCrabSpawnablesDA::SapphireMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EmeraldMedalIcon) == 0x000708, "Member 'UCrabSpawnablesDA::EmeraldMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RubyMedalIcon) == 0x000710, "Member 'UCrabSpawnablesDA::RubyMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DiamondMedalIcon) == 0x000718, "Member 'UCrabSpawnablesDA::DiamondMedalIcon' has a wrong offset!");

// Class CrabChampions.CrabSpawnActionDA
// 0x0018 (0x0080 - 0x0068)
class UCrabSpawnActionDA final : public UCrabActionDA
{
public:
	TArray<TSubclassOf<class ACrabEnemyC>>        LesserEnemiesToSpawn;                              // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnedLesserEnemies;                           // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpawnActionDA">();
	}
	static class UCrabSpawnActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSpawnActionDA>();
	}
};
static_assert(alignof(UCrabSpawnActionDA) == 0x000008, "Wrong alignment on UCrabSpawnActionDA");
static_assert(sizeof(UCrabSpawnActionDA) == 0x000080, "Wrong size on UCrabSpawnActionDA");
static_assert(offsetof(UCrabSpawnActionDA, LesserEnemiesToSpawn) == 0x000068, "Member 'UCrabSpawnActionDA::LesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabSpawnActionDA, MaxSpawnedLesserEnemies) == 0x000078, "Member 'UCrabSpawnActionDA::MaxSpawnedLesserEnemies' has a wrong offset!");

// Class CrabChampions.CrabSpawnPoint
// 0x0018 (0x0238 - 0x0220)
class ACrabSpawnPoint : public AActor
{
public:
	class USceneComponent*                        SpawnPointRoot;                                    // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabSpawnPointType                           SpawnPointType;                                    // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0xF];                                      // 0x0229(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpawnPoint">();
	}
	static class ACrabSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabSpawnPoint>();
	}
};
static_assert(alignof(ACrabSpawnPoint) == 0x000008, "Wrong alignment on ACrabSpawnPoint");
static_assert(sizeof(ACrabSpawnPoint) == 0x000238, "Wrong size on ACrabSpawnPoint");
static_assert(offsetof(ACrabSpawnPoint, SpawnPointRoot) == 0x000220, "Member 'ACrabSpawnPoint::SpawnPointRoot' has a wrong offset!");
static_assert(offsetof(ACrabSpawnPoint, SpawnPointType) == 0x000228, "Member 'ACrabSpawnPoint::SpawnPointType' has a wrong offset!");

// Class CrabChampions.CrabSpectatorC
// 0x0020 (0x02A0 - 0x0280)
class ACrabSpectatorC final : public APawn
{
public:
	class USpringArmComponent*                    CameraSpringArm;                                   // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       SpectatorCamera;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           SpectatingPlayer;                                  // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientInitSpectatorC(class ACrabPlayerC* EliminatedPlayerToSpectate);
	void ClientSpectatePlayer(class ACrabPlayerC* PlayerToSpectate, bool bShowSpectatingUI);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpectatorC">();
	}
	static class ACrabSpectatorC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabSpectatorC>();
	}
};
static_assert(alignof(ACrabSpectatorC) == 0x000008, "Wrong alignment on ACrabSpectatorC");
static_assert(sizeof(ACrabSpectatorC) == 0x0002A0, "Wrong size on ACrabSpectatorC");
static_assert(offsetof(ACrabSpectatorC, CameraSpringArm) == 0x000280, "Member 'ACrabSpectatorC::CameraSpringArm' has a wrong offset!");
static_assert(offsetof(ACrabSpectatorC, SpectatorCamera) == 0x000288, "Member 'ACrabSpectatorC::SpectatorCamera' has a wrong offset!");
static_assert(offsetof(ACrabSpectatorC, SpectatingPlayer) == 0x000290, "Member 'ACrabSpectatorC::SpectatingPlayer' has a wrong offset!");

// Class CrabChampions.CrabStatics
// 0x0000 (0x0028 - 0x0028)
class UCrabStatics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStatics">();
	}
	static class UCrabStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabStatics>();
	}
};
static_assert(alignof(UCrabStatics) == 0x000008, "Wrong alignment on UCrabStatics");
static_assert(sizeof(UCrabStatics) == 0x000028, "Wrong size on UCrabStatics");

// Class CrabChampions.CrabStatsPedestal
// 0x0080 (0x02A0 - 0x0220)
class ACrabStatsPedestal final : public AActor
{
public:
	class UStaticMeshComponent*                   PedestalMesh;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       StatsWC;                                           // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PedestalMeshToSpawn;                               // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabStatsUI>               StatsUIToSpawn;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabLobbyStats                        LobbyStats;                                        // 0x0240(0x0058)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LobbyStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStatsPedestal">();
	}
	static class ACrabStatsPedestal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabStatsPedestal>();
	}
};
static_assert(alignof(ACrabStatsPedestal) == 0x000008, "Wrong alignment on ACrabStatsPedestal");
static_assert(sizeof(ACrabStatsPedestal) == 0x0002A0, "Wrong size on ACrabStatsPedestal");
static_assert(offsetof(ACrabStatsPedestal, PedestalMesh) == 0x000220, "Member 'ACrabStatsPedestal::PedestalMesh' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, StatsWC) == 0x000228, "Member 'ACrabStatsPedestal::StatsWC' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, PedestalMeshToSpawn) == 0x000230, "Member 'ACrabStatsPedestal::PedestalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, StatsUIToSpawn) == 0x000238, "Member 'ACrabStatsPedestal::StatsUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, LobbyStats) == 0x000240, "Member 'ACrabStatsPedestal::LobbyStats' has a wrong offset!");

// Class CrabChampions.CrabStatsUI
// 0x0118 (0x03D0 - 0x02B8)
class UCrabStatsUI final : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AttemptsText;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinsText;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinStreakText;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighestIslandReachedText;                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalUnlockedPercentageText;                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           TotalUnlockedPB;                                   // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticsUnlockedText;                             // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalCosmeticsToUnlockText;                        // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CosmeticsUnlockedPB;                               // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponsUnlockedText;                               // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalWeaponsToUnlockText;                          // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           WeaponsUnlockedPB;                                 // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilitiesUnlockedText;                             // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalAbilitiesToUnlockText;                        // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           AbilitiesUnlockedPB;                               // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeWeaponsUnlockedText;                          // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalMeleeWeaponsToUnlockText;                     // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           MeleeWeaponsUnlockedPB;                            // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponModsUnlockedText;                            // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalWeaponModsToUnlockText;                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           WeaponModsUnlockedPB;                              // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityModsUnlockedText;                           // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalAbilityModsToUnlockText;                      // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           AbilityModsUnlockedPB;                             // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeModsUnlockedText;                             // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalMeleeModsToUnlockText;                        // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           MeleeModsUnlockedPB;                               // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PerksUnlockedText;                                 // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalPerksToUnlockText;                            // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PerksUnlockedPB;                                   // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RelicsUnlockedText;                                // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalRelicsToUnlockText;                           // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           RelicsUnlockedPB;                                  // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStatsUI">();
	}
	static class UCrabStatsUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabStatsUI>();
	}
};
static_assert(alignof(UCrabStatsUI) == 0x000008, "Wrong alignment on UCrabStatsUI");
static_assert(sizeof(UCrabStatsUI) == 0x0003D0, "Wrong size on UCrabStatsUI");
static_assert(offsetof(UCrabStatsUI, PlayerNameText) == 0x0002B8, "Member 'UCrabStatsUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, DifficultyText) == 0x0002C0, "Member 'UCrabStatsUI::DifficultyText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AttemptsText) == 0x0002C8, "Member 'UCrabStatsUI::AttemptsText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WinsText) == 0x0002D0, "Member 'UCrabStatsUI::WinsText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WinStreakText) == 0x0002D8, "Member 'UCrabStatsUI::WinStreakText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, HighestIslandReachedText) == 0x0002E0, "Member 'UCrabStatsUI::HighestIslandReachedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalUnlockedPercentageText) == 0x0002E8, "Member 'UCrabStatsUI::TotalUnlockedPercentageText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalUnlockedPB) == 0x0002F0, "Member 'UCrabStatsUI::TotalUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, CosmeticsUnlockedText) == 0x0002F8, "Member 'UCrabStatsUI::CosmeticsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalCosmeticsToUnlockText) == 0x000300, "Member 'UCrabStatsUI::TotalCosmeticsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, CosmeticsUnlockedPB) == 0x000308, "Member 'UCrabStatsUI::CosmeticsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponsUnlockedText) == 0x000310, "Member 'UCrabStatsUI::WeaponsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalWeaponsToUnlockText) == 0x000318, "Member 'UCrabStatsUI::TotalWeaponsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponsUnlockedPB) == 0x000320, "Member 'UCrabStatsUI::WeaponsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AbilitiesUnlockedText) == 0x000328, "Member 'UCrabStatsUI::AbilitiesUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalAbilitiesToUnlockText) == 0x000330, "Member 'UCrabStatsUI::TotalAbilitiesToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AbilitiesUnlockedPB) == 0x000338, "Member 'UCrabStatsUI::AbilitiesUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, MeleeWeaponsUnlockedText) == 0x000340, "Member 'UCrabStatsUI::MeleeWeaponsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalMeleeWeaponsToUnlockText) == 0x000348, "Member 'UCrabStatsUI::TotalMeleeWeaponsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, MeleeWeaponsUnlockedPB) == 0x000350, "Member 'UCrabStatsUI::MeleeWeaponsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponModsUnlockedText) == 0x000358, "Member 'UCrabStatsUI::WeaponModsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalWeaponModsToUnlockText) == 0x000360, "Member 'UCrabStatsUI::TotalWeaponModsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponModsUnlockedPB) == 0x000368, "Member 'UCrabStatsUI::WeaponModsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AbilityModsUnlockedText) == 0x000370, "Member 'UCrabStatsUI::AbilityModsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalAbilityModsToUnlockText) == 0x000378, "Member 'UCrabStatsUI::TotalAbilityModsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AbilityModsUnlockedPB) == 0x000380, "Member 'UCrabStatsUI::AbilityModsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, MeleeModsUnlockedText) == 0x000388, "Member 'UCrabStatsUI::MeleeModsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalMeleeModsToUnlockText) == 0x000390, "Member 'UCrabStatsUI::TotalMeleeModsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, MeleeModsUnlockedPB) == 0x000398, "Member 'UCrabStatsUI::MeleeModsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, PerksUnlockedText) == 0x0003A0, "Member 'UCrabStatsUI::PerksUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalPerksToUnlockText) == 0x0003A8, "Member 'UCrabStatsUI::TotalPerksToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, PerksUnlockedPB) == 0x0003B0, "Member 'UCrabStatsUI::PerksUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, RelicsUnlockedText) == 0x0003B8, "Member 'UCrabStatsUI::RelicsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalRelicsToUnlockText) == 0x0003C0, "Member 'UCrabStatsUI::TotalRelicsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, RelicsUnlockedPB) == 0x0003C8, "Member 'UCrabStatsUI::RelicsUnlockedPB' has a wrong offset!");

// Class CrabChampions.CrabStrike
// 0x0060 (0x0280 - 0x0220)
class ACrabStrike : public AActor
{
public:
	struct FCrabStrikeInfo                        StrikeInfo;                                        // 0x0220(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SpawnSound;                                        // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionDelay;                                    // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               DamageType;                                        // 0x0254(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            Debuff;                                            // 0x0258(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         KnockbackStrength;                                 // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawn;                                 // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_StrikeInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStrike">();
	}
	static class ACrabStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabStrike>();
	}
};
static_assert(alignof(ACrabStrike) == 0x000008, "Wrong alignment on ACrabStrike");
static_assert(sizeof(ACrabStrike) == 0x000280, "Wrong size on ACrabStrike");
static_assert(offsetof(ACrabStrike, StrikeInfo) == 0x000220, "Member 'ACrabStrike::StrikeInfo' has a wrong offset!");
static_assert(offsetof(ACrabStrike, FX) == 0x000238, "Member 'ACrabStrike::FX' has a wrong offset!");
static_assert(offsetof(ACrabStrike, SpawnSound) == 0x000240, "Member 'ACrabStrike::SpawnSound' has a wrong offset!");
static_assert(offsetof(ACrabStrike, Radius) == 0x000248, "Member 'ACrabStrike::Radius' has a wrong offset!");
static_assert(offsetof(ACrabStrike, ExplosionDelay) == 0x00024C, "Member 'ACrabStrike::ExplosionDelay' has a wrong offset!");
static_assert(offsetof(ACrabStrike, Damage) == 0x000250, "Member 'ACrabStrike::Damage' has a wrong offset!");
static_assert(offsetof(ACrabStrike, DamageType) == 0x000254, "Member 'ACrabStrike::DamageType' has a wrong offset!");
static_assert(offsetof(ACrabStrike, Debuff) == 0x000258, "Member 'ACrabStrike::Debuff' has a wrong offset!");
static_assert(offsetof(ACrabStrike, KnockbackStrength) == 0x000260, "Member 'ACrabStrike::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(ACrabStrike, DamageAreaToSpawn) == 0x000268, "Member 'ACrabStrike::DamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabStrike, ExplosionSound) == 0x000270, "Member 'ACrabStrike::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabStrike, ExplosionCameraShake) == 0x000278, "Member 'ACrabStrike::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabStrikeActionDA
// 0x0028 (0x0090 - 0x0068)
class UCrabStrikeActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACrabStrike>                StrikeToSpawn;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumLineStrikesToSpawn;                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineStrikeSpawnFrequency;                          // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFormationType                            FormationType;                                     // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FormationSpacing;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationArcStrength;                              // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spread;                                            // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStrikeActionDA">();
	}
	static class UCrabStrikeActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabStrikeActionDA>();
	}
};
static_assert(alignof(UCrabStrikeActionDA) == 0x000008, "Wrong alignment on UCrabStrikeActionDA");
static_assert(sizeof(UCrabStrikeActionDA) == 0x000090, "Wrong size on UCrabStrikeActionDA");
static_assert(offsetof(UCrabStrikeActionDA, TargetType) == 0x000068, "Member 'UCrabStrikeActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, StrikeToSpawn) == 0x000070, "Member 'UCrabStrikeActionDA::StrikeToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, NumLineStrikesToSpawn) == 0x000078, "Member 'UCrabStrikeActionDA::NumLineStrikesToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, LineStrikeSpawnFrequency) == 0x00007C, "Member 'UCrabStrikeActionDA::LineStrikeSpawnFrequency' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, FormationType) == 0x000080, "Member 'UCrabStrikeActionDA::FormationType' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, FormationSpacing) == 0x000084, "Member 'UCrabStrikeActionDA::FormationSpacing' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, FormationArcStrength) == 0x000088, "Member 'UCrabStrikeActionDA::FormationArcStrength' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, Spread) == 0x00008C, "Member 'UCrabStrikeActionDA::Spread' has a wrong offset!");

// Class CrabChampions.CrabTargetDummyC
// 0x0030 (0x09C0 - 0x0990)
class ACrabTargetDummyC : public ACrabEnemyC
{
public:
	class UWidgetComponent*                       DPSWC;                                             // 0x0988(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCrabDamageTextUI>          DPSWidgetClass;                                    // 0x0990(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DPSInterval;                                       // 0x0998(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99C[0x4];                                      // 0x099C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabDamageTextUI*                      DPSUI;                                             // 0x09A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A8[0x4];                                      // 0x09A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DPS;                                               // 0x09AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B0[0x10];                                     // 0x09B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DPS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabTargetDummyC">();
	}
	static class ACrabTargetDummyC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabTargetDummyC>();
	}
};
static_assert(alignof(ACrabTargetDummyC) == 0x000010, "Wrong alignment on ACrabTargetDummyC");
static_assert(sizeof(ACrabTargetDummyC) == 0x0009C0, "Wrong size on ACrabTargetDummyC");
static_assert(offsetof(ACrabTargetDummyC, DPSWC) == 0x000988, "Member 'ACrabTargetDummyC::DPSWC' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPSWidgetClass) == 0x000990, "Member 'ACrabTargetDummyC::DPSWidgetClass' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPSInterval) == 0x000998, "Member 'ACrabTargetDummyC::DPSInterval' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPSUI) == 0x0009A0, "Member 'ACrabTargetDummyC::DPSUI' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPS) == 0x0009AC, "Member 'ACrabTargetDummyC::DPS' has a wrong offset!");

// Class CrabChampions.CrabTotem
// 0x00B0 (0x0328 - 0x0278)
class ACrabTotem : public ACrabInteractable
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TotemMesh;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TotemNC;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        TotemAC;                                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabTotemType                                TotemType;                                         // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnWeight;                                       // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChanceToExplode;                                   // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x02A4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Cost;                                              // 0x02D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumBuffs;                                          // 0x02D8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              BuffSound;                                         // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDebuffs;                                        // 0x02E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              DebuffSound;                                       // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsExploded;                                       // 0x0300(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DestroyedMesh;                                     // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Cost();
	void OnRep_IsExploded();
	void OnRep_NumBuffs();
	void OnRep_NumDebuffs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabTotem">();
	}
	static class ACrabTotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabTotem>();
	}
};
static_assert(alignof(ACrabTotem) == 0x000008, "Wrong alignment on ACrabTotem");
static_assert(sizeof(ACrabTotem) == 0x000328, "Wrong size on ACrabTotem");
static_assert(offsetof(ACrabTotem, TotemMesh) == 0x000280, "Member 'ACrabTotem::TotemMesh' has a wrong offset!");
static_assert(offsetof(ACrabTotem, TotemNC) == 0x000288, "Member 'ACrabTotem::TotemNC' has a wrong offset!");
static_assert(offsetof(ACrabTotem, TotemAC) == 0x000290, "Member 'ACrabTotem::TotemAC' has a wrong offset!");
static_assert(offsetof(ACrabTotem, TotemType) == 0x000298, "Member 'ACrabTotem::TotemType' has a wrong offset!");
static_assert(offsetof(ACrabTotem, SpawnWeight) == 0x00029C, "Member 'ACrabTotem::SpawnWeight' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ChanceToExplode) == 0x0002A0, "Member 'ACrabTotem::ChanceToExplode' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Tint) == 0x0002A4, "Member 'ACrabTotem::Tint' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Mesh) == 0x0002B8, "Member 'ACrabTotem::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabTotem, FX) == 0x0002C0, "Member 'ACrabTotem::FX' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Sound) == 0x0002C8, "Member 'ACrabTotem::Sound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Cost) == 0x0002D0, "Member 'ACrabTotem::Cost' has a wrong offset!");
static_assert(offsetof(ACrabTotem, NumBuffs) == 0x0002D8, "Member 'ACrabTotem::NumBuffs' has a wrong offset!");
static_assert(offsetof(ACrabTotem, BuffSound) == 0x0002E0, "Member 'ACrabTotem::BuffSound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, NumDebuffs) == 0x0002E8, "Member 'ACrabTotem::NumDebuffs' has a wrong offset!");
static_assert(offsetof(ACrabTotem, DebuffSound) == 0x0002F0, "Member 'ACrabTotem::DebuffSound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, bIsExploded) == 0x000300, "Member 'ACrabTotem::bIsExploded' has a wrong offset!");
static_assert(offsetof(ACrabTotem, DestroyedMesh) == 0x000308, "Member 'ACrabTotem::DestroyedMesh' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ExplosionFX) == 0x000310, "Member 'ACrabTotem::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ExplosionSound) == 0x000318, "Member 'ACrabTotem::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ExplosionCameraShake) == 0x000320, "Member 'ACrabTotem::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabTurret
// 0x0128 (0x0348 - 0x0220)
class ACrabTurret : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   TurretMesh;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TurretNC;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabHC*                                HC;                                                // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       HealthBarWC;                                       // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocketName;                                  // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MuzzleFlashNC;                                     // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        GunshotAC;                                         // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabTurretType                               TurretType;                                        // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Tint;                                              // 0x026C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BaseMeshToSpawn;                                   // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            TurretMeshToSpawn;                                 // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0298(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchFrequency;                                   // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthReductionScale;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x4];                                      // 0x02A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireRate;                                          // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCrabHealthBarUI>           HealthBarUIToSpawn;                                // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarHeightOffset;                             // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TurretName;                                        // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MuzzleFlashFX;                                     // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              GunshotSound;                                      // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurretRotationSpeed;                               // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0xC];                                      // 0x02EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 BestEnemyC;                                        // 0x02F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchRange;                                       // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0xC];                                      // 0x0304(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Spread;                                            // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabDebuff                            Debuff;                                            // 0x0320(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsExploded;                                       // 0x0328(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_IsExploded();
	void OnRep_OwningC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabTurret">();
	}
	static class ACrabTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabTurret>();
	}
};
static_assert(alignof(ACrabTurret) == 0x000008, "Wrong alignment on ACrabTurret");
static_assert(sizeof(ACrabTurret) == 0x000348, "Wrong size on ACrabTurret");
static_assert(offsetof(ACrabTurret, BaseMesh) == 0x000228, "Member 'ACrabTurret::BaseMesh' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretMesh) == 0x000230, "Member 'ACrabTurret::TurretMesh' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretNC) == 0x000238, "Member 'ACrabTurret::TurretNC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HC) == 0x000240, "Member 'ACrabTurret::HC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthBarWC) == 0x000248, "Member 'ACrabTurret::HealthBarWC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, MuzzleSocketName) == 0x000250, "Member 'ACrabTurret::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(ACrabTurret, MuzzleFlashNC) == 0x000258, "Member 'ACrabTurret::MuzzleFlashNC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, GunshotAC) == 0x000260, "Member 'ACrabTurret::GunshotAC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretType) == 0x000268, "Member 'ACrabTurret::TurretType' has a wrong offset!");
static_assert(offsetof(ACrabTurret, Tint) == 0x00026C, "Member 'ACrabTurret::Tint' has a wrong offset!");
static_assert(offsetof(ACrabTurret, BaseMeshToSpawn) == 0x000280, "Member 'ACrabTurret::BaseMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretMeshToSpawn) == 0x000288, "Member 'ACrabTurret::TurretMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabTurret, FX) == 0x000290, "Member 'ACrabTurret::FX' has a wrong offset!");
static_assert(offsetof(ACrabTurret, OwningC) == 0x000298, "Member 'ACrabTurret::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, SearchFrequency) == 0x0002A0, "Member 'ACrabTurret::SearchFrequency' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthReductionScale) == 0x0002A4, "Member 'ACrabTurret::HealthReductionScale' has a wrong offset!");
static_assert(offsetof(ACrabTurret, FireRate) == 0x0002AC, "Member 'ACrabTurret::FireRate' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthBarUIToSpawn) == 0x0002B8, "Member 'ACrabTurret::HealthBarUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthBarHeightOffset) == 0x0002C0, "Member 'ACrabTurret::HealthBarHeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretName) == 0x0002C8, "Member 'ACrabTurret::TurretName' has a wrong offset!");
static_assert(offsetof(ACrabTurret, MuzzleFlashFX) == 0x0002D8, "Member 'ACrabTurret::MuzzleFlashFX' has a wrong offset!");
static_assert(offsetof(ACrabTurret, GunshotSound) == 0x0002E0, "Member 'ACrabTurret::GunshotSound' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretRotationSpeed) == 0x0002E8, "Member 'ACrabTurret::TurretRotationSpeed' has a wrong offset!");
static_assert(offsetof(ACrabTurret, BestEnemyC) == 0x0002F8, "Member 'ACrabTurret::BestEnemyC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, SearchRange) == 0x000300, "Member 'ACrabTurret::SearchRange' has a wrong offset!");
static_assert(offsetof(ACrabTurret, Spread) == 0x000310, "Member 'ACrabTurret::Spread' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ProjectileDA) == 0x000318, "Member 'ACrabTurret::ProjectileDA' has a wrong offset!");
static_assert(offsetof(ACrabTurret, Debuff) == 0x000320, "Member 'ACrabTurret::Debuff' has a wrong offset!");
static_assert(offsetof(ACrabTurret, bIsExploded) == 0x000328, "Member 'ACrabTurret::bIsExploded' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ExplosionFX) == 0x000330, "Member 'ACrabTurret::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ExplosionSound) == 0x000338, "Member 'ACrabTurret::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ExplosionCameraShake) == 0x000340, "Member 'ACrabTurret::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabUnlockedCosmeticUI
// 0x0028 (0x02E0 - 0x02B8)
class UCrabUnlockedCosmeticUI : public UCrabUI
{
public:
	class UTextBlock*                             ChallengeDescriptionText;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticTypeText;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticNameText;                                  // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CosmeticIconImage;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UnlockedAnim;                                      // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabUnlockedCosmeticUI">();
	}
	static class UCrabUnlockedCosmeticUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabUnlockedCosmeticUI>();
	}
};
static_assert(alignof(UCrabUnlockedCosmeticUI) == 0x000008, "Wrong alignment on UCrabUnlockedCosmeticUI");
static_assert(sizeof(UCrabUnlockedCosmeticUI) == 0x0002E0, "Wrong size on UCrabUnlockedCosmeticUI");
static_assert(offsetof(UCrabUnlockedCosmeticUI, ChallengeDescriptionText) == 0x0002B8, "Member 'UCrabUnlockedCosmeticUI::ChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, CosmeticTypeText) == 0x0002C0, "Member 'UCrabUnlockedCosmeticUI::CosmeticTypeText' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, CosmeticNameText) == 0x0002C8, "Member 'UCrabUnlockedCosmeticUI::CosmeticNameText' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, CosmeticIconImage) == 0x0002D0, "Member 'UCrabUnlockedCosmeticUI::CosmeticIconImage' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, UnlockedAnim) == 0x0002D8, "Member 'UCrabUnlockedCosmeticUI::UnlockedAnim' has a wrong offset!");

// Class CrabChampions.CrabVideoMenuUI
// 0x01A8 (0x0460 - 0x02B8)
class UCrabVideoMenuUI : public UCrabUI
{
public:
	TArray<class UWidget*>                        VideoMenuFocusableWidgetArray;                     // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x110];                                    // 0x02C8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabArrowSelectionUI*                  DisplayModeAS;                                     // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  ResolutionAS;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  ResolutionQualityAS;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  FPSLimitAS;                                        // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  VSyncAS;                                           // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  FieldOfViewAS;                                     // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  GraphicsQualityAS;                                 // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  WeaponEffectsAS;                                   // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  AntiAliasingTypeAS;                                // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  SharpeningAS;                                      // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  MotionBlurAS;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  CameraShakeAS;                                     // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  HitmarkersAS;                                      // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  DamageNumbersAS;                                   // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  TextChatVisibilityAS;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  ShowFPSAS;                                         // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  PauseWhenLosingFocusAS;                            // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAntiAliasingType(const class FString& NewSelection);
	void SetCameraShake(const class FString& NewSelection);
	void SetDamageNumbers(const class FString& NewSelection);
	void SetDisplayMode(const class FString& NewSelection);
	void SetFieldOfView(const class FString& NewSelection);
	void SetFPSLimit(const class FString& NewSelection);
	void SetGraphicsQuality(const class FString& NewSelection);
	void SetHitmarkers(const class FString& NewSelection);
	void SetMotionBlur(const class FString& NewSelection);
	void SetPauseWhenLosingFocus(const class FString& NewSelection);
	void SetResolution(const class FString& NewSelection);
	void SetResolutionQuality(const class FString& NewSelection);
	void SetSharpening(const class FString& NewSelection);
	void SetShowFPS(const class FString& NewSelection);
	void SetTextChatVisibility(const class FString& NewSelection);
	void SetVSync(const class FString& NewSelection);
	void SetWeaponEffects(const class FString& NewSelection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabVideoMenuUI">();
	}
	static class UCrabVideoMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabVideoMenuUI>();
	}
};
static_assert(alignof(UCrabVideoMenuUI) == 0x000008, "Wrong alignment on UCrabVideoMenuUI");
static_assert(sizeof(UCrabVideoMenuUI) == 0x000460, "Wrong size on UCrabVideoMenuUI");
static_assert(offsetof(UCrabVideoMenuUI, VideoMenuFocusableWidgetArray) == 0x0002B8, "Member 'UCrabVideoMenuUI::VideoMenuFocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, DisplayModeAS) == 0x0003D8, "Member 'UCrabVideoMenuUI::DisplayModeAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, ResolutionAS) == 0x0003E0, "Member 'UCrabVideoMenuUI::ResolutionAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, ResolutionQualityAS) == 0x0003E8, "Member 'UCrabVideoMenuUI::ResolutionQualityAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, FPSLimitAS) == 0x0003F0, "Member 'UCrabVideoMenuUI::FPSLimitAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, VSyncAS) == 0x0003F8, "Member 'UCrabVideoMenuUI::VSyncAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, FieldOfViewAS) == 0x000400, "Member 'UCrabVideoMenuUI::FieldOfViewAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, GraphicsQualityAS) == 0x000408, "Member 'UCrabVideoMenuUI::GraphicsQualityAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, WeaponEffectsAS) == 0x000410, "Member 'UCrabVideoMenuUI::WeaponEffectsAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, AntiAliasingTypeAS) == 0x000418, "Member 'UCrabVideoMenuUI::AntiAliasingTypeAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, SharpeningAS) == 0x000420, "Member 'UCrabVideoMenuUI::SharpeningAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, MotionBlurAS) == 0x000428, "Member 'UCrabVideoMenuUI::MotionBlurAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, CameraShakeAS) == 0x000430, "Member 'UCrabVideoMenuUI::CameraShakeAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, HitmarkersAS) == 0x000438, "Member 'UCrabVideoMenuUI::HitmarkersAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, DamageNumbersAS) == 0x000440, "Member 'UCrabVideoMenuUI::DamageNumbersAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, TextChatVisibilityAS) == 0x000448, "Member 'UCrabVideoMenuUI::TextChatVisibilityAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, ShowFPSAS) == 0x000450, "Member 'UCrabVideoMenuUI::ShowFPSAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, PauseWhenLosingFocusAS) == 0x000458, "Member 'UCrabVideoMenuUI::PauseWhenLosingFocusAS' has a wrong offset!");

// Class CrabChampions.CrabWeapon
// 0x0180 (0x03A0 - 0x0220)
class ACrabWeapon final : public AActor
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CosmeticNC;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      MuzzleFlashNC;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x0240(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabWeaponInfo                        WeaponInfo;                                        // 0x0248(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPC*                                OwningPC;                                          // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0xA8];                                     // 0x0290(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimesFired;                                        // 0x0338(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x34];                                     // 0x033C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReloading;                                      // 0x0370(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x2F];                                     // 0x0371(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsReloading();
	void OnRep_OwningPS();
	void OnRep_TimesFired();
	void OnRep_WeaponInfo();
	void ServerPlayStartFireFX();
	void ServerSetIsReloading(bool bNewIsReloading);
	void ServerTriggerOnReloadPerks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabWeapon">();
	}
	static class ACrabWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabWeapon>();
	}
};
static_assert(alignof(ACrabWeapon) == 0x000008, "Wrong alignment on ACrabWeapon");
static_assert(sizeof(ACrabWeapon) == 0x0003A0, "Wrong size on ACrabWeapon");
static_assert(offsetof(ACrabWeapon, Mesh) == 0x000220, "Member 'ACrabWeapon::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, CosmeticNC) == 0x000228, "Member 'ACrabWeapon::CosmeticNC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, MuzzleFlashNC) == 0x000238, "Member 'ACrabWeapon::MuzzleFlashNC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, OwningPS) == 0x000240, "Member 'ACrabWeapon::OwningPS' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, WeaponInfo) == 0x000248, "Member 'ACrabWeapon::WeaponInfo' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, WeaponDA) == 0x000260, "Member 'ACrabWeapon::WeaponDA' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, OwningC) == 0x000268, "Member 'ACrabWeapon::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, OwningPC) == 0x000270, "Member 'ACrabWeapon::OwningPC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, ActorsToIgnore) == 0x000280, "Member 'ACrabWeapon::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, TimesFired) == 0x000338, "Member 'ACrabWeapon::TimesFired' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, bIsReloading) == 0x000370, "Member 'ACrabWeapon::bIsReloading' has a wrong offset!");

// Class CrabChampions.CrabWeaponDA
// 0x0130 (0x01E0 - 0x00B0)
class UCrabWeaponDA final : public UCrabPickupDA
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDualWield;                                        // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabWeaponMod                         StartingWeaponMod;                                 // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AimingFOVMultiplier;                               // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimingSpringArmOffset;                             // 0x00F4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabCrosshairType                            CrosshairType;                                     // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabHitmarkerType                            HitmarkerType;                                     // 0x0101(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFireMode                                 FireMode;                                          // 0x0102(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabShotDirType                              ShotDirType;                                       // 0x0103(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabShotSpawnType                            ShotSpawnType;                                     // 0x0104(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireFromRoot;                                     // 0x0105(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFormationType                            FormationType;                                     // 0x0106(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_107[0x1];                                      // 0x0107(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FormationSpacing;                                  // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationExpansionDampening;                       // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdditiveFormations;                               // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShotsPerBurst;                                     // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenBurstShots;                             // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseFireRate;                                      // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponModTriggerRollMultiplier;                    // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpread;                                        // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringSpreadIncrement;                             // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpread;                                         // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadRecovery;                                    // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingSpreadMultiplier;                            // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoil;                                    // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRecoil;                                  // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilInterpSpeed;                                 // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRecoveryInterpSpeed;                         // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfKnockbackStrength;                             // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseClipSize;                                      // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfiniteClipSize;                                 // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadDuration;                                    // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EquipMontage;                                      // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EquipSound;                                        // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CosmeticFX;                                        // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireMontage;                                       // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DualWieldFireMontage;                              // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FloatFireMontage;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         MuzzleFlashFX;                                     // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GunshotSound;                                      // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LowAmmoSound;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostFireClearChamberDelay;                         // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PostFireClearChamberMontage;                       // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PostFireClearChamberSound;                         // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EmptyClipSound;                                    // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadMontage;                                     // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DualWieldReloadMontage;                            // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MagOutSound;                                       // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MagInSound;                                        // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabWeaponDA">();
	}
	static class UCrabWeaponDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabWeaponDA>();
	}
};
static_assert(alignof(UCrabWeaponDA) == 0x000008, "Wrong alignment on UCrabWeaponDA");
static_assert(sizeof(UCrabWeaponDA) == 0x0001E0, "Wrong size on UCrabWeaponDA");
static_assert(offsetof(UCrabWeaponDA, Mesh) == 0x0000B0, "Member 'UCrabWeaponDA::Mesh' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bDualWield) == 0x0000B8, "Member 'UCrabWeaponDA::bDualWield' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ProjectileDA) == 0x0000C0, "Member 'UCrabWeaponDA::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, StartingWeaponMod) == 0x0000C8, "Member 'UCrabWeaponDA::StartingWeaponMod' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, AimingFOVMultiplier) == 0x0000F0, "Member 'UCrabWeaponDA::AimingFOVMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, AimingSpringArmOffset) == 0x0000F4, "Member 'UCrabWeaponDA::AimingSpringArmOffset' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, CrosshairType) == 0x000100, "Member 'UCrabWeaponDA::CrosshairType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, HitmarkerType) == 0x000101, "Member 'UCrabWeaponDA::HitmarkerType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FireMode) == 0x000102, "Member 'UCrabWeaponDA::FireMode' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ShotDirType) == 0x000103, "Member 'UCrabWeaponDA::ShotDirType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ShotSpawnType) == 0x000104, "Member 'UCrabWeaponDA::ShotSpawnType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bFireFromRoot) == 0x000105, "Member 'UCrabWeaponDA::bFireFromRoot' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FormationType) == 0x000106, "Member 'UCrabWeaponDA::FormationType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FormationSpacing) == 0x000108, "Member 'UCrabWeaponDA::FormationSpacing' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FormationExpansionDampening) == 0x00010C, "Member 'UCrabWeaponDA::FormationExpansionDampening' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bAdditiveFormations) == 0x000110, "Member 'UCrabWeaponDA::bAdditiveFormations' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ShotsPerBurst) == 0x000114, "Member 'UCrabWeaponDA::ShotsPerBurst' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, TimeBetweenBurstShots) == 0x000118, "Member 'UCrabWeaponDA::TimeBetweenBurstShots' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, BaseFireRate) == 0x00011C, "Member 'UCrabWeaponDA::BaseFireRate' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, WeaponModTriggerRollMultiplier) == 0x000120, "Member 'UCrabWeaponDA::WeaponModTriggerRollMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, BaseSpread) == 0x000124, "Member 'UCrabWeaponDA::BaseSpread' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FiringSpreadIncrement) == 0x000128, "Member 'UCrabWeaponDA::FiringSpreadIncrement' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MaxSpread) == 0x00012C, "Member 'UCrabWeaponDA::MaxSpread' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, SpreadRecovery) == 0x000130, "Member 'UCrabWeaponDA::SpreadRecovery' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, AimingSpreadMultiplier) == 0x000134, "Member 'UCrabWeaponDA::AimingSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, VerticalRecoil) == 0x000138, "Member 'UCrabWeaponDA::VerticalRecoil' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, HorizontalRecoil) == 0x00013C, "Member 'UCrabWeaponDA::HorizontalRecoil' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, RecoilInterpSpeed) == 0x000140, "Member 'UCrabWeaponDA::RecoilInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, RecoilRecoveryInterpSpeed) == 0x000144, "Member 'UCrabWeaponDA::RecoilRecoveryInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, SelfKnockbackStrength) == 0x000148, "Member 'UCrabWeaponDA::SelfKnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, BaseClipSize) == 0x00014C, "Member 'UCrabWeaponDA::BaseClipSize' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bInfiniteClipSize) == 0x000150, "Member 'UCrabWeaponDA::bInfiniteClipSize' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ReloadDuration) == 0x000154, "Member 'UCrabWeaponDA::ReloadDuration' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, EquipMontage) == 0x000158, "Member 'UCrabWeaponDA::EquipMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, EquipSound) == 0x000160, "Member 'UCrabWeaponDA::EquipSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, CosmeticFX) == 0x000168, "Member 'UCrabWeaponDA::CosmeticFX' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FireMontage) == 0x000170, "Member 'UCrabWeaponDA::FireMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, DualWieldFireMontage) == 0x000178, "Member 'UCrabWeaponDA::DualWieldFireMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FloatFireMontage) == 0x000180, "Member 'UCrabWeaponDA::FloatFireMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MuzzleFlashFX) == 0x000188, "Member 'UCrabWeaponDA::MuzzleFlashFX' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, GunshotSound) == 0x000190, "Member 'UCrabWeaponDA::GunshotSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, LowAmmoSound) == 0x000198, "Member 'UCrabWeaponDA::LowAmmoSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, PostFireClearChamberDelay) == 0x0001A0, "Member 'UCrabWeaponDA::PostFireClearChamberDelay' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, PostFireClearChamberMontage) == 0x0001A8, "Member 'UCrabWeaponDA::PostFireClearChamberMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, PostFireClearChamberSound) == 0x0001B0, "Member 'UCrabWeaponDA::PostFireClearChamberSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, EmptyClipSound) == 0x0001B8, "Member 'UCrabWeaponDA::EmptyClipSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ReloadMontage) == 0x0001C0, "Member 'UCrabWeaponDA::ReloadMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, DualWieldReloadMontage) == 0x0001C8, "Member 'UCrabWeaponDA::DualWieldReloadMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MagOutSound) == 0x0001D0, "Member 'UCrabWeaponDA::MagOutSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MagInSound) == 0x0001D8, "Member 'UCrabWeaponDA::MagInSound' has a wrong offset!");

// Class CrabChampions.CrabWeaponModDA
// 0x0008 (0x00E0 - 0x00D8)
class UCrabWeaponModDA final : public UCrabInventoryDA
{
public:
	ECrabWeaponModType                            WeaponModType;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabTriggerChanceType                        TriggerChanceType;                                 // 0x00D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabWeaponModDA">();
	}
	static class UCrabWeaponModDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabWeaponModDA>();
	}
};
static_assert(alignof(UCrabWeaponModDA) == 0x000008, "Wrong alignment on UCrabWeaponModDA");
static_assert(sizeof(UCrabWeaponModDA) == 0x0000E0, "Wrong size on UCrabWeaponModDA");
static_assert(offsetof(UCrabWeaponModDA, WeaponModType) == 0x0000D8, "Member 'UCrabWeaponModDA::WeaponModType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponModDA, TriggerChanceType) == 0x0000D9, "Member 'UCrabWeaponModDA::TriggerChanceType' has a wrong offset!");

}

