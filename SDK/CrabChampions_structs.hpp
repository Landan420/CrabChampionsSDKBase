#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CrabChampions

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum CrabChampions.ECrabAbilitySpawnType
// NumValues: 0x0003
enum class ECrabAbilitySpawnType : uint8
{
	Claw                                     = 0,
	AboveCrosshair                           = 1,
	ECrabAbilitySpawnType_MAX                = 2,
};

// Enum CrabChampions.ECrabBossPhase
// NumValues: 0x0004
enum class ECrabBossPhase : uint8
{
	PhaseOne                                 = 0,
	PhaseTwo                                 = 1,
	PhaseThree                               = 2,
	ECrabBossPhase_MAX                       = 3,
};

// Enum CrabChampions.ECrabCrystalDropType
// NumValues: 0x000A
enum class ECrabCrystalDropType : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	Gigantic                                 = 4,
	SmallWithBonus                           = 5,
	MediumWithBonus                          = 6,
	LargeWithBonus                           = 7,
	GiganticWithBonus                        = 8,
	ECrabCrystalDropType_MAX                 = 9,
};

// Enum CrabChampions.ECrabDamageAreaType
// NumValues: 0x0007
enum class ECrabDamageAreaType : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Health                                   = 2,
	MaxHealth                                = 3,
	EnergyRing                               = 4,
	BlackHole                                = 5,
	ECrabDamageAreaType_MAX                  = 6,
};

// Enum CrabChampions.ECrabEQCType
// NumValues: 0x0005
enum class ECrabEQCType : uint8
{
	None                                     = 0,
	BestEnemyC                               = 1,
	BestEnemyCoreLoc                         = 2,
	BestFriendlyC                            = 3,
	ECrabEQCType_MAX                         = 4,
};

// Enum CrabChampions.ECrabHarvestAreaType
// NumValues: 0x0004
enum class ECrabHarvestAreaType : uint8
{
	None                                     = 0,
	Crystal                                  = 1,
	Revival                                  = 2,
	ECrabHarvestAreaType_MAX                 = 3,
};

// Enum CrabChampions.ECrabConfirmationPromptType
// NumValues: 0x0005
enum class ECrabConfirmationPromptType : uint8
{
	None                                     = 0,
	QuitToLobby                              = 1,
	BringPartyMembersToLobby                 = 2,
	QuitToDesktop                            = 3,
	ECrabConfirmationPromptType_MAX          = 4,
};

// Enum CrabChampions.ECrabInputDir
// NumValues: 0x0006
enum class ECrabInputDir : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Right                                    = 3,
	Left                                     = 4,
	ECrabInputDir_MAX                        = 5,
};

// Enum CrabChampions.ECrabBlockingHitState
// NumValues: 0x0003
enum class ECrabBlockingHitState : uint8
{
	Deflected                                = 0,
	Aborted                                  = 1,
	ECrabBlockingHitState_MAX                = 2,
};

// Enum CrabChampions.ECrabProjectileState
// NumValues: 0x0005
enum class ECrabProjectileState : uint8
{
	None                                     = 0,
	Pooled                                   = 1,
	Active                                   = 2,
	Exploded                                 = 3,
	ECrabProjectileState_MAX                 = 4,
};

// Enum CrabChampions.ECrabTurretType
// NumValues: 0x0007
enum class ECrabTurretType : uint8
{
	None                                     = 0,
	Sentry                                   = 1,
	Sniper                                   = 2,
	Mortar                                   = 3,
	Wave                                     = 4,
	Beam                                     = 5,
	ECrabTurretType_MAX                      = 6,
};

// Enum CrabChampions.ECrabTargetType
// NumValues: 0x0006
enum class ECrabTargetType : uint8
{
	None                                     = 0,
	Up                                       = 1,
	CurrentLoc                               = 2,
	PredictedLoc                             = 3,
	TelegraphedLoc                           = 4,
	ECrabTargetType_MAX                      = 5,
};

// Enum CrabChampions.ECrabEnemyBuff
// NumValues: 0x0009
enum class ECrabEnemyBuff : uint8
{
	None                                     = 0,
	Shielded                                 = 1,
	Healthy                                  = 2,
	Regenerating                             = 3,
	Angered                                  = 4,
	Frenzied                                 = 5,
	Speedy                                   = 6,
	Last                                     = 7,
	ECrabEnemyBuff_MAX                       = 8,
};

// Enum CrabChampions.ECrabEnemyMovementType
// NumValues: 0x0005
enum class ECrabEnemyMovementType : uint8
{
	None                                     = 0,
	MoveDirectlyToEnemy                      = 1,
	MoveToPredictedEnemyLoc                  = 2,
	MoveToRangedActionLoc                    = 3,
	ECrabEnemyMovementType_MAX               = 4,
};

// Enum CrabChampions.ECrabEnemyCategory
// NumValues: 0x0007
enum class ECrabEnemyCategory : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Elite                                    = 4,
	Boss                                     = 5,
	ECrabEnemyCategory_MAX                   = 6,
};

// Enum CrabChampions.ECrabBlessing
// NumValues: 0x0007
enum class ECrabBlessing : uint8
{
	None                                     = 0,
	Flawless                                 = 1,
	Rush                                     = 2,
	KnivesOut                                = 3,
	Harvest                                  = 4,
	Last                                     = 5,
	ECrabBlessing_MAX                        = 6,
};

// Enum CrabChampions.ECrabChallengeModifier
// NumValues: 0x0014
enum class ECrabChallengeModifier : uint8
{
	None                                     = 0,
	OneHit                                   = 1,
	NoHealing                                = 2,
	MirroredProjectiles                      = 3,
	Shrapnel                                 = 4,
	HomingThorns                             = 5,
	HomingBarrels                            = 6,
	ElementalExplosions                      = 7,
	EnergyRings                              = 8,
	SpikeStrikes                             = 9,
	TwinnedEnemies                           = 10,
	ArmoredEnemies                           = 11,
	SpeedyEnemies                            = 12,
	IcyEnemies                               = 13,
	ExplosiveEnemies                         = 14,
	BarrelRain                               = 15,
	LandmineRain                             = 16,
	MeteorShower                             = 17,
	Last                                     = 18,
	ECrabChallengeModifier_MAX               = 19,
};

// Enum CrabChampions.ECrabContractType
// NumValues: 0x000A
enum class ECrabContractType : uint8
{
	None                                     = 0,
	TimeTrial                                = 1,
	NoHeals                                  = 2,
	Pacifist                                 = 3,
	ShieldedElite                            = 4,
	Zombies                                  = 5,
	Clones                                   = 6,
	Chaos                                    = 7,
	Last                                     = 8,
	ECrabContractType_MAX                    = 9,
};

// Enum CrabChampions.ECrabIslandType
// NumValues: 0x0012
enum class ECrabIslandType : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	NewRun                                   = 2,
	ContinueRun                              = 3,
	Arena                                    = 4,
	Horde                                    = 5,
	Demolition                               = 6,
	Parkour                                  = 7,
	Shop                                     = 8,
	Elite                                    = 9,
	Boss                                     = 10,
	Biome                                    = 11,
	CrabIsland                               = 12,
	Loop                                     = 13,
	Arcade                                   = 14,
	Holdout                                  = 15,
	Duel                                     = 16,
	ECrabIslandType_MAX                      = 17,
};

// Enum CrabChampions.ECrabRank
// NumValues: 0x0009
enum class ECrabRank : uint8
{
	None                                     = 0,
	Bronze                                   = 1,
	Silver                                   = 2,
	Gold                                     = 3,
	Sapphire                                 = 4,
	Emerald                                  = 5,
	Ruby                                     = 6,
	Diamond                                  = 7,
	ECrabRank_MAX                            = 8,
};

// Enum CrabChampions.ECrabDifficultyModifier
// NumValues: 0x000C
enum class ECrabDifficultyModifier : uint8
{
	LockedSlots                              = 0,
	BuffedEnemies                            = 1,
	ResurrectingEnemies                      = 2,
	ExpensiveShops                           = 3,
	DoubleChallenge                          = 4,
	EvolvedEnemies                           = 5,
	AmbushingElites                          = 6,
	EternalPunishment                        = 7,
	UnfairBosses                             = 8,
	NoSafetyNet                              = 9,
	Last                                     = 10,
	ECrabDifficultyModifier_MAX              = 11,
};

// Enum CrabChampions.ECrabDifficulty
// NumValues: 0x0005
enum class ECrabDifficulty : uint8
{
	Easy                                     = 0,
	Normal                                   = 1,
	Nightmare                                = 2,
	UltraChaos                               = 3,
	ECrabDifficulty_MAX                      = 4,
};

// Enum CrabChampions.ECrabTotemType
// NumValues: 0x0014
enum class ECrabTotemType : uint8
{
	None                                     = 0,
	Cosmetics                                = 1,
	Difficulty                               = 2,
	Key                                      = 3,
	Multiplayer                              = 4,
	Health                                   = 5,
	Crystal                                  = 6,
	Chance                                   = 7,
	Gamble                                   = 8,
	Loot                                     = 9,
	Gold                                     = 10,
	Glass                                    = 11,
	Fuse                                     = 12,
	Greed                                    = 13,
	Random                                   = 14,
	Contract                                 = 15,
	XL                                       = 16,
	Reroll                                   = 17,
	Enhancement                              = 18,
	ECrabTotemType_MAX                       = 19,
};

// Enum CrabChampions.ECrabConsumableType
// NumValues: 0x0005
enum class ECrabConsumableType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	Crystal                                  = 2,
	Key                                      = 3,
	ECrabConsumableType_MAX                  = 4,
};

// Enum CrabChampions.ECrabRelicType
// NumValues: 0x0040
enum class ECrabRelicType : uint8
{
	None                                     = 0,
	RingOfVigor                              = 1,
	RingOfHealing                            = 2,
	RingOfArmor                              = 3,
	RingOfParrying                           = 4,
	RingOfHealthyTurrets                     = 5,
	AdrenalineAmulet                         = 6,
	RingOfDestruction                        = 7,
	AncientBlade                             = 8,
	PortalRing                               = 9,
	RingOfRevolution                         = 10,
	RingOfReloading                          = 11,
	CoralAmulet                              = 12,
	RubyDice                                 = 13,
	BlacksmithAmulet                         = 14,
	TonysRing                                = 15,
	ComboRing                                = 16,
	TonysAmulet                              = 17,
	EtherealArmor                            = 18,
	RingOfReinforcement                      = 19,
	RingOfDefense                            = 20,
	RingOfDeflection                         = 21,
	FullMetalJacket                          = 22,
	RingOfRepulsion                          = 23,
	RingOfPower                              = 24,
	TimeRing                                 = 25,
	RingOfFury                               = 26,
	RingOfWisdom                             = 27,
	RingOfPrecision                          = 28,
	IceRing                                  = 29,
	FireRing                                 = 30,
	LightningRing                            = 31,
	PoisonRing                               = 32,
	ArcaneRing                               = 33,
	ChaoticRing                              = 34,
	ElementalRing                            = 35,
	TurboRing                                = 36,
	AmmoRing                                 = 37,
	RingOfRocketJumping                      = 38,
	SkillRing                                = 39,
	DuplicationRing                          = 40,
	BlacksmithRing                           = 41,
	RingOfDividends                          = 42,
	RingOfValue                              = 43,
	RingOfRegeneratingArmor                  = 44,
	RingOfProtection                         = 45,
	RingOfSwiftness                          = 46,
	RingOfGravity                            = 47,
	RingOfLuck                               = 48,
	RecursiveRing                            = 49,
	GoldenArc                                = 50,
	PortalAmulet                             = 51,
	AbilityRing                              = 52,
	GoldRing                                 = 53,
	TonysCrown                               = 54,
	TwinRing                                 = 55,
	RingOfTankiness                          = 56,
	OverspillGoblet                          = 57,
	RingOfFavoritism                         = 58,
	HoarderBackpack                          = 59,
	UpgradeRing                              = 60,
	CursedRing                               = 61,
	RushedRing                               = 62,
	ECrabRelicType_MAX                       = 63,
};

// Enum CrabChampions.ECrabPerkType
// NumValues: 0x007C
enum class ECrabPerkType : uint8
{
	None                                     = 0,
	Mango                                    = 1,
	Fortitude                                = 2,
	ValuedCustomer                           = 3,
	PersonalSpace                            = 4,
	Bullseye                                 = 5,
	Banana                                   = 6,
	Endurance                                = 7,
	Regenerator                              = 8,
	Scavenger                                = 9,
	HardTarget                               = 10,
	Vitality                                 = 11,
	DamageCombo                              = 12,
	ElementalSpecialist                      = 13,
	ElementalExpert                          = 14,
	Sharpshooter                             = 15,
	HotShot                                  = 16,
	PowerPunch                               = 17,
	CriticalThinking                         = 18,
	CriticalArrow                            = 19,
	ChainReaction                            = 20,
	Efficiency                               = 21,
	Autoloader                               = 22,
	SonicBoom                                = 23,
	SpecialDelivery                          = 24,
	TonysBlackCard                           = 25,
	DangerClose                              = 26,
	EagleEye                                 = 27,
	PowerArmor                               = 28,
	Equalizer                                = 29,
	SpeedDemon                               = 30,
	Stamina                                  = 31,
	Slugger                                  = 32,
	ExplosiveArmor                           = 33,
	FlammableArmor                           = 34,
	PoisonousArmor                           = 35,
	Icebreaker                               = 36,
	HotSteam                                 = 37,
	ArcaneRift                               = 38,
	Frostbite                                = 39,
	BubblingAcid                             = 40,
	IceCold                                  = 41,
	Firestarter                              = 42,
	HighVoltage                              = 43,
	Toxic                                    = 44,
	PotentMagic                              = 45,
	CrystalCombo                             = 46,
	Snatcher                                 = 47,
	Paycheck                                 = 48,
	CrystalFertilizer                        = 49,
	Driller                                  = 50,
	StreamerLoot                             = 51,
	EnhancedTurrets                          = 52,
	TurboTurrets                             = 53,
	TurretFriendship                         = 54,
	DamageAura                               = 55,
	IceAura                                  = 56,
	FireAura                                 = 57,
	LightningAura                            = 58,
	PoisonAura                               = 59,
	OrbitingScythes                          = 60,
	CrimsonHaze                              = 61,
	Shockwave                                = 62,
	GrimReaper                               = 63,
	GraveDodger                              = 64,
	AmberResin                               = 65,
	Bulletproof                              = 66,
	TastyOrange                              = 67,
	SilverLining                             = 68,
	Checklist                                = 69,
	Assassin                                 = 70,
	Gemstone                                 = 71,
	Collector                                = 72,
	MoneyIsPower                             = 73,
	HealthIsPower                            = 74,
	SpeedIsPower                             = 75,
	MegaCrit                                 = 76,
	CriticalBlast                            = 77,
	LingeringFumes                           = 78,
	AllYouCanEat                             = 79,
	BigChests                                = 80,
	PerformanceBonus                         = 81,
	DoubleVision                             = 82,
	SturdyTotems                             = 83,
	BonusCrystals                            = 84,
	GoldCoating                              = 85,
	RareTreasure                             = 86,
	ExplodingEnemies                         = 87,
	FreezingEnemies                          = 88,
	FlammableEnemies                         = 89,
	ElectricEnemies                          = 90,
	PoisonousEnemies                         = 91,
	FaultyChests                             = 92,
	CrystalAsteroids                         = 93,
	BonusChests                              = 94,
	CarePackage                              = 95,
	LevelUp                                  = 96,
	DivineBlessing                           = 97,
	CriticalLightning                        = 98,
	IceDash                                  = 99,
	LightningDash                            = 100,
	DaggerDash                               = 101,
	Powerslide                               = 102,
	StormCloud                               = 103,
	LeapOfFaith                              = 104,
	Bribe                                    = 105,
	DoubleTrouble                            = 106,
	Juggernaut                               = 107,
	BigBones                                 = 108,
	GlassCannon                              = 109,
	DamageSeeker                             = 110,
	BruteForce                               = 111,
	ThinkFast                                = 112,
	MetalClaw                                = 113,
	UpTheAnte                                = 114,
	Untouchable                              = 115,
	SlipperySlope                            = 116,
	DoubleEdgedSword                         = 117,
	Workaholic                               = 118,
	RisingStar                               = 119,
	LimitedLoot                              = 120,
	FlashSale                                = 121,
	HighRoller                               = 122,
	ECrabPerkType_MAX                        = 123,
};

// Enum CrabChampions.ECrabMeleeModType
// NumValues: 0x000E
enum class ECrabMeleeModType : uint8
{
	None                                     = 0,
	Vampire                                  = 1,
	BigClaws                                 = 2,
	SharpClaws                               = 3,
	IronClaws                                = 4,
	TimeClaws                                = 5,
	Blender                                  = 6,
	IceClaws                                 = 7,
	FireClaws                                = 8,
	LightningClaws                           = 9,
	PoisonClaws                              = 10,
	ArcaneClaws                              = 11,
	Brawler                                  = 12,
	ECrabMeleeModType_MAX                    = 13,
};

// Enum CrabChampions.ECrabAbilityModType
// NumValues: 0x003E
enum class ECrabAbilityModType : uint8
{
	None                                     = 0,
	AcceleratingAbility                      = 1,
	LightExplosion                           = 2,
	GlueExplosion                            = 3,
	ChaoticExplosion                         = 4,
	BigAbility                               = 5,
	IronExplosion                            = 6,
	TimeExplosion                            = 7,
	ImplodingExplosion                       = 8,
	BiggerBoom                               = 9,
	WeakExplosion                            = 10,
	SlowExplosion                            = 11,
	HeatSink                                 = 12,
	BouncingExplosion                        = 13,
	DamageExplosion                          = 14,
	TripleAbility                            = 15,
	LayeredExplosion                         = 16,
	AuraExplosion                            = 17,
	BubbleBlast                              = 18,
	DaggerBlast                              = 19,
	FireworkExplosion                        = 20,
	ThornExplosion                           = 21,
	SparkExplosion                           = 22,
	ShrapnelExplosion                        = 23,
	BarrelExplosion                          = 24,
	LandmineExplosion                        = 25,
	ElementalExplosion                       = 26,
	PopcornExplosion                         = 27,
	GiantDrill                               = 28,
	LightningBeam                            = 29,
	PoisonVines                              = 30,
	ToxicCloud                               = 31,
	ArcaneRift                               = 32,
	ArtilleryStrike                          = 33,
	TurretExplosion                          = 34,
	SentryTurret                             = 35,
	SniperTurret                             = 36,
	Grenadier                                = 37,
	DamagingCast                             = 38,
	HealingCast                              = 39,
	SplitAbility                             = 40,
	TargetingExplosion                       = 41,
	CloneExplosion                           = 42,
	BombExplosion                            = 43,
	SpinningBlade                            = 44,
	SporeExplosion                           = 45,
	UltraMushroom                            = 46,
	ScytheVortex                             = 47,
	CrystalBarrage                           = 48,
	EnergyRing                               = 49,
	MOAB                                     = 50,
	StarfishExplosion                        = 51,
	IceExplosion                             = 52,
	FireExplosion                            = 53,
	LightningExplosion                       = 54,
	PoisonExplosion                          = 55,
	SpikeStrike                              = 56,
	CrystalStrike                            = 57,
	MortarTurret                             = 58,
	WaveTurret                               = 59,
	BeamTurret                               = 60,
	ECrabAbilityModType_MAX                  = 61,
};

// Enum CrabChampions.ECrabWeaponModType
// NumValues: 0x005D
enum class ECrabWeaponModType : uint8
{
	None                                     = 0,
	BouncingShot                             = 1,
	AcceleratingShot                         = 2,
	ZigZagShot                               = 3,
	SpiralShot                               = 4,
	SnakeShot                                = 5,
	ChaoticShot                              = 6,
	BoomerangShot                            = 7,
	OrbitingShot                             = 8,
	RecoilShot                               = 9,
	FastShot                                 = 10,
	BigMag                                   = 11,
	HighCaliber                              = 12,
	WindUp                                   = 13,
	SteadyShot                               = 14,
	TrickShot                                = 15,
	AerialShot                               = 16,
	GripTape                                 = 17,
	BlindFire                                = 18,
	TimeShot                                 = 19,
	TimeBolt                                 = 20,
	UltraShot                                = 21,
	SharpShot                                = 22,
	GlueShot                                 = 23,
	BigShot                                  = 24,
	StreakShot                               = 25,
	MagShot                                  = 26,
	Uppercut                                 = 27,
	HeavyShot                                = 28,
	HeavyHitter                              = 29,
	RapidFire                                = 30,
	LightShot                                = 31,
	EscalatingShot                           = 32,
	IceShot                                  = 33,
	FireShot                                 = 34,
	LightningShot                            = 35,
	PoisonShot                               = 36,
	ArcaneShot                               = 37,
	RandomShot                               = 38,
	ReloadArc                                = 39,
	LuckyShot                                = 40,
	TripleShot                               = 41,
	ArcShot                                  = 42,
	XShot                                    = 43,
	SplitShot                                = 44,
	ScatterShot                              = 45,
	TargetingShot                            = 46,
	LinkShot                                 = 47,
	DrillShot                                = 48,
	DoubleTap                                = 49,
	HealthShot                               = 50,
	MoneyShot                                = 51,
	DamageShot                               = 52,
	Supercharged                             = 53,
	Juiced                                   = 54,
	AuraShot                                 = 55,
	PiercingShot                             = 56,
	BubbleShot                               = 57,
	PopcornShot                              = 58,
	PumpkinShot                              = 59,
	DaggerArc                                = 60,
	PiercingWave                             = 61,
	ArcaneBlast                              = 62,
	ShotgunBlast                             = 63,
	MaceShot                                 = 64,
	FireworkShot                             = 65,
	ThornShot                                = 66,
	SparkShot                                = 67,
	Firepower                                = 68,
	SquareShot                               = 69,
	HomingShot                               = 70,
	SplashDamage                             = 71,
	ProximityBarrage                         = 72,
	HomingBlades                             = 73,
	BombShot                                 = 74,
	LandmineShot                             = 75,
	TorpedoShot                              = 76,
	FireballShot                             = 77,
	SharpenedAxe                             = 78,
	TriangleShot                             = 79,
	BeamShot                                 = 80,
	SporeShot                                = 81,
	IceStorm                                 = 82,
	FireStorm                                = 83,
	LightningStorm                           = 84,
	PoisonStorm                              = 85,
	IceStrike                                = 86,
	FireStrike                               = 87,
	LightningStrike                          = 88,
	PoisonStrike                             = 89,
	SpikeStrike                              = 90,
	DiceShot                                 = 91,
	ECrabWeaponModType_MAX                   = 92,
};

// Enum CrabChampions.ECrabMiscPickupType
// NumValues: 0x0005
enum class ECrabMiscPickupType : uint8
{
	None                                     = 0,
	StreamerLootUpgradePickup                = 1,
	AutoLootPickup                           = 2,
	InfinitePedestalPickup                   = 3,
	ECrabMiscPickupType_MAX                  = 4,
};

// Enum CrabChampions.ECrabCurrencyType
// NumValues: 0x0005
enum class ECrabCurrencyType : uint8
{
	Crystal                                  = 0,
	Key                                      = 1,
	Health                                   = 2,
	MaxHealth                                = 3,
	ECrabCurrencyType_MAX                    = 4,
};

// Enum CrabChampions.ECrabEnhancementType
// NumValues: 0x001D
enum class ECrabEnhancementType : uint8
{
	None                                     = 0,
	Bouncing                                 = 1,
	Accelerating                             = 2,
	Zigging                                  = 3,
	Spiraling                                = 4,
	Snaking                                  = 5,
	Returning                                = 6,
	Orbiting                                 = 7,
	Chipping                                 = 8,
	Sticky                                   = 9,
	Growing                                  = 10,
	Freezing                                 = 11,
	Flaming                                  = 12,
	Electrifying                             = 13,
	Toxifying                                = 14,
	Arcanifying                              = 15,
	Persisting                               = 16,
	Doubling                                 = 17,
	Targeting                                = 18,
	Damaging                                 = 19,
	Booming                                  = 20,
	Tripling                                 = 21,
	Splitting                                = 22,
	Scattering                               = 23,
	Expanding                                = 24,
	Homing                                   = 25,
	Endangering                              = 26,
	Random                                   = 27,
	ECrabEnhancementType_MAX                 = 28,
};

// Enum CrabChampions.ECrabEnhanceableType
// NumValues: 0x0005
enum class ECrabEnhanceableType : uint8
{
	NotEnhanceable                           = 0,
	Enhanceable                              = 1,
	EnhanceableNonElemental                  = 2,
	EnhanceableNonHoming                     = 3,
	ECrabEnhanceableType_MAX                 = 4,
};

// Enum CrabChampions.ECrabPickupTag
// NumValues: 0x000E
enum class ECrabPickupTag : uint8
{
	None                                     = 0,
	Healing                                  = 1,
	DamageOverTime                           = 2,
	Critical                                 = 3,
	Speed                                    = 4,
	Bounce                                   = 5,
	Ice                                      = 6,
	Fire                                     = 7,
	Lightning                                = 8,
	Poison                                   = 9,
	Arcane                                   = 10,
	Turret                                   = 11,
	Combo                                    = 12,
	ECrabPickupTag_MAX                       = 13,
};

// Enum CrabChampions.ECrabRarity
// NumValues: 0x0006
enum class ECrabRarity : uint8
{
	None                                     = 0,
	Common                                   = 1,
	Epic                                     = 2,
	Legendary                                = 3,
	Greed                                    = 4,
	ECrabRarity_MAX                          = 5,
};

// Enum CrabChampions.ECrabLootPool
// NumValues: 0x0016
enum class ECrabLootPool : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Critical                                 = 2,
	Elemental                                = 3,
	Speed                                    = 4,
	Luck                                     = 5,
	Health                                   = 6,
	Economy                                  = 7,
	Skill                                    = 8,
	Greed                                    = 9,
	Upgrade                                  = 10,
	Random                                   = 11,
	Anvil                                    = 12,
	RelicChest                               = 13,
	SpikedChest                              = 14,
	EpicChest                                = 15,
	LegendaryChest                           = 16,
	RegenerationChest                        = 17,
	KeyChest                                 = 18,
	Lesser                                   = 19,
	NoRelicsOrConsumables                    = 20,
	ECrabLootPool_MAX                        = 21,
};

// Enum CrabChampions.ECrabPickupType
// NumValues: 0x000C
enum class ECrabPickupType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Ability                                  = 2,
	Melee                                    = 3,
	WeaponMod                                = 4,
	AbilityMod                               = 5,
	MeleeMod                                 = 6,
	Perk                                     = 7,
	Relic                                    = 8,
	Consumable                               = 9,
	Random                                   = 10,
	ECrabPickupType_MAX                      = 11,
};

// Enum CrabChampions.ECrabLesserProjectileType
// NumValues: 0x002A
enum class ECrabLesserProjectileType : uint8
{
	None                                     = 0,
	Duplicate                                = 1,
	Generic                                  = 2,
	TimeBolt                                 = 3,
	UltraShot                                = 4,
	ReloadArc                                = 5,
	LinkShot                                 = 6,
	DrillShot                                = 7,
	BubbleShot                               = 8,
	PumpkinShot                              = 9,
	DaggerArc                                = 10,
	PiercingWave                             = 11,
	ArcaneBlast                              = 12,
	ShotgunBlast                             = 13,
	MaceShot                                 = 14,
	FireworkShot                             = 15,
	ThornShot                                = 16,
	SparkShot                                = 17,
	ProximityBarrage                         = 18,
	HomingBlade                              = 19,
	BombShot                                 = 20,
	TorpedoShot                              = 21,
	FireballShot                             = 22,
	SharpenedAxe                             = 23,
	TriangleShot                             = 24,
	BeamShot                                 = 25,
	BubbleBlast                              = 26,
	DaggerBlast                              = 27,
	FireworkExplosion                        = 28,
	ThornExplosion                           = 29,
	SparkExplosion                           = 30,
	SentryTurret                             = 31,
	SniperTurret                             = 32,
	CloneExplosion                           = 33,
	BombExplosion                            = 34,
	SpinningBlade                            = 35,
	MortarTurret                             = 36,
	WaveTurret                               = 37,
	BeamTurret                               = 38,
	OrbitingScythe                           = 39,
	DaggerDash                               = 40,
	ECrabLesserProjectileType_MAX            = 41,
};

// Enum CrabChampions.ECrabFormationType
// NumValues: 0x001A
enum class ECrabFormationType : uint8
{
	Single                                   = 0,
	Double                                   = 1,
	Triple                                   = 2,
	Quad                                     = 3,
	SmallCluster                             = 4,
	MediumCluster                            = 5,
	LargeCluster                             = 6,
	SmallArc                                 = 7,
	SmallArcTightSpread                      = 8,
	LargeArc                                 = 9,
	LargeArcTightSpread                      = 10,
	TripleArc                                = 11,
	Box                                      = 12,
	Triangle                                 = 13,
	X                                        = 14,
	Square                                   = 15,
	LargeSquare                              = 16,
	Circle                                   = 17,
	LargeCircle                              = 18,
	Line                                     = 19,
	Cross                                    = 20,
	Ring                                     = 21,
	MediumRing                               = 22,
	LargeRing                                = 23,
	Random                                   = 24,
	ECrabFormationType_MAX                   = 25,
};

// Enum CrabChampions.ECrabHitmarkerType
// NumValues: 0x0004
enum class ECrabHitmarkerType : uint8
{
	Quiet                                    = 0,
	Normal                                   = 1,
	Loud                                     = 2,
	ECrabHitmarkerType_MAX                   = 3,
};

// Enum CrabChampions.ECrabCrosshairType
// NumValues: 0x0007
enum class ECrabCrosshairType : uint8
{
	None                                     = 0,
	Cross                                    = 1,
	Circle                                   = 2,
	BrokenCircle                             = 3,
	Dot                                      = 4,
	SniperScope                              = 5,
	ECrabCrosshairType_MAX                   = 6,
};

// Enum CrabChampions.ECrabDamageHitType
// NumValues: 0x0007
enum class ECrabDamageHitType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	ArmorBreak                               = 2,
	Health                                   = 3,
	Crit                                     = 4,
	Elimination                              = 5,
	ECrabDamageHitType_MAX                   = 6,
};

// Enum CrabChampions.ECrabDebuffType
// NumValues: 0x0008
enum class ECrabDebuffType : uint8
{
	None                                     = 0,
	Ice                                      = 1,
	Fire                                     = 2,
	Lightning                                = 3,
	Poison                                   = 4,
	Arcane                                   = 5,
	Last                                     = 6,
	ECrabDebuffType_MAX                      = 7,
};

// Enum CrabChampions.ECrabDamageTagType
// NumValues: 0x0008
enum class ECrabDamageTagType : uint8
{
	None                                     = 0,
	CriticalHit                              = 1,
	DOT                                      = 2,
	HealthShot                               = 3,
	MoneyShot                                = 4,
	Endangering                              = 5,
	ArmorPenetration                         = 6,
	ECrabDamageTagType_MAX                   = 7,
};

// Enum CrabChampions.ECrabDamageType
// NumValues: 0x000E
enum class ECrabDamageType : uint8
{
	None                                     = 0,
	Radial                                   = 1,
	Ability                                  = 2,
	Melee                                    = 3,
	Lesser                                   = 4,
	Knockback                                = 5,
	DOT                                      = 6,
	Ice                                      = 7,
	Fire                                     = 8,
	Lightning                                = 9,
	Arcane                                   = 10,
	Hazard                                   = 11,
	Unblockable                              = 12,
	ECrabDamageType_MAX                      = 13,
};

// Enum CrabChampions.ECrabSpawnPointType
// NumValues: 0x0009
enum class ECrabSpawnPointType : uint8
{
	Player                                   = 0,
	Destructible                             = 1,
	Totem                                    = 2,
	Secret                                   = 3,
	Enemy                                    = 4,
	Reward                                   = 5,
	Portal                                   = 6,
	Shop                                     = 7,
	ECrabSpawnPointType_MAX                  = 8,
};

// Enum CrabChampions.ECrabBiome
// NumValues: 0x0006
enum class ECrabBiome : uint8
{
	None                                     = 0,
	Tropical                                 = 1,
	Arctic                                   = 2,
	Desert                                   = 3,
	Volcanic                                 = 4,
	ECrabBiome_MAX                           = 5,
};

// Enum CrabChampions.ECrabMatchState
// NumValues: 0x0009
enum class ECrabMatchState : uint8
{
	None                                     = 0,
	WaitingToStart                           = 1,
	PortalCountdown                          = 2,
	StartedIsland                            = 3,
	ClearedIsland                            = 4,
	AllPlayersEliminated                     = 5,
	GameOver                                 = 6,
	Restarting                               = 7,
	ECrabMatchState_MAX                      = 8,
};

// Enum CrabChampions.ECrabCosmeticType
// NumValues: 0x0003
enum class ECrabCosmeticType : uint8
{
	CrabSkin                                 = 0,
	WeaponSkin                               = 1,
	ECrabCosmeticType_MAX                    = 2,
};

// Enum CrabChampions.ECrabTintType
// NumValues: 0x0009
enum class ECrabTintType : uint8
{
	None                                     = 0,
	Red                                      = 1,
	Orange                                   = 2,
	Yellow                                   = 3,
	Green                                    = 4,
	Blue                                     = 5,
	Purple                                   = 6,
	Last                                     = 7,
	ECrabTintType_MAX                        = 8,
};

// Enum CrabChampions.ECrabShotSpawnType
// NumValues: 0x0003
enum class ECrabShotSpawnType : uint8
{
	Muzzle                                   = 0,
	AboveCrosshair                           = 1,
	ECrabShotSpawnType_MAX                   = 2,
};

// Enum CrabChampions.ECrabShotDirType
// NumValues: 0x0003
enum class ECrabShotDirType : uint8
{
	CameraDir                                = 0,
	LobDir                                   = 1,
	ECrabShotDirType_MAX                     = 2,
};

// Enum CrabChampions.ECrabFireMode
// NumValues: 0x0003
enum class ECrabFireMode : uint8
{
	Automatic                                = 0,
	Burst                                    = 1,
	ECrabFireMode_MAX                        = 2,
};

// Enum CrabChampions.ECrabTriggerChanceType
// NumValues: 0x0004
enum class ECrabTriggerChanceType : uint8
{
	NotChanceBased                           = 0,
	FullScalingTriggerChance                 = 1,
	HalfScalingTriggerChance                 = 2,
	ECrabTriggerChanceType_MAX               = 3,
};

// ScriptStruct CrabChampions.CrabCosmetic
// 0x0028 (0x0028 - 0x0000)
struct FCrabCosmetic final
{
public:
	ECrabCosmeticType                             CosmeticType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmeticName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CosmeticIcon;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CosmeticObject;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabCosmetic) == 0x000008, "Wrong alignment on FCrabCosmetic");
static_assert(sizeof(FCrabCosmetic) == 0x000028, "Wrong size on FCrabCosmetic");
static_assert(offsetof(FCrabCosmetic, CosmeticType) == 0x000000, "Member 'FCrabCosmetic::CosmeticType' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticName) == 0x000008, "Member 'FCrabCosmetic::CosmeticName' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticIcon) == 0x000018, "Member 'FCrabCosmetic::CosmeticIcon' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticObject) == 0x000020, "Member 'FCrabCosmetic::CosmeticObject' has a wrong offset!");

// ScriptStruct CrabChampions.CrabChallenge
// 0x0050 (0x0050 - 0x0000)
struct FCrabChallenge final
{
public:
	class FName                                   ChallengeID;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeDescription;                              // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgress;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeGoal;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChallengeCompleted;                               // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabCosmetic                          CosmeticReward;                                    // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabChallenge) == 0x000008, "Wrong alignment on FCrabChallenge");
static_assert(sizeof(FCrabChallenge) == 0x000050, "Wrong size on FCrabChallenge");
static_assert(offsetof(FCrabChallenge, ChallengeID) == 0x000000, "Member 'FCrabChallenge::ChallengeID' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeDescription) == 0x000008, "Member 'FCrabChallenge::ChallengeDescription' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeProgress) == 0x000018, "Member 'FCrabChallenge::ChallengeProgress' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeGoal) == 0x00001C, "Member 'FCrabChallenge::ChallengeGoal' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, bChallengeCompleted) == 0x000020, "Member 'FCrabChallenge::bChallengeCompleted' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, CosmeticReward) == 0x000028, "Member 'FCrabChallenge::CosmeticReward' has a wrong offset!");

// ScriptStruct CrabChampions.ClientAuthoritativeMoveData
// 0x0050 (0x0050 - 0x0000)
struct FClientAuthoritativeMoveData final
{
public:
	struct FVector_NetQuantize10                  Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Velocity;                                          // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation;                                   // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         MovementMode;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    BasedMovementBase;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BasedMovementBaseBoneName;                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBasedHasRelativeRotation;                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientAuthoritativeMoveData) == 0x000008, "Wrong alignment on FClientAuthoritativeMoveData");
static_assert(sizeof(FClientAuthoritativeMoveData) == 0x000050, "Wrong size on FClientAuthoritativeMoveData");
static_assert(offsetof(FClientAuthoritativeMoveData, Location) == 0x000000, "Member 'FClientAuthoritativeMoveData::Location' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, Rotation) == 0x00000C, "Member 'FClientAuthoritativeMoveData::Rotation' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, Velocity) == 0x000018, "Member 'FClientAuthoritativeMoveData::Velocity' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, ControlRotation) == 0x000024, "Member 'FClientAuthoritativeMoveData::ControlRotation' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, MovementMode) == 0x000030, "Member 'FClientAuthoritativeMoveData::MovementMode' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, BasedMovementBase) == 0x000038, "Member 'FClientAuthoritativeMoveData::BasedMovementBase' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, BasedMovementBaseBoneName) == 0x000040, "Member 'FClientAuthoritativeMoveData::BasedMovementBaseBoneName' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, bBasedHasRelativeRotation) == 0x000048, "Member 'FClientAuthoritativeMoveData::bBasedHasRelativeRotation' has a wrong offset!");

// ScriptStruct CrabChampions.CrabEnemySpawnSettings
// 0x0028 (0x0028 - 0x0000)
struct FCrabEnemySpawnSettings final
{
public:
	int32                                         IslandToStartSpawningAt;                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySpawnIfLooping;                               // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabIslandType>                       BannedIslandTypes;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsEvolvedEnemy;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExplosiveEnemy;                                 // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnCost;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnLimit;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabEnemySpawnSettings) == 0x000008, "Wrong alignment on FCrabEnemySpawnSettings");
static_assert(sizeof(FCrabEnemySpawnSettings) == 0x000028, "Wrong size on FCrabEnemySpawnSettings");
static_assert(offsetof(FCrabEnemySpawnSettings, IslandToStartSpawningAt) == 0x000000, "Member 'FCrabEnemySpawnSettings::IslandToStartSpawningAt' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bOnlySpawnIfLooping) == 0x000004, "Member 'FCrabEnemySpawnSettings::bOnlySpawnIfLooping' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, BannedIslandTypes) == 0x000008, "Member 'FCrabEnemySpawnSettings::BannedIslandTypes' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bIsEvolvedEnemy) == 0x000018, "Member 'FCrabEnemySpawnSettings::bIsEvolvedEnemy' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bIsExplosiveEnemy) == 0x000019, "Member 'FCrabEnemySpawnSettings::bIsExplosiveEnemy' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnCost) == 0x00001C, "Member 'FCrabEnemySpawnSettings::SpawnCost' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnWeight) == 0x000020, "Member 'FCrabEnemySpawnSettings::SpawnWeight' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnLimit) == 0x000024, "Member 'FCrabEnemySpawnSettings::SpawnLimit' has a wrong offset!");

// ScriptStruct CrabChampions.CrabLightingPreset
// 0x00A0 (0x00A0 - 0x0000)
struct FCrabLightingPreset final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SkydomeMI;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkydomeRotation;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLHeight;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLRotation;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLIntensity;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DLTint;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SLIntensity;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SLTint;                                            // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SLHemisphereTint;                                  // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SLMinOcclusion;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SLOcclusionTint;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PPTemperature;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFDensity;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFHeightFalloff;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HFTint;                                            // 0x0068(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFStartDistance;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OceanMI;                                           // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnderwaterPPTint;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabBiomeDA*                           BiomeDA;                                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabLightingPreset) == 0x000008, "Wrong alignment on FCrabLightingPreset");
static_assert(sizeof(FCrabLightingPreset) == 0x0000A0, "Wrong size on FCrabLightingPreset");
static_assert(offsetof(FCrabLightingPreset, Weight) == 0x000000, "Member 'FCrabLightingPreset::Weight' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SkydomeMI) == 0x000008, "Member 'FCrabLightingPreset::SkydomeMI' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SkydomeRotation) == 0x000010, "Member 'FCrabLightingPreset::SkydomeRotation' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLHeight) == 0x000014, "Member 'FCrabLightingPreset::DLHeight' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLRotation) == 0x000018, "Member 'FCrabLightingPreset::DLRotation' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLIntensity) == 0x00001C, "Member 'FCrabLightingPreset::DLIntensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLTint) == 0x000020, "Member 'FCrabLightingPreset::DLTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLIntensity) == 0x000030, "Member 'FCrabLightingPreset::SLIntensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLTint) == 0x000034, "Member 'FCrabLightingPreset::SLTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLHemisphereTint) == 0x000044, "Member 'FCrabLightingPreset::SLHemisphereTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLMinOcclusion) == 0x000054, "Member 'FCrabLightingPreset::SLMinOcclusion' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLOcclusionTint) == 0x000058, "Member 'FCrabLightingPreset::SLOcclusionTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, PPTemperature) == 0x00005C, "Member 'FCrabLightingPreset::PPTemperature' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFDensity) == 0x000060, "Member 'FCrabLightingPreset::HFDensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFHeightFalloff) == 0x000064, "Member 'FCrabLightingPreset::HFHeightFalloff' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFTint) == 0x000068, "Member 'FCrabLightingPreset::HFTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFStartDistance) == 0x000078, "Member 'FCrabLightingPreset::HFStartDistance' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, OceanMI) == 0x000080, "Member 'FCrabLightingPreset::OceanMI' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, UnderwaterPPTint) == 0x000088, "Member 'FCrabLightingPreset::UnderwaterPPTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, BiomeDA) == 0x000098, "Member 'FCrabLightingPreset::BiomeDA' has a wrong offset!");

// ScriptStruct CrabChampions.CrabProjectileModInfo
// 0x0028 (0x0028 - 0x0000)
struct FCrabProjectileModInfo final
{
public:
	float                                         DamageMultiplier;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlatDamageBonus;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMultiplier;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifetimeMultiplier;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeMultiplier;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationBonus;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityMultiplier;                                 // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingScale;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBounces;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabProjectileModInfo) == 0x000004, "Wrong alignment on FCrabProjectileModInfo");
static_assert(sizeof(FCrabProjectileModInfo) == 0x000028, "Wrong size on FCrabProjectileModInfo");
static_assert(offsetof(FCrabProjectileModInfo, DamageMultiplier) == 0x000000, "Member 'FCrabProjectileModInfo::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, FlatDamageBonus) == 0x000004, "Member 'FCrabProjectileModInfo::FlatDamageBonus' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, RadiusMultiplier) == 0x000008, "Member 'FCrabProjectileModInfo::RadiusMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, LifetimeMultiplier) == 0x00000C, "Member 'FCrabProjectileModInfo::LifetimeMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, SizeMultiplier) == 0x000010, "Member 'FCrabProjectileModInfo::SizeMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, SpeedMultiplier) == 0x000014, "Member 'FCrabProjectileModInfo::SpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, AccelerationBonus) == 0x000018, "Member 'FCrabProjectileModInfo::AccelerationBonus' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, GravityMultiplier) == 0x00001C, "Member 'FCrabProjectileModInfo::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, HomingScale) == 0x000020, "Member 'FCrabProjectileModInfo::HomingScale' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, NumBounces) == 0x000024, "Member 'FCrabProjectileModInfo::NumBounces' has a wrong offset!");

// ScriptStruct CrabChampions.CrabStrikeInfo
// 0x0010 (0x0010 - 0x0000)
struct FCrabStrikeInfo final
{
public:
	class ACrabC*                                 OwningC;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMultiplier;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabStrikeInfo) == 0x000008, "Wrong alignment on FCrabStrikeInfo");
static_assert(sizeof(FCrabStrikeInfo) == 0x000010, "Wrong size on FCrabStrikeInfo");
static_assert(offsetof(FCrabStrikeInfo, OwningC) == 0x000000, "Member 'FCrabStrikeInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabStrikeInfo, RadiusMultiplier) == 0x000008, "Member 'FCrabStrikeInfo::RadiusMultiplier' has a wrong offset!");

// ScriptStruct CrabChampions.CrabLobbyStats
// 0x0058 (0x0058 - 0x0000)
struct FCrabLobbyStats final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Difficulty;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attempts;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wins;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreak;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighestIslandReached;                              // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompletedChallenges;                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedWeapons;                                // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedAbilities;                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedMeleeWeapons;                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedWeaponMods;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedAbilityMods;                            // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedMeleeMods;                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedPerks;                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedRelics;                                 // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabLobbyStats) == 0x000008, "Wrong alignment on FCrabLobbyStats");
static_assert(sizeof(FCrabLobbyStats) == 0x000058, "Wrong size on FCrabLobbyStats");
static_assert(offsetof(FCrabLobbyStats, PlayerName) == 0x000000, "Member 'FCrabLobbyStats::PlayerName' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Difficulty) == 0x000010, "Member 'FCrabLobbyStats::Difficulty' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Attempts) == 0x000020, "Member 'FCrabLobbyStats::Attempts' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Wins) == 0x000024, "Member 'FCrabLobbyStats::Wins' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, WinStreak) == 0x000028, "Member 'FCrabLobbyStats::WinStreak' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, HighestIslandReached) == 0x00002C, "Member 'FCrabLobbyStats::HighestIslandReached' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumCompletedChallenges) == 0x000030, "Member 'FCrabLobbyStats::NumCompletedChallenges' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedWeapons) == 0x000034, "Member 'FCrabLobbyStats::NumUnlockedWeapons' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedAbilities) == 0x000038, "Member 'FCrabLobbyStats::NumUnlockedAbilities' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedMeleeWeapons) == 0x00003C, "Member 'FCrabLobbyStats::NumUnlockedMeleeWeapons' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedWeaponMods) == 0x000040, "Member 'FCrabLobbyStats::NumUnlockedWeaponMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedAbilityMods) == 0x000044, "Member 'FCrabLobbyStats::NumUnlockedAbilityMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedMeleeMods) == 0x000048, "Member 'FCrabLobbyStats::NumUnlockedMeleeMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedPerks) == 0x00004C, "Member 'FCrabLobbyStats::NumUnlockedPerks' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedRelics) == 0x000050, "Member 'FCrabLobbyStats::NumUnlockedRelics' has a wrong offset!");

// ScriptStruct CrabChampions.CrabInventoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabInventoryInfo final
{
public:
	uint8                                         Level;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabEnhancementType>                  Enhancements;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AccumulatedBuff;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabInventoryInfo) == 0x000008, "Wrong alignment on FCrabInventoryInfo");
static_assert(sizeof(FCrabInventoryInfo) == 0x000020, "Wrong size on FCrabInventoryInfo");
static_assert(offsetof(FCrabInventoryInfo, Level) == 0x000000, "Member 'FCrabInventoryInfo::Level' has a wrong offset!");
static_assert(offsetof(FCrabInventoryInfo, Enhancements) == 0x000008, "Member 'FCrabInventoryInfo::Enhancements' has a wrong offset!");
static_assert(offsetof(FCrabInventoryInfo, AccumulatedBuff) == 0x000018, "Member 'FCrabInventoryInfo::AccumulatedBuff' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPerk
// 0x0028 (0x0028 - 0x0000)
struct FCrabPerk final
{
public:
	class UCrabPerkDA*                            PerkDA;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPerk) == 0x000008, "Wrong alignment on FCrabPerk");
static_assert(sizeof(FCrabPerk) == 0x000028, "Wrong size on FCrabPerk");
static_assert(offsetof(FCrabPerk, PerkDA) == 0x000000, "Member 'FCrabPerk::PerkDA' has a wrong offset!");
static_assert(offsetof(FCrabPerk, InventoryInfo) == 0x000008, "Member 'FCrabPerk::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabNextIslandInfo
// 0x0030 (0x0030 - 0x0000)
struct FCrabNextIslandInfo final
{
public:
	bool                                          bIsContinuingRun;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabBiome                                    Biome;                                             // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIsland;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IslandName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabIslandType                               IslandType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECrabBlessing                                 Blessing;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 RewardLootPool;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabNextIslandInfo) == 0x000008, "Wrong alignment on FCrabNextIslandInfo");
static_assert(sizeof(FCrabNextIslandInfo) == 0x000030, "Wrong size on FCrabNextIslandInfo");
static_assert(offsetof(FCrabNextIslandInfo, bIsContinuingRun) == 0x000000, "Member 'FCrabNextIslandInfo::bIsContinuingRun' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, Biome) == 0x000001, "Member 'FCrabNextIslandInfo::Biome' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, CurrentIsland) == 0x000004, "Member 'FCrabNextIslandInfo::CurrentIsland' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, IslandName) == 0x000008, "Member 'FCrabNextIslandInfo::IslandName' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, IslandType) == 0x000010, "Member 'FCrabNextIslandInfo::IslandType' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, ChallengeModifiers) == 0x000018, "Member 'FCrabNextIslandInfo::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, Blessing) == 0x000028, "Member 'FCrabNextIslandInfo::Blessing' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, RewardLootPool) == 0x000029, "Member 'FCrabNextIslandInfo::RewardLootPool' has a wrong offset!");

// ScriptStruct CrabChampions.CrabHealthInfo
// 0x001C (0x001C - 0x0000)
struct FCrabHealthInfo final
{
public:
	int32                                         CurrentArmorPlates;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentArmorPlateHealth;                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousArmorPlateHealth;                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHealth;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMaxHealth;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousHealth;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousMaxHealth;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabHealthInfo) == 0x000004, "Wrong alignment on FCrabHealthInfo");
static_assert(sizeof(FCrabHealthInfo) == 0x00001C, "Wrong size on FCrabHealthInfo");
static_assert(offsetof(FCrabHealthInfo, CurrentArmorPlates) == 0x000000, "Member 'FCrabHealthInfo::CurrentArmorPlates' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentArmorPlateHealth) == 0x000004, "Member 'FCrabHealthInfo::CurrentArmorPlateHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousArmorPlateHealth) == 0x000008, "Member 'FCrabHealthInfo::PreviousArmorPlateHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentHealth) == 0x00000C, "Member 'FCrabHealthInfo::CurrentHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentMaxHealth) == 0x000010, "Member 'FCrabHealthInfo::CurrentMaxHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousHealth) == 0x000014, "Member 'FCrabHealthInfo::PreviousHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousMaxHealth) == 0x000018, "Member 'FCrabHealthInfo::PreviousMaxHealth' has a wrong offset!");

// ScriptStruct CrabChampions.CrabWeaponMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabWeaponMod final
{
public:
	class UCrabWeaponModDA*                       WeaponModDA;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabWeaponMod) == 0x000008, "Wrong alignment on FCrabWeaponMod");
static_assert(sizeof(FCrabWeaponMod) == 0x000028, "Wrong size on FCrabWeaponMod");
static_assert(offsetof(FCrabWeaponMod, WeaponModDA) == 0x000000, "Member 'FCrabWeaponMod::WeaponModDA' has a wrong offset!");
static_assert(offsetof(FCrabWeaponMod, InventoryInfo) == 0x000008, "Member 'FCrabWeaponMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAbilityMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabAbilityMod final
{
public:
	class UCrabAbilityModDA*                      AbilityModDA;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAbilityMod) == 0x000008, "Wrong alignment on FCrabAbilityMod");
static_assert(sizeof(FCrabAbilityMod) == 0x000028, "Wrong size on FCrabAbilityMod");
static_assert(offsetof(FCrabAbilityMod, AbilityModDA) == 0x000000, "Member 'FCrabAbilityMod::AbilityModDA' has a wrong offset!");
static_assert(offsetof(FCrabAbilityMod, InventoryInfo) == 0x000008, "Member 'FCrabAbilityMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabMeleeMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabMeleeMod final
{
public:
	class UCrabMeleeModDA*                        MeleeModDA;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabMeleeMod) == 0x000008, "Wrong alignment on FCrabMeleeMod");
static_assert(sizeof(FCrabMeleeMod) == 0x000028, "Wrong size on FCrabMeleeMod");
static_assert(offsetof(FCrabMeleeMod, MeleeModDA) == 0x000000, "Member 'FCrabMeleeMod::MeleeModDA' has a wrong offset!");
static_assert(offsetof(FCrabMeleeMod, InventoryInfo) == 0x000008, "Member 'FCrabMeleeMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabRelic
// 0x0028 (0x0028 - 0x0000)
struct FCrabRelic final
{
public:
	class UCrabRelicDA*                           RelicDA;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabRelic) == 0x000008, "Wrong alignment on FCrabRelic");
static_assert(sizeof(FCrabRelic) == 0x000028, "Wrong size on FCrabRelic");
static_assert(offsetof(FCrabRelic, RelicDA) == 0x000000, "Member 'FCrabRelic::RelicDA' has a wrong offset!");
static_assert(offsetof(FCrabRelic, InventoryInfo) == 0x000008, "Member 'FCrabRelic::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAutoSave
// 0x0148 (0x0148 - 0x0000)
struct FCrabAutoSave final
{
public:
	int32                                         CurrentTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDifficulty                               Difficulty;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCrabNextIslandInfo                    NextIslandInfo;                                    // 0x0018(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ComboCounter;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Combo;                                             // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Eliminations;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsFired;                                        // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DamageDealt;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        HighestDamageDealt;                                // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageTaken;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFlawlessIslands;                                // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x0068(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BaseMaxHealth;                                     // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealthMultiplier;                               // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumWeaponModSlots;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumAbilityModSlots;                                // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabAbilityMod>                AbilityMods;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumMeleeModSlots;                                  // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabMeleeMod>                  MeleeMods;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumPerkSlots;                                      // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabPerk>                      Perks;                                             // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabRelic>                     Relics;                                            // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NumTimesSalvaged;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShopPurchases;                                  // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShopRerolls;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTotemsDestroyed;                                // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Crystals;                                          // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTimeTaken;                                    // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAutoSave) == 0x000008, "Wrong alignment on FCrabAutoSave");
static_assert(sizeof(FCrabAutoSave) == 0x000148, "Wrong size on FCrabAutoSave");
static_assert(offsetof(FCrabAutoSave, CurrentTime) == 0x000000, "Member 'FCrabAutoSave::CurrentTime' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Difficulty) == 0x000004, "Member 'FCrabAutoSave::Difficulty' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DifficultyModifiers) == 0x000008, "Member 'FCrabAutoSave::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NextIslandInfo) == 0x000018, "Member 'FCrabAutoSave::NextIslandInfo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ComboCounter) == 0x000048, "Member 'FCrabAutoSave::ComboCounter' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Combo) == 0x00004C, "Member 'FCrabAutoSave::Combo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Eliminations) == 0x000050, "Member 'FCrabAutoSave::Eliminations' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ShotsFired) == 0x000054, "Member 'FCrabAutoSave::ShotsFired' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageDealt) == 0x000058, "Member 'FCrabAutoSave::DamageDealt' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, HighestDamageDealt) == 0x00005C, "Member 'FCrabAutoSave::HighestDamageDealt' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageTaken) == 0x000060, "Member 'FCrabAutoSave::DamageTaken' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumFlawlessIslands) == 0x000064, "Member 'FCrabAutoSave::NumFlawlessIslands' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, HealthInfo) == 0x000068, "Member 'FCrabAutoSave::HealthInfo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, BaseMaxHealth) == 0x000084, "Member 'FCrabAutoSave::BaseMaxHealth' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MaxHealthMultiplier) == 0x000088, "Member 'FCrabAutoSave::MaxHealthMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageMultiplier) == 0x00008C, "Member 'FCrabAutoSave::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ScaleMultiplier) == 0x000090, "Member 'FCrabAutoSave::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, WeaponDA) == 0x000098, "Member 'FCrabAutoSave::WeaponDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, AbilityDA) == 0x0000A0, "Member 'FCrabAutoSave::AbilityDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MeleeDA) == 0x0000A8, "Member 'FCrabAutoSave::MeleeDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumWeaponModSlots) == 0x0000B0, "Member 'FCrabAutoSave::NumWeaponModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, WeaponMods) == 0x0000B8, "Member 'FCrabAutoSave::WeaponMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumAbilityModSlots) == 0x0000C8, "Member 'FCrabAutoSave::NumAbilityModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, AbilityMods) == 0x0000D0, "Member 'FCrabAutoSave::AbilityMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumMeleeModSlots) == 0x0000E0, "Member 'FCrabAutoSave::NumMeleeModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MeleeMods) == 0x0000E8, "Member 'FCrabAutoSave::MeleeMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumPerkSlots) == 0x0000F8, "Member 'FCrabAutoSave::NumPerkSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Perks) == 0x000100, "Member 'FCrabAutoSave::Perks' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Relics) == 0x000110, "Member 'FCrabAutoSave::Relics' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumTimesSalvaged) == 0x000120, "Member 'FCrabAutoSave::NumTimesSalvaged' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumShopPurchases) == 0x000124, "Member 'FCrabAutoSave::NumShopPurchases' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumShopRerolls) == 0x000128, "Member 'FCrabAutoSave::NumShopRerolls' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumTotemsDestroyed) == 0x00012C, "Member 'FCrabAutoSave::NumTotemsDestroyed' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Crystals) == 0x000130, "Member 'FCrabAutoSave::Crystals' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, TotalTimeTaken) == 0x000134, "Member 'FCrabAutoSave::TotalTimeTaken' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, CompletedChallenges) == 0x000138, "Member 'FCrabAutoSave::CompletedChallenges' has a wrong offset!");

// ScriptStruct CrabChampions.CrabEnemyStats
// 0x0010 (0x0010 - 0x0000)
struct FCrabEnemyStats final
{
public:
	float                                         HealthMultiplier;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeedMultiplier;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabEnemyStats) == 0x000004, "Wrong alignment on FCrabEnemyStats");
static_assert(sizeof(FCrabEnemyStats) == 0x000010, "Wrong size on FCrabEnemyStats");
static_assert(offsetof(FCrabEnemyStats, HealthMultiplier) == 0x000000, "Member 'FCrabEnemyStats::HealthMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, MovementSpeedMultiplier) == 0x000004, "Member 'FCrabEnemyStats::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, ActionSpeedMultiplier) == 0x000008, "Member 'FCrabEnemyStats::ActionSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, DamageMultiplier) == 0x00000C, "Member 'FCrabEnemyStats::DamageMultiplier' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAISettings
// 0x0028 (0x0028 - 0x0000)
struct FCrabAISettings final
{
public:
	ECrabEnemyMovementType                        MovementType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenMoves;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpProbability;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashProbability;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActionsMin;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActionsMax;                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEnvQuery*>                      RangedActionEnvQueries;                            // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAISettings) == 0x000008, "Wrong alignment on FCrabAISettings");
static_assert(sizeof(FCrabAISettings) == 0x000028, "Wrong size on FCrabAISettings");
static_assert(offsetof(FCrabAISettings, MovementType) == 0x000000, "Member 'FCrabAISettings::MovementType' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenMoves) == 0x000004, "Member 'FCrabAISettings::TimeBetweenMoves' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, JumpProbability) == 0x000008, "Member 'FCrabAISettings::JumpProbability' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, DashProbability) == 0x00000C, "Member 'FCrabAISettings::DashProbability' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenActionsMin) == 0x000010, "Member 'FCrabAISettings::TimeBetweenActionsMin' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenActionsMax) == 0x000014, "Member 'FCrabAISettings::TimeBetweenActionsMax' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, RangedActionEnvQueries) == 0x000018, "Member 'FCrabAISettings::RangedActionEnvQueries' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPortalInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabPortalInfo final
{
public:
	bool                                          bIsInited;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECrabBlessing                                 Blessing;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 RewardLootPool;                                    // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabPortalInfo) == 0x000008, "Wrong alignment on FCrabPortalInfo");
static_assert(sizeof(FCrabPortalInfo) == 0x000020, "Wrong size on FCrabPortalInfo");
static_assert(offsetof(FCrabPortalInfo, bIsInited) == 0x000000, "Member 'FCrabPortalInfo::bIsInited' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, ChallengeModifiers) == 0x000008, "Member 'FCrabPortalInfo::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, Blessing) == 0x000018, "Member 'FCrabPortalInfo::Blessing' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, RewardLootPool) == 0x000019, "Member 'FCrabPortalInfo::RewardLootPool' has a wrong offset!");

// ScriptStruct CrabChampions.CrabContract
// 0x000C (0x000C - 0x0000)
struct FCrabContract final
{
public:
	ECrabContractType                             ContractType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Progress;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabContract) == 0x000004, "Wrong alignment on FCrabContract");
static_assert(sizeof(FCrabContract) == 0x00000C, "Wrong size on FCrabContract");
static_assert(offsetof(FCrabContract, ContractType) == 0x000000, "Member 'FCrabContract::ContractType' has a wrong offset!");
static_assert(offsetof(FCrabContract, Progress) == 0x000004, "Member 'FCrabContract::Progress' has a wrong offset!");
static_assert(offsetof(FCrabContract, Goal) == 0x000008, "Member 'FCrabContract::Goal' has a wrong offset!");

// ScriptStruct CrabChampions.CrabIsland
// 0x000C (0x000C - 0x0000)
struct FCrabIsland final
{
public:
	class FName                                   IslandName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabIsland) == 0x000004, "Wrong alignment on FCrabIsland");
static_assert(sizeof(FCrabIsland) == 0x00000C, "Wrong size on FCrabIsland");
static_assert(offsetof(FCrabIsland, IslandName) == 0x000000, "Member 'FCrabIsland::IslandName' has a wrong offset!");
static_assert(offsetof(FCrabIsland, SpawnWeight) == 0x000008, "Member 'FCrabIsland::SpawnWeight' has a wrong offset!");

// ScriptStruct CrabChampions.CrabRankedWeapon
// 0x0010 (0x0010 - 0x0000)
struct FCrabRankedWeapon final
{
public:
	class UCrabPickupDA*                          Weapon;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabRank                                     Rank;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabRankedWeapon) == 0x000008, "Wrong alignment on FCrabRankedWeapon");
static_assert(sizeof(FCrabRankedWeapon) == 0x000010, "Wrong size on FCrabRankedWeapon");
static_assert(offsetof(FCrabRankedWeapon, Weapon) == 0x000000, "Member 'FCrabRankedWeapon::Weapon' has a wrong offset!");
static_assert(offsetof(FCrabRankedWeapon, Rank) == 0x000008, "Member 'FCrabRankedWeapon::Rank' has a wrong offset!");

// ScriptStruct CrabChampions.CrabInventoryCooldown
// 0x0010 (0x0010 - 0x0000)
struct FCrabInventoryCooldown final
{
public:
	class UCrabInventoryDA*                       InventoryDA;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentCooldown;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabInventoryCooldown) == 0x000008, "Wrong alignment on FCrabInventoryCooldown");
static_assert(sizeof(FCrabInventoryCooldown) == 0x000010, "Wrong size on FCrabInventoryCooldown");
static_assert(offsetof(FCrabInventoryCooldown, InventoryDA) == 0x000000, "Member 'FCrabInventoryCooldown::InventoryDA' has a wrong offset!");
static_assert(offsetof(FCrabInventoryCooldown, CurrentCooldown) == 0x000008, "Member 'FCrabInventoryCooldown::CurrentCooldown' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPedestalInfo
// 0x000C (0x000C - 0x0000)
struct FCrabPedestalInfo final
{
public:
	ECrabCurrencyType                             CurrencyType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPedestalInfo) == 0x000004, "Wrong alignment on FCrabPedestalInfo");
static_assert(sizeof(FCrabPedestalInfo) == 0x00000C, "Wrong size on FCrabPedestalInfo");
static_assert(offsetof(FCrabPedestalInfo, CurrencyType) == 0x000000, "Member 'FCrabPedestalInfo::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCrabPedestalInfo, Cost) == 0x000004, "Member 'FCrabPedestalInfo::Cost' has a wrong offset!");
static_assert(offsetof(FCrabPedestalInfo, DiscountPercentage) == 0x000008, "Member 'FCrabPedestalInfo::DiscountPercentage' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPickupInfo
// 0x0050 (0x0050 - 0x0000)
struct FCrabPickupInfo final
{
public:
	class UCrabPickupDA*                          PickupDA;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         MaxPickups;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabCurrencyType                             CurrencyType;                                      // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SalvageReward;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabPS*                                OwningPS;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    CosmeticSpawnLoc;                                  // 0x0040(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLocationUI;                                   // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabMiscPickupType                           MiscPickupType;                                    // 0x004D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabPickupInfo) == 0x000008, "Wrong alignment on FCrabPickupInfo");
static_assert(sizeof(FCrabPickupInfo) == 0x000050, "Wrong size on FCrabPickupInfo");
static_assert(offsetof(FCrabPickupInfo, PickupDA) == 0x000000, "Member 'FCrabPickupInfo::PickupDA' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, InventoryInfo) == 0x000008, "Member 'FCrabPickupInfo::InventoryInfo' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, MaxPickups) == 0x000028, "Member 'FCrabPickupInfo::MaxPickups' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, CurrencyType) == 0x000029, "Member 'FCrabPickupInfo::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, Cost) == 0x00002C, "Member 'FCrabPickupInfo::Cost' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, SalvageReward) == 0x000030, "Member 'FCrabPickupInfo::SalvageReward' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, OwningPS) == 0x000038, "Member 'FCrabPickupInfo::OwningPS' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, CosmeticSpawnLoc) == 0x000040, "Member 'FCrabPickupInfo::CosmeticSpawnLoc' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, bShowLocationUI) == 0x00004C, "Member 'FCrabPickupInfo::bShowLocationUI' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, MiscPickupType) == 0x00004D, "Member 'FCrabPickupInfo::MiscPickupType' has a wrong offset!");

// ScriptStruct CrabChampions.CrabProjectileInfo
// 0x0030 (0x0030 - 0x0000)
struct FCrabProjectileInfo final
{
public:
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Dir;                                               // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 OwningC;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLesserProjectileType                     LesserProjectileType;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParentLesserProjectile;                         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToTempMoveIgnore;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabProjectileInfo) == 0x000008, "Wrong alignment on FCrabProjectileInfo");
static_assert(sizeof(FCrabProjectileInfo) == 0x000030, "Wrong size on FCrabProjectileInfo");
static_assert(offsetof(FCrabProjectileInfo, ProjectileDA) == 0x000000, "Member 'FCrabProjectileInfo::ProjectileDA' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, Dir) == 0x000008, "Member 'FCrabProjectileInfo::Dir' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, OwningC) == 0x000018, "Member 'FCrabProjectileInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, LesserProjectileType) == 0x000020, "Member 'FCrabProjectileInfo::LesserProjectileType' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, bIsParentLesserProjectile) == 0x000021, "Member 'FCrabProjectileInfo::bIsParentLesserProjectile' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, ActorToTempMoveIgnore) == 0x000028, "Member 'FCrabProjectileInfo::ActorToTempMoveIgnore' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDebuffState
// 0x0014 (0x0014 - 0x0000)
struct FCrabDebuffState final
{
public:
	int32                                         IceStack;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireStack;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningStack;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoisonStack;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneStack;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDebuffState) == 0x000004, "Wrong alignment on FCrabDebuffState");
static_assert(sizeof(FCrabDebuffState) == 0x000014, "Wrong size on FCrabDebuffState");
static_assert(offsetof(FCrabDebuffState, IceStack) == 0x000000, "Member 'FCrabDebuffState::IceStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, FireStack) == 0x000004, "Member 'FCrabDebuffState::FireStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, LightningStack) == 0x000008, "Member 'FCrabDebuffState::LightningStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, PoisonStack) == 0x00000C, "Member 'FCrabDebuffState::PoisonStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, ArcaneStack) == 0x000010, "Member 'FCrabDebuffState::ArcaneStack' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDebuff
// 0x0008 (0x0008 - 0x0000)
struct FCrabDebuff final
{
public:
	ECrabDebuffType                               DebuffType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebuffStack;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDebuff) == 0x000004, "Wrong alignment on FCrabDebuff");
static_assert(sizeof(FCrabDebuff) == 0x000008, "Wrong size on FCrabDebuff");
static_assert(offsetof(FCrabDebuff, DebuffType) == 0x000000, "Member 'FCrabDebuff::DebuffType' has a wrong offset!");
static_assert(offsetof(FCrabDebuff, DebuffStack) == 0x000004, "Member 'FCrabDebuff::DebuffStack' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDamageInfo
// 0x0048 (0x0048 - 0x0000)
struct FCrabDamageInfo final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDamageType                               CrabDamageType;                                    // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDamageTagType>                    DamageTags;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCrabDebuff>                    Debuffs;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageLoc;                                         // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackStrength;                                 // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 DamagingC;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDamageInfo) == 0x000008, "Wrong alignment on FCrabDamageInfo");
static_assert(sizeof(FCrabDamageInfo) == 0x000048, "Wrong size on FCrabDamageInfo");
static_assert(offsetof(FCrabDamageInfo, DamagedActor) == 0x000000, "Member 'FCrabDamageInfo::DamagedActor' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, Damage) == 0x000008, "Member 'FCrabDamageInfo::Damage' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, CrabDamageType) == 0x00000C, "Member 'FCrabDamageInfo::CrabDamageType' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamageTags) == 0x000010, "Member 'FCrabDamageInfo::DamageTags' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, Debuffs) == 0x000020, "Member 'FCrabDamageInfo::Debuffs' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamageLoc) == 0x000030, "Member 'FCrabDamageInfo::DamageLoc' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, KnockbackStrength) == 0x00003C, "Member 'FCrabDamageInfo::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamagingC) == 0x000040, "Member 'FCrabDamageInfo::DamagingC' has a wrong offset!");

// ScriptStruct CrabChampions.CrabExplosionFX
// 0x0048 (0x0048 - 0x0000)
struct FCrabExplosionFX final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Sound;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabExplosionFX) == 0x000008, "Wrong alignment on FCrabExplosionFX");
static_assert(sizeof(FCrabExplosionFX) == 0x000048, "Wrong size on FCrabExplosionFX");
static_assert(offsetof(FCrabExplosionFX, Loc) == 0x000000, "Member 'FCrabExplosionFX::Loc' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, ImpactNormal) == 0x00000C, "Member 'FCrabExplosionFX::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Radius) == 0x000018, "Member 'FCrabExplosionFX::Radius' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, FX) == 0x000020, "Member 'FCrabExplosionFX::FX' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Tint) == 0x000028, "Member 'FCrabExplosionFX::Tint' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Sound) == 0x000038, "Member 'FCrabExplosionFX::Sound' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, CameraShake) == 0x000040, "Member 'FCrabExplosionFX::CameraShake' has a wrong offset!");

// ScriptStruct CrabChampions.CrabVideoSettings
// 0x0110 (0x0110 - 0x0000)
struct FCrabVideoSettings final
{
public:
	class FString                                 DisplayMode;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Resolution;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResolutionQuality;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FPSLimit;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VSync;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldOfView;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GraphicsQuality;                                   // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponEffects;                                     // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AntiAliasingType;                                  // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sharpening;                                        // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MotionBlur;                                        // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShake;                                       // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hitmarkers;                                        // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageNumbers;                                     // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextChatVisibility;                                // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShowFPS;                                           // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PauseWhenLosingFocus;                              // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabVideoSettings) == 0x000008, "Wrong alignment on FCrabVideoSettings");
static_assert(sizeof(FCrabVideoSettings) == 0x000110, "Wrong size on FCrabVideoSettings");
static_assert(offsetof(FCrabVideoSettings, DisplayMode) == 0x000000, "Member 'FCrabVideoSettings::DisplayMode' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Resolution) == 0x000010, "Member 'FCrabVideoSettings::Resolution' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, ResolutionQuality) == 0x000020, "Member 'FCrabVideoSettings::ResolutionQuality' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, FPSLimit) == 0x000030, "Member 'FCrabVideoSettings::FPSLimit' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, VSync) == 0x000040, "Member 'FCrabVideoSettings::VSync' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, FieldOfView) == 0x000050, "Member 'FCrabVideoSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, GraphicsQuality) == 0x000060, "Member 'FCrabVideoSettings::GraphicsQuality' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, WeaponEffects) == 0x000070, "Member 'FCrabVideoSettings::WeaponEffects' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, AntiAliasingType) == 0x000080, "Member 'FCrabVideoSettings::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Sharpening) == 0x000090, "Member 'FCrabVideoSettings::Sharpening' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, MotionBlur) == 0x0000A0, "Member 'FCrabVideoSettings::MotionBlur' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, CameraShake) == 0x0000B0, "Member 'FCrabVideoSettings::CameraShake' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Hitmarkers) == 0x0000C0, "Member 'FCrabVideoSettings::Hitmarkers' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, DamageNumbers) == 0x0000D0, "Member 'FCrabVideoSettings::DamageNumbers' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, TextChatVisibility) == 0x0000E0, "Member 'FCrabVideoSettings::TextChatVisibility' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, ShowFPS) == 0x0000F0, "Member 'FCrabVideoSettings::ShowFPS' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, PauseWhenLosingFocus) == 0x000100, "Member 'FCrabVideoSettings::PauseWhenLosingFocus' has a wrong offset!");

// ScriptStruct CrabChampions.CrabKeyBind
// 0x0070 (0x0070 - 0x0000)
struct FCrabKeyBind final
{
public:
	class FName                                   MappingName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyBindTitle;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAxisMapping;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   KeyboardKey;                                       // 0x0020(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyboardKeyFriendlyName;                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ControllerKey;                                     // 0x0048(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ControllerIcon;                                    // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeRemapped;                                    // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabKeyBind) == 0x000008, "Wrong alignment on FCrabKeyBind");
static_assert(sizeof(FCrabKeyBind) == 0x000070, "Wrong size on FCrabKeyBind");
static_assert(offsetof(FCrabKeyBind, MappingName) == 0x000000, "Member 'FCrabKeyBind::MappingName' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyBindTitle) == 0x000008, "Member 'FCrabKeyBind::KeyBindTitle' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, bAxisMapping) == 0x000018, "Member 'FCrabKeyBind::bAxisMapping' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyboardKey) == 0x000020, "Member 'FCrabKeyBind::KeyboardKey' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyboardKeyFriendlyName) == 0x000038, "Member 'FCrabKeyBind::KeyboardKeyFriendlyName' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, ControllerKey) == 0x000048, "Member 'FCrabKeyBind::ControllerKey' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, ControllerIcon) == 0x000060, "Member 'FCrabKeyBind::ControllerIcon' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, bCanBeRemapped) == 0x000068, "Member 'FCrabKeyBind::bCanBeRemapped' has a wrong offset!");

// ScriptStruct CrabChampions.CrabWeaponInfo
// 0x0018 (0x0018 - 0x0000)
struct FCrabWeaponInfo final
{
public:
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 OwningC;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDualWieldWeapon;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabWeaponInfo) == 0x000008, "Wrong alignment on FCrabWeaponInfo");
static_assert(sizeof(FCrabWeaponInfo) == 0x000018, "Wrong size on FCrabWeaponInfo");
static_assert(offsetof(FCrabWeaponInfo, WeaponDA) == 0x000000, "Member 'FCrabWeaponInfo::WeaponDA' has a wrong offset!");
static_assert(offsetof(FCrabWeaponInfo, OwningC) == 0x000008, "Member 'FCrabWeaponInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabWeaponInfo, bIsDualWieldWeapon) == 0x000010, "Member 'FCrabWeaponInfo::bIsDualWieldWeapon' has a wrong offset!");

}

